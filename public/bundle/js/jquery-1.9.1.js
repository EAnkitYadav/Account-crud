/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/jquery-1.9.1.js":
/*!**************************************!*\
  !*** ./resources/js/jquery-1.9.1.js ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v1.9.1\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-2-4\n */\n(function (window, undefined) {\n  // Can't do this because several apps including ASP.NET trace\n  // the stack via arguments.caller.callee and Firefox dies if\n  // you try to trace through \"use strict\" call chains. (#13335)\n  // Support: Firefox 18+\n  //\"use strict\";\n  var // The deferred used on DOM ready\n  readyList,\n      // A central reference to the root jQuery(document)\n  rootjQuery,\n      // Support: IE<9\n  // For `typeof node.method` instead of `node.method !== undefined`\n  core_strundefined = _typeof(undefined),\n      // Use the correct document accordingly with window argument (sandbox)\n  document = window.document,\n      location = window.location,\n      // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$,\n      // [[Class]] -> type pairs\n  class2type = {},\n      // List of deleted data cache ids, so we can reuse them\n  core_deletedIds = [],\n      core_version = \"1.9.1\",\n      // Save a reference to some core methods\n  core_concat = core_deletedIds.concat,\n      core_push = core_deletedIds.push,\n      core_slice = core_deletedIds.slice,\n      core_indexOf = core_deletedIds.indexOf,\n      core_toString = class2type.toString,\n      core_hasOwn = class2type.hasOwnProperty,\n      core_trim = core_version.trim,\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    return new jQuery.fn.init(selector, context, rootjQuery);\n  },\n      // Used for matching numbers\n  core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      // Used for splitting on whitespace\n  core_rnotwhite = /\\S+/g,\n      // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  rquickExpr = /^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      // Match a standalone tag\n  rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      // JSON RegExp\n  rvalidchars = /^[\\],:{}\\s]*$/,\n      rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n      rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n      rvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n      // Matches dashed string for camelizing\n  rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([\\da-z])/gi,\n      // Used by jQuery.camelCase as callback to replace()\n  fcamelCase = function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  },\n      // The ready event handler\n  completed = function completed(event) {\n    // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n    if (document.addEventListener || event.type === \"load\" || document.readyState === \"complete\") {\n      detach();\n      jQuery.ready();\n    }\n  },\n      // Clean-up method for dom ready events\n  detach = function detach() {\n    if (document.addEventListener) {\n      document.removeEventListener(\"DOMContentLoaded\", completed, false);\n      window.removeEventListener(\"load\", completed, false);\n    } else {\n      document.detachEvent(\"onreadystatechange\", completed);\n      window.detachEvent(\"onload\", completed);\n    }\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: core_version,\n    constructor: jQuery,\n    init: function init(selector, context, rootjQuery) {\n      var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n      if (!selector) {\n        return this;\n      } // Handle HTML strings\n\n\n      if (typeof selector === \"string\") {\n        if (selector.charAt(0) === \"<\" && selector.charAt(selector.length - 1) === \">\" && selector.length >= 3) {\n          // Assume that strings that start and end with <> are HTML and skip the regex check\n          match = [null, selector, null];\n        } else {\n          match = rquickExpr.exec(selector);\n        } // Match html or make sure no context is specified for #id\n\n\n        if (match && (match[1] || !context)) {\n          // HANDLE: $(html) -> $(array)\n          if (match[1]) {\n            context = context instanceof jQuery ? context[0] : context; // scripts is true for back-compat\n\n            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n              for (match in context) {\n                // Properties of context are called as methods if possible\n                if (jQuery.isFunction(this[match])) {\n                  this[match](context[match]); // ...and otherwise set as attributes\n                } else {\n                  this.attr(match, context[match]);\n                }\n              }\n            }\n\n            return this; // HANDLE: $(#id)\n          } else {\n            elem = document.getElementById(match[2]); // Check parentNode to catch when Blackberry 4.6 returns\n            // nodes that are no longer in the document #6963\n\n            if (elem && elem.parentNode) {\n              // Handle the case where IE and Opera return items\n              // by name instead of ID\n              if (elem.id !== match[2]) {\n                return rootjQuery.find(selector);\n              } // Otherwise, we inject the element directly into the jQuery object\n\n\n              this.length = 1;\n              this[0] = elem;\n            }\n\n            this.context = document;\n            this.selector = selector;\n            return this;\n          } // HANDLE: $(expr, $(...))\n\n        } else if (!context || context.jquery) {\n          return (context || rootjQuery).find(selector); // HANDLE: $(expr, context)\n          // (which is just equivalent to: $(context).find(expr)\n        } else {\n          return this.constructor(context).find(selector);\n        } // HANDLE: $(DOMElement)\n\n      } else if (selector.nodeType) {\n        this.context = this[0] = selector;\n        this.length = 1;\n        return this; // HANDLE: $(function)\n        // Shortcut for document ready\n      } else if (jQuery.isFunction(selector)) {\n        return rootjQuery.ready(selector);\n      }\n\n      if (selector.selector !== undefined) {\n        this.selector = selector.selector;\n        this.context = selector.context;\n      }\n\n      return jQuery.makeArray(selector, this);\n    },\n    // Start with an empty selector\n    selector: \"\",\n    // The default length of a jQuery object is 0\n    length: 0,\n    // The number of elements contained in the matched element set\n    size: function size() {\n      return this.length;\n    },\n    toArray: function toArray() {\n      return core_slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      return num == null ? // Return a 'clean' array\n      this.toArray() : // Return just the object\n      num < 0 ? this[this.length + num] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this;\n      ret.context = this.context; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    // (You can seed the arguments with an array of args, but this is\n    // only used internally.)\n    each: function each(callback, args) {\n      return jQuery.each(this, callback, args);\n    },\n    ready: function ready(fn) {\n      // Add the callback\n      jQuery.ready.promise().done(fn);\n      return this;\n    },\n    slice: function slice() {\n      return this.pushStack(core_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    end: function end() {\n      return this.prevObject || this.constructor(null);\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: core_push,\n    sort: [].sort,\n    splice: [].splice\n  }; // Give the init function the jQuery prototype for later instantiation\n\n  jQuery.fn.init.prototype = jQuery.fn;\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var src,\n        copyIsArray,\n        copy,\n        name,\n        options,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target;\n      target = arguments[1] || {}; // skip the boolean and the target\n\n      i = 2;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !jQuery.isFunction(target)) {\n      target = {};\n    } // extend jQuery itself if only one argument is passed\n\n\n    if (length === i) {\n      target = this;\n      --i;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name]; // Prevent never-ending loop\n\n          if (target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && jQuery.isArray(src) ? src : [];\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    noConflict: function noConflict(deep) {\n      if (window.$ === jQuery) {\n        window.$ = _$;\n      }\n\n      if (deep && window.jQuery === jQuery) {\n        window.jQuery = _jQuery;\n      }\n\n      return jQuery;\n    },\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Hold (or release) the ready event\n    holdReady: function holdReady(hold) {\n      if (hold) {\n        jQuery.readyWait++;\n      } else {\n        jQuery.ready(true);\n      }\n    },\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\n\n      if (!document.body) {\n        return setTimeout(jQuery.ready);\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events\n\n      if (jQuery.fn.trigger) {\n        jQuery(document).trigger(\"ready\").off(\"ready\");\n      }\n    },\n    // See test/unit/core.js for details concerning isFunction.\n    // Since version 1.3, DOM methods and functions like alert\n    // aren't supported. They return false on IE (#2968).\n    isFunction: function isFunction(obj) {\n      return jQuery.type(obj) === \"function\";\n    },\n    isArray: Array.isArray || function (obj) {\n      return jQuery.type(obj) === \"array\";\n    },\n    isWindow: function isWindow(obj) {\n      return obj != null && obj == obj.window;\n    },\n    isNumeric: function isNumeric(obj) {\n      return !isNaN(parseFloat(obj)) && isFinite(obj);\n    },\n    type: function type(obj) {\n      if (obj == null) {\n        return String(obj);\n      }\n\n      return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[core_toString.call(obj)] || \"object\" : _typeof(obj);\n    },\n    isPlainObject: function isPlainObject(obj) {\n      // Must be an Object.\n      // Because of IE, we also have to check the presence of the constructor property.\n      // Make sure that DOM nodes and window objects don't pass through, as well\n      if (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n        return false;\n      }\n\n      try {\n        // Not own constructor property must be Object\n        if (obj.constructor && !core_hasOwn.call(obj, \"constructor\") && !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n          return false;\n        }\n      } catch (e) {\n        // IE8,9 Will throw exceptions on certain host objects #9897\n        return false;\n      } // Own properties are enumerated firstly, so to speed up,\n      // if last one is own, then all properties are own.\n\n\n      var key;\n\n      for (key in obj) {}\n\n      return key === undefined || core_hasOwn.call(obj, key);\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    // data: string of html\n    // context (optional): If specified, the fragment will be created in this context, defaults to document\n    // keepScripts (optional): If true, will include scripts passed in the html string\n    parseHTML: function parseHTML(data, context, keepScripts) {\n      if (!data || typeof data !== \"string\") {\n        return null;\n      }\n\n      if (typeof context === \"boolean\") {\n        keepScripts = context;\n        context = false;\n      }\n\n      context = context || document;\n      var parsed = rsingleTag.exec(data),\n          scripts = !keepScripts && []; // Single tag\n\n      if (parsed) {\n        return [context.createElement(parsed[1])];\n      }\n\n      parsed = jQuery.buildFragment([data], context, scripts);\n\n      if (scripts) {\n        jQuery(scripts).remove();\n      }\n\n      return jQuery.merge([], parsed.childNodes);\n    },\n    parseJSON: function parseJSON(data) {\n      // Attempt to parse using the native JSON parser first\n      if (window.JSON && window.JSON.parse) {\n        return window.JSON.parse(data);\n      }\n\n      if (data === null) {\n        return data;\n      }\n\n      if (typeof data === \"string\") {\n        // Make sure leading/trailing whitespace is removed (IE can't handle it)\n        data = jQuery.trim(data);\n\n        if (data) {\n          // Make sure the incoming data is actual JSON\n          // Logic borrowed from http://json.org/json2.js\n          if (rvalidchars.test(data.replace(rvalidescape, \"@\").replace(rvalidtokens, \"]\").replace(rvalidbraces, \"\"))) {\n            return new Function(\"return \" + data)();\n          }\n        }\n      }\n\n      jQuery.error(\"Invalid JSON: \" + data);\n    },\n    // Cross-browser xml parsing\n    parseXML: function parseXML(data) {\n      var xml, tmp;\n\n      if (!data || typeof data !== \"string\") {\n        return null;\n      }\n\n      try {\n        if (window.DOMParser) {\n          // Standard\n          tmp = new DOMParser();\n          xml = tmp.parseFromString(data, \"text/xml\");\n        } else {\n          // IE\n          xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n          xml.async = \"false\";\n          xml.loadXML(data);\n        }\n      } catch (e) {\n        xml = undefined;\n      }\n\n      if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length) {\n        jQuery.error(\"Invalid XML: \" + data);\n      }\n\n      return xml;\n    },\n    noop: function noop() {},\n    // Evaluates a script in a global context\n    // Workarounds based on findings by Jim Driscoll\n    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n    globalEval: function globalEval(data) {\n      if (data && jQuery.trim(data)) {\n        // We use execScript on Internet Explorer\n        // We use an anonymous function so that context is window\n        // rather than jQuery in Firefox\n        (window.execScript || function (data) {\n          window[\"eval\"].call(window, data);\n        })(data);\n      }\n    },\n    // Convert dashed to camelCase; used by the css and data modules\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function camelCase(string) {\n      return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n    },\n    nodeName: function nodeName(elem, name) {\n      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    },\n    // args is for internal usage only\n    each: function each(obj, callback, args) {\n      var value,\n          i = 0,\n          length = obj.length,\n          isArray = isArraylike(obj);\n\n      if (args) {\n        if (isArray) {\n          for (; i < length; i++) {\n            value = callback.apply(obj[i], args);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } else {\n          for (i in obj) {\n            value = callback.apply(obj[i], args);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } // A special, fast, case for the most common use of each\n\n      } else {\n        if (isArray) {\n          for (; i < length; i++) {\n            value = callback.call(obj[i], i, obj[i]);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } else {\n          for (i in obj) {\n            value = callback.call(obj[i], i, obj[i]);\n\n            if (value === false) {\n              break;\n            }\n          }\n        }\n      }\n\n      return obj;\n    },\n    // Use native String.trim function wherever possible\n    trim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ? function (text) {\n      return text == null ? \"\" : core_trim.call(text);\n    } : // Otherwise use our own trimming functionality\n    function (text) {\n      return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArraylike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          core_push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      var len;\n\n      if (arr) {\n        if (core_indexOf) {\n          return core_indexOf.call(arr, elem, i);\n        }\n\n        len = arr.length;\n        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\n        for (; i < len; i++) {\n          // Skip accessing in sparse arrays\n          if (i in arr && arr[i] === elem) {\n            return i;\n          }\n        }\n      }\n\n      return -1;\n    },\n    merge: function merge(first, second) {\n      var l = second.length,\n          i = first.length,\n          j = 0;\n\n      if (typeof l === \"number\") {\n        for (; j < l; j++) {\n          first[i++] = second[j];\n        }\n      } else {\n        while (second[j] !== undefined) {\n          first[i++] = second[j++];\n        }\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, inv) {\n      var retVal,\n          ret = [],\n          i = 0,\n          length = elems.length;\n      inv = !!inv; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        retVal = !!callback(elems[i], i);\n\n        if (inv !== retVal) {\n          ret.push(elems[i]);\n        }\n      }\n\n      return ret;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var value,\n          i = 0,\n          length = elems.length,\n          isArray = isArraylike(elems),\n          ret = []; // Go through the array, translating each of the items to their\n\n      if (isArray) {\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret[ret.length] = value;\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret[ret.length] = value;\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return core_concat.apply([], ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function proxy(fn, context) {\n      var args, proxy, tmp;\n\n      if (typeof context === \"string\") {\n        tmp = fn[context];\n        context = fn;\n        fn = tmp;\n      } // Quick check to determine if target is callable, in the spec\n      // this throws a TypeError, but we will just return undefined.\n\n\n      if (!jQuery.isFunction(fn)) {\n        return undefined;\n      } // Simulated bind\n\n\n      args = core_slice.call(arguments, 2);\n\n      proxy = function proxy() {\n        return fn.apply(context || this, args.concat(core_slice.call(arguments)));\n      }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n      proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n      return proxy;\n    },\n    // Multifunctional method to get and set values of a collection\n    // The value/s can optionally be executed if it's a function\n    access: function access(elems, fn, key, value, chainable, emptyGet, raw) {\n      var i = 0,\n          length = elems.length,\n          bulk = key == null; // Sets many values\n\n      if (jQuery.type(key) === \"object\") {\n        chainable = true;\n\n        for (i in key) {\n          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);\n        } // Sets one value\n\n      } else if (value !== undefined) {\n        chainable = true;\n\n        if (!jQuery.isFunction(value)) {\n          raw = true;\n        }\n\n        if (bulk) {\n          // Bulk operations run against the entire set\n          if (raw) {\n            fn.call(elems, value);\n            fn = null; // ...except when executing function values\n          } else {\n            bulk = fn;\n\n            fn = function fn(elem, key, value) {\n              return bulk.call(jQuery(elem), value);\n            };\n          }\n        }\n\n        if (fn) {\n          for (; i < length; i++) {\n            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n          }\n        }\n      }\n\n      return chainable ? elems : // Gets\n      bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;\n    },\n    now: function now() {\n      return new Date().getTime();\n    }\n  });\n\n  jQuery.ready.promise = function (obj) {\n    if (!readyList) {\n      readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred.\n      // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\n      if (document.readyState === \"complete\") {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        setTimeout(jQuery.ready); // Standards-based browsers support DOMContentLoaded\n      } else if (document.addEventListener) {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed, false); // A fallback to window.onload, that will always work\n\n        window.addEventListener(\"load\", completed, false); // If IE event model is used\n      } else {\n        // Ensure firing before onload, maybe late but safe also for iframes\n        document.attachEvent(\"onreadystatechange\", completed); // A fallback to window.onload, that will always work\n\n        window.attachEvent(\"onload\", completed); // If IE and not a frame\n        // continually check to see if the document is ready\n\n        var top = false;\n\n        try {\n          top = window.frameElement == null && document.documentElement;\n        } catch (e) {}\n\n        if (top && top.doScroll) {\n          (function doScrollCheck() {\n            if (!jQuery.isReady) {\n              try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n              } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n              } // detach all dom ready events\n\n\n              detach(); // and execute any waiting functions\n\n              jQuery.ready();\n            }\n          })();\n        }\n      }\n    }\n\n    return readyList.promise(obj);\n  }; // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArraylike(obj) {\n    var length = obj.length,\n        type = jQuery.type(obj);\n\n    if (jQuery.isWindow(obj)) {\n      return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n      return true;\n    }\n\n    return type === \"array\" || type !== \"function\" && (length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj);\n  } // All jQuery objects should point back to these\n\n\n  rootjQuery = jQuery(document); // String to Object options format cache\n\n  var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache\n\n  function createOptions(options) {\n    var object = optionsCache[options] = {};\n    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value (for non-forgettable lists)\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // End of the loop when firing\n    firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n    firingIndex,\n        // First callback to fire (used internally by add and fireWith)\n    firingStart,\n        // Actual callback list\n    list = [],\n        // Stack of fire calls for repeatable lists\n    stack = !options.once && [],\n        // Fire callbacks\n    fire = function fire(data) {\n      memory = options.memory && data;\n      _fired = true;\n      firingIndex = firingStart || 0;\n      firingStart = 0;\n      firingLength = list.length;\n      firing = true;\n\n      for (; list && firingIndex < firingLength; firingIndex++) {\n        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n          memory = false; // To prevent further calls using add\n\n          break;\n        }\n      }\n\n      firing = false;\n\n      if (list) {\n        if (stack) {\n          if (stack.length) {\n            fire(stack.shift());\n          }\n        } else if (memory) {\n          list = [];\n        } else {\n          self.disable();\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // First, we save the current length\n          var start = list.length;\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              var type = jQuery.type(arg);\n\n              if (type === \"function\") {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && type !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments); // Do we need to add the callbacks to the\n          // current firing batch?\n\n\n          if (firing) {\n            firingLength = list.length; // With memory, if we're not firing then\n            // we should call right away\n          } else if (memory) {\n            firingStart = start;\n            fire(memory);\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        if (list) {\n          jQuery.each(arguments, function (_, arg) {\n            var index;\n\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1); // Handle firing indexes\n\n              if (firing) {\n                if (index <= firingLength) {\n                  firingLength--;\n                }\n\n                if (index <= firingIndex) {\n                  firingIndex--;\n                }\n              }\n            }\n          });\n        }\n\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        list = [];\n        return this;\n      },\n      // Have the list do nothing anymore\n      disable: function disable() {\n        list = stack = memory = undefined;\n        return this;\n      },\n      // Is it disabled?\n      disabled: function disabled() {\n        return !list;\n      },\n      // Lock the list in its current state\n      lock: function lock() {\n        stack = undefined;\n\n        if (!memory) {\n          self.disable();\n        }\n\n        return this;\n      },\n      // Is it locked?\n      locked: function locked() {\n        return !stack;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        args = args || [];\n        args = [context, args.slice ? args.slice() : args];\n\n        if (list && (!_fired || stack)) {\n          if (firing) {\n            stack.push(args);\n          } else {\n            fire(args);\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, listener list, final state\n      [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        then: function\n          /* fnDone, fnFail, fnProgress */\n        then() {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n              var action = tuple[0],\n                  fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && jQuery.isFunction(returned.promise)) {\n                  returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n                } else {\n                  newDefer[action + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Keep pipe for back-compat\n\n      _promise.pipe = _promise.then; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = [ resolved | rejected ]\n            _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n        } // deferred[ resolve | reject | notify ]\n\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n          return this;\n        };\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(subordinate\n    /* , ..., subordinateN */\n    ) {\n      var i = 0,\n          resolveValues = core_slice.call(arguments),\n          length = resolveValues.length,\n          // the count of uncompleted subordinates\n      remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n          // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n          // Update function for both resolve and progress values\n      updateFunc = function updateFunc(i, contexts, values) {\n        return function (value) {\n          contexts[i] = this;\n          values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;\n\n          if (values === progressValues) {\n            deferred.notifyWith(contexts, values);\n          } else if (! --remaining) {\n            deferred.resolveWith(contexts, values);\n          }\n        };\n      },\n          progressValues,\n          progressContexts,\n          resolveContexts; // add listeners to Deferred subordinates; treat others as resolved\n\n\n      if (length > 1) {\n        progressValues = new Array(length);\n        progressContexts = new Array(length);\n        resolveContexts = new Array(length);\n\n        for (; i < length; i++) {\n          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n          } else {\n            --remaining;\n          }\n        }\n      } // if we're not waiting on anything, resolve the master\n\n\n      if (!remaining) {\n        deferred.resolveWith(resolveContexts, resolveValues);\n      }\n\n      return deferred.promise();\n    }\n  });\n\n  jQuery.support = function () {\n    var support,\n        all,\n        a,\n        input,\n        select,\n        fragment,\n        opt,\n        eventName,\n        isSupported,\n        i,\n        div = document.createElement(\"div\"); // Setup\n\n    div.setAttribute(\"className\", \"t\");\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\"; // Support tests won't run in some limited or non-browser environments\n\n    all = div.getElementsByTagName(\"*\");\n    a = div.getElementsByTagName(\"a\")[0];\n\n    if (!all || !a || !all.length) {\n      return {};\n    } // First batch of tests\n\n\n    select = document.createElement(\"select\");\n    opt = select.appendChild(document.createElement(\"option\"));\n    input = div.getElementsByTagName(\"input\")[0];\n    a.style.cssText = \"top:1px;float:left;opacity:.5\";\n    support = {\n      // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n      getSetAttribute: div.className !== \"t\",\n      // IE strips leading whitespace when .innerHTML is used\n      leadingWhitespace: div.firstChild.nodeType === 3,\n      // Make sure that tbody elements aren't automatically inserted\n      // IE will insert them into empty tables\n      tbody: !div.getElementsByTagName(\"tbody\").length,\n      // Make sure that link elements get serialized correctly by innerHTML\n      // This requires a wrapper element in IE\n      htmlSerialize: !!div.getElementsByTagName(\"link\").length,\n      // Get the style information from getAttribute\n      // (IE uses .cssText instead)\n      style: /top/.test(a.getAttribute(\"style\")),\n      // Make sure that URLs aren't manipulated\n      // (IE normalizes it by default)\n      hrefNormalized: a.getAttribute(\"href\") === \"/a\",\n      // Make sure that element opacity exists\n      // (IE uses filter instead)\n      // Use a regex to work around a WebKit issue. See #5145\n      opacity: /^0.5/.test(a.style.opacity),\n      // Verify style float existence\n      // (IE uses styleFloat instead of cssFloat)\n      cssFloat: !!a.style.cssFloat,\n      // Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n      checkOn: !!input.value,\n      // Make sure that a selected-by-default option has a working selected property.\n      // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n      optSelected: opt.selected,\n      // Tests for enctype support on a form (#6743)\n      enctype: !!document.createElement(\"form\").enctype,\n      // Makes sure cloning an html5 element does not cause problems\n      // Where outerHTML is undefined, this still works\n      html5Clone: document.createElement(\"nav\").cloneNode(true).outerHTML !== \"<:nav></:nav>\",\n      // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode\n      boxModel: document.compatMode === \"CSS1Compat\",\n      // Will be defined later\n      deleteExpando: true,\n      noCloneEvent: true,\n      inlineBlockNeedsLayout: false,\n      shrinkWrapBlocks: false,\n      reliableMarginRight: true,\n      boxSizingReliable: true,\n      pixelPosition: false\n    }; // Make sure checked status is properly cloned\n\n    input.checked = true;\n    support.noCloneChecked = input.cloneNode(true).checked; // Make sure that the options inside disabled selects aren't marked as disabled\n    // (WebKit marks them as disabled)\n\n    select.disabled = true;\n    support.optDisabled = !opt.disabled; // Support: IE<9\n\n    try {\n      delete div.test;\n    } catch (e) {\n      support.deleteExpando = false;\n    } // Check if we can trust getAttribute(\"value\")\n\n\n    input = document.createElement(\"input\");\n    input.setAttribute(\"value\", \"\");\n    support.input = input.getAttribute(\"value\") === \"\"; // Check if an input maintains its value after becoming a radio\n\n    input.value = \"t\";\n    input.setAttribute(\"type\", \"radio\");\n    support.radioValue = input.value === \"t\"; // #11217 - WebKit loses check when the name is after the checked attribute\n\n    input.setAttribute(\"checked\", \"t\");\n    input.setAttribute(\"name\", \"t\");\n    fragment = document.createDocumentFragment();\n    fragment.appendChild(input); // Check if a disconnected checkbox will retain its checked\n    // value of true after appended to the DOM (IE6/7)\n\n    support.appendChecked = input.checked; // WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE<9\n    // Opera does not clone events (and typeof div.attachEvent === undefined).\n    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\n    if (div.attachEvent) {\n      div.attachEvent(\"onclick\", function () {\n        support.noCloneEvent = false;\n      });\n      div.cloneNode(true).click();\n    } // Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n    // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php\n\n\n    for (i in {\n      submit: true,\n      change: true,\n      focusin: true\n    }) {\n      div.setAttribute(eventName = \"on\" + i, \"t\");\n      support[i + \"Bubbles\"] = eventName in window || div.attributes[eventName].expando === false;\n    }\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\"; // Run tests that need a body at doc ready\n\n    jQuery(function () {\n      var container,\n          marginDiv,\n          tds,\n          divReset = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",\n          body = document.getElementsByTagName(\"body\")[0];\n\n      if (!body) {\n        // Return for frameset docs that don't have a body\n        return;\n      }\n\n      container = document.createElement(\"div\");\n      container.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n      body.appendChild(container).appendChild(div); // Support: IE8\n      // Check if table cells still have offsetWidth/Height when they are set\n      // to display:none and there are still other visible table cells in a\n      // table row; if so, offsetWidth/Height are not reliable for use when\n      // determining if an element has been hidden directly using\n      // display:none (it is still safe to use offsets if a parent element is\n      // hidden; don safety goggles and see bug #4512 for more information).\n\n      div.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n      tds = div.getElementsByTagName(\"td\");\n      tds[0].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n      isSupported = tds[0].offsetHeight === 0;\n      tds[0].style.display = \"\";\n      tds[1].style.display = \"none\"; // Support: IE8\n      // Check if empty table cells still have offsetWidth/Height\n\n      support.reliableHiddenOffsets = isSupported && tds[0].offsetHeight === 0; // Check box-sizing and margin behavior\n\n      div.innerHTML = \"\";\n      div.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n      support.boxSizing = div.offsetWidth === 4;\n      support.doesNotIncludeMarginInBodyOffset = body.offsetTop !== 1; // Use window.getComputedStyle because jsdom on node.js will break without it.\n\n      if (window.getComputedStyle) {\n        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== \"1%\";\n        support.boxSizingReliable = (window.getComputedStyle(div, null) || {\n          width: \"4px\"\n        }).width === \"4px\"; // Check if div with explicit width and no margin-right incorrectly\n        // gets computed margin-right based on width of container. (#3333)\n        // Fails in WebKit before Feb 2011 nightlies\n        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\n        marginDiv = div.appendChild(document.createElement(\"div\"));\n        marginDiv.style.cssText = div.style.cssText = divReset;\n        marginDiv.style.marginRight = marginDiv.style.width = \"0\";\n        div.style.width = \"1px\";\n        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);\n      }\n\n      if (_typeof(div.style.zoom) !== core_strundefined) {\n        // Support: IE<8\n        // Check if natively block-level elements act like inline-block\n        // elements when setting their display to 'inline' and giving\n        // them layout\n        div.innerHTML = \"\";\n        div.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n        support.inlineBlockNeedsLayout = div.offsetWidth === 3; // Support: IE6\n        // Check if elements with layout shrink-wrap their children\n\n        div.style.display = \"block\";\n        div.innerHTML = \"<div></div>\";\n        div.firstChild.style.width = \"5px\";\n        support.shrinkWrapBlocks = div.offsetWidth !== 3;\n\n        if (support.inlineBlockNeedsLayout) {\n          // Prevent IE 6 from affecting layout for positioned elements #11048\n          // Prevent IE from shrinking the body in IE 7 mode #12869\n          // Support: IE<8\n          body.style.zoom = 1;\n        }\n      }\n\n      body.removeChild(container); // Null elements to avoid leaks in IE\n\n      container = div = tds = marginDiv = null;\n    }); // Null elements to avoid leaks in IE\n\n    all = select = fragment = opt = a = input = null;\n    return support;\n  }();\n\n  var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n      rmultiDash = /([A-Z])/g;\n\n  function internalData(elem, name, data, pvt\n  /* Internal Use Only */\n  ) {\n    if (!jQuery.acceptData(elem)) {\n      return;\n    }\n\n    var thisCache,\n        ret,\n        internalKey = jQuery.expando,\n        getByName = typeof name === \"string\",\n        // We have to handle DOM nodes and JS objects differently because IE6-7\n    // can't GC object references properly across the DOM-JS boundary\n    isNode = elem.nodeType,\n        // Only DOM nodes need the global jQuery cache; JS object data is\n    // attached directly to the object so GC can occur automatically\n    cache = isNode ? jQuery.cache : elem,\n        // Only defining an ID for JS objects if its cache already exists allows\n    // the code to shortcut on the same path as a DOM node with no cache\n    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey; // Avoid doing any more work than we need to when trying to get data on an\n    // object that has no data at all\n\n    if ((!id || !cache[id] || !pvt && !cache[id].data) && getByName && data === undefined) {\n      return;\n    }\n\n    if (!id) {\n      // Only DOM nodes need a new unique ID for each element since their data\n      // ends up in the global cache\n      if (isNode) {\n        elem[internalKey] = id = core_deletedIds.pop() || jQuery.guid++;\n      } else {\n        id = internalKey;\n      }\n    }\n\n    if (!cache[id]) {\n      cache[id] = {}; // Avoids exposing jQuery metadata on plain JS objects when the object\n      // is serialized using JSON.stringify\n\n      if (!isNode) {\n        cache[id].toJSON = jQuery.noop;\n      }\n    } // An object can be passed to jQuery.data instead of a key/value pair; this gets\n    // shallow copied over onto the existing cache\n\n\n    if (_typeof(name) === \"object\" || typeof name === \"function\") {\n      if (pvt) {\n        cache[id] = jQuery.extend(cache[id], name);\n      } else {\n        cache[id].data = jQuery.extend(cache[id].data, name);\n      }\n    }\n\n    thisCache = cache[id]; // jQuery data() is stored in a separate object inside the object's internal data\n    // cache in order to avoid key collisions between internal data and user-defined\n    // data.\n\n    if (!pvt) {\n      if (!thisCache.data) {\n        thisCache.data = {};\n      }\n\n      thisCache = thisCache.data;\n    }\n\n    if (data !== undefined) {\n      thisCache[jQuery.camelCase(name)] = data;\n    } // Check for both converted-to-camel and non-converted data property names\n    // If a data property was specified\n\n\n    if (getByName) {\n      // First Try to find as-is property data\n      ret = thisCache[name]; // Test for null|undefined property data\n\n      if (ret == null) {\n        // Try to find the camelCased property\n        ret = thisCache[jQuery.camelCase(name)];\n      }\n    } else {\n      ret = thisCache;\n    }\n\n    return ret;\n  }\n\n  function internalRemoveData(elem, name, pvt) {\n    if (!jQuery.acceptData(elem)) {\n      return;\n    }\n\n    var i,\n        l,\n        thisCache,\n        isNode = elem.nodeType,\n        // See jQuery.data for more information\n    cache = isNode ? jQuery.cache : elem,\n        id = isNode ? elem[jQuery.expando] : jQuery.expando; // If there is already no cache entry for this object, there is no\n    // purpose in continuing\n\n    if (!cache[id]) {\n      return;\n    }\n\n    if (name) {\n      thisCache = pvt ? cache[id] : cache[id].data;\n\n      if (thisCache) {\n        // Support array or space separated string names for data keys\n        if (!jQuery.isArray(name)) {\n          // try the string as a key before any manipulation\n          if (name in thisCache) {\n            name = [name];\n          } else {\n            // split the camel cased version by spaces unless a key with the spaces exists\n            name = jQuery.camelCase(name);\n\n            if (name in thisCache) {\n              name = [name];\n            } else {\n              name = name.split(\" \");\n            }\n          }\n        } else {\n          // If \"name\" is an array of keys...\n          // When data is initially created, via (\"key\", \"val\") signature,\n          // keys will be converted to camelCase.\n          // Since there is no way to tell _how_ a key was added, remove\n          // both plain key and camelCase key. #12786\n          // This will only penalize the array argument path.\n          name = name.concat(jQuery.map(name, jQuery.camelCase));\n        }\n\n        for (i = 0, l = name.length; i < l; i++) {\n          delete thisCache[name[i]];\n        } // If there is no data left in the cache, we want to continue\n        // and let the cache object itself get destroyed\n\n\n        if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {\n          return;\n        }\n      }\n    } // See jQuery.data for more information\n\n\n    if (!pvt) {\n      delete cache[id].data; // Don't destroy the parent cache unless the internal data object\n      // had been the only thing left in it\n\n      if (!isEmptyDataObject(cache[id])) {\n        return;\n      }\n    } // Destroy the cache\n\n\n    if (isNode) {\n      jQuery.cleanData([elem], true); // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n    } else if (jQuery.support.deleteExpando || cache != cache.window) {\n      delete cache[id]; // When all else fails, null\n    } else {\n      cache[id] = null;\n    }\n  }\n\n  jQuery.extend({\n    cache: {},\n    // Unique for each copy of jQuery on the page\n    // Non-digits removed to match rinlinejQuery\n    expando: \"jQuery\" + (core_version + Math.random()).replace(/\\D/g, \"\"),\n    // The following elements throw uncatchable exceptions if you\n    // attempt to add expando properties to them.\n    noData: {\n      \"embed\": true,\n      // Ban all objects except for Flash (which handle expandos)\n      \"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n      \"applet\": true\n    },\n    hasData: function hasData(elem) {\n      elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];\n      return !!elem && !isEmptyDataObject(elem);\n    },\n    data: function data(elem, name, _data) {\n      return internalData(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      return internalRemoveData(elem, name);\n    },\n    // For internal use only.\n    _data: function _data(elem, name, data) {\n      return internalData(elem, name, data, true);\n    },\n    _removeData: function _removeData(elem, name) {\n      return internalRemoveData(elem, name, true);\n    },\n    // A method for determining if a DOM node can handle the data expando\n    acceptData: function acceptData(elem) {\n      // Do not set data on non-element because it will not be cleared (#8335).\n      if (elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9) {\n        return false;\n      }\n\n      var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]; // nodes accept data unless otherwise specified; rejection can be conditional\n\n      return !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var attrs,\n          name,\n          elem = this[0],\n          i = 0,\n          data = null; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = jQuery.data(elem);\n\n          if (elem.nodeType === 1 && !jQuery._data(elem, \"parsedAttrs\")) {\n            attrs = elem.attributes;\n\n            for (; i < attrs.length; i++) {\n              name = attrs[i].name;\n\n              if (!name.indexOf(\"data-\")) {\n                name = jQuery.camelCase(name.slice(5));\n                dataAttr(elem, name, data[name]);\n              }\n            }\n\n            jQuery._data(elem, \"parsedAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          jQuery.data(this, key);\n        });\n      }\n\n      return jQuery.access(this, function (value) {\n        if (value === undefined) {\n          // Try to fetch any internally stored data first\n          return elem ? dataAttr(elem, key, jQuery.data(elem, key)) : null;\n        }\n\n        this.each(function () {\n          jQuery.data(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        jQuery.removeData(this, key);\n      });\n    }\n  });\n\n  function dataAttr(elem, key, data) {\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if (data === undefined && elem.nodeType === 1) {\n      var name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null : // Only convert to a number if it doesn't change the string\n          +data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        jQuery.data(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  } // checks a cache object for emptiness\n\n\n  function isEmptyDataObject(obj) {\n    var name;\n\n    for (name in obj) {\n      // if the public data object is empty, the private is still empty\n      if (name === \"data\" && jQuery.isEmptyObject(obj[name])) {\n        continue;\n      }\n\n      if (name !== \"toJSON\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = jQuery._data(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || jQuery.isArray(data)) {\n            queue = jQuery._data(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      hooks.cur = fn;\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return jQuery._data(elem, key) || jQuery._data(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          jQuery._removeData(elem, type + \"queue\");\n\n          jQuery._removeData(elem, key);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    // Based off of the plugin by Clint Helfers, with permission.\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\n    delay: function delay(time, type) {\n      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n      type = type || \"fx\";\n      return this.queue(type, function (next, hooks) {\n        var timeout = setTimeout(next, time);\n\n        hooks.stop = function () {\n          clearTimeout(timeout);\n        };\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = jQuery._data(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var nodeHook,\n      boolHook,\n      rclass = /[\\t\\r\\n]/g,\n      rreturn = /\\r/g,\n      rfocusable = /^(?:input|select|textarea|button|object)$/i,\n      rclickable = /^(?:a|area)$/i,\n      rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,\n      ruseDefault = /^(?:checked|selected)$/i,\n      getSetAttribute = jQuery.support.getSetAttribute,\n      getSetInput = jQuery.support.input;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    },\n    prop: function prop(name, value) {\n      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      name = jQuery.propFix[name] || name;\n      return this.each(function () {\n        // try/catch handles cases where IE balks (such as removing a property on window)\n        try {\n          this[name] = undefined;\n          delete this[name];\n        } catch (e) {}\n      });\n    },\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          clazz,\n          j,\n          i = 0,\n          len = this.length,\n          proceed = typeof value === \"string\" && value;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, this.className));\n        });\n      }\n\n      if (proceed) {\n        // The disjunction here is for better compressibility (see removeClass)\n        classes = (value || \"\").match(core_rnotwhite) || [];\n\n        for (; i < len; i++) {\n          elem = this[i];\n          cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \" \");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            }\n\n            elem.className = jQuery.trim(cur);\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          clazz,\n          j,\n          i = 0,\n          len = this.length,\n          proceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, this.className));\n        });\n      }\n\n      if (proceed) {\n        classes = (value || \"\").match(core_rnotwhite) || [];\n\n        for (; i < len; i++) {\n          elem = this[i]; // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \"\");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") >= 0) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            }\n\n            elem.className = value ? jQuery.trim(cur) : \"\";\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n          isBool = typeof stateVal === \"boolean\";\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        if (type === \"string\") {\n          // toggle individual class names\n          var className,\n              i = 0,\n              self = jQuery(this),\n              state = stateVal,\n              classNames = value.match(core_rnotwhite) || [];\n\n          while (className = classNames[i++]) {\n            // check each className given, space separated list\n            state = isBool ? state : !self.hasClass(className);\n            self[state ? \"addClass\" : \"removeClass\"](className);\n          } // Toggle whole class name\n\n        } else if (type === core_strundefined || type === \"boolean\") {\n          if (this.className) {\n            // store className if set\n            jQuery._data(this, \"__className__\", this.className);\n          } // If the element has a class name or if we're passed \"false\",\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          this.className = this.className || value === false ? \"\" : jQuery._data(this, \"__className__\") || \"\";\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className = \" \" + selector + \" \",\n          i = 0,\n          l = this.length;\n\n      for (; i < l; i++) {\n        if (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) >= 0) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    val: function val(value) {\n      var ret,\n          hooks,\n          isFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value;\n          return typeof ret === \"string\" ? // handle most common string cases\n          ret.replace(rreturn, \"\") : // handle cases where value is null/undef or number\n          ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      isFunction = jQuery.isFunction(value);\n      return this.each(function (i) {\n        var val,\n            self = jQuery(this);\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (isFunction) {\n          val = value.call(this, i, self.val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (jQuery.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          // attributes.value is undefined in Blackberry 4.7 but\n          // uses .value. See #6932\n          var val = elem.attributes.value;\n          return !val || val.specified ? elem.value : elem.text;\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\" || index < 0,\n              values = one ? null : [],\n              max = one ? index + 1 : options.length,\n              i = index < 0 ? max : one ? index : 0; // Loop through all the selected options\n\n          for (; i < max; i++) {\n            option = options[i]; // oldIE doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && ( // Don't return options that are disabled or in a disabled optgroup\n            jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var values = jQuery.makeArray(value);\n          jQuery(elem).find(\"option\").each(function () {\n            this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;\n          });\n\n          if (!values.length) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    },\n    attr: function attr(elem, name, value) {\n      var hooks,\n          notxml,\n          ret,\n          nType = elem.nodeType; // don't get/set attributes on text, comment and attribute nodes\n\n      if (!elem || nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (_typeof(elem.getAttribute) === core_strundefined) {\n        return jQuery.prop(elem, name, value);\n      }\n\n      notxml = nType !== 1 || !jQuery.isXMLDoc(elem); // All attributes are lowercase\n      // Grab necessary hook if one is defined\n\n      if (notxml) {\n        name = name.toLowerCase();\n        hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n        } else if (hooks && notxml && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        } else {\n          elem.setAttribute(name, value + \"\");\n          return value;\n        }\n      } else if (hooks && notxml && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      } else {\n        // In IE9+, Flash objects don't have .getAttribute (#12945)\n        // Support: IE9+\n        if (_typeof(elem.getAttribute) !== core_strundefined) {\n          ret = elem.getAttribute(name);\n        } // Non-existent attributes return null, we normalize to undefined\n\n\n        return ret == null ? undefined : ret;\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          propName,\n          i = 0,\n          attrNames = value && value.match(core_rnotwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          propName = jQuery.propFix[name] || name; // Boolean attributes get special treatment (#10870)\n\n          if (rboolean.test(name)) {\n            // Set corresponding property to false for boolean attributes\n            // Also clear defaultChecked/defaultSelected (if appropriate) for IE<8\n            if (!getSetAttribute && ruseDefault.test(name)) {\n              elem[jQuery.camelCase(\"default-\" + name)] = elem[propName] = false;\n            } else {\n              elem[propName] = false;\n            } // See #9699 for explanation of this approach (setting first, then removal)\n\n          } else {\n            jQuery.attr(elem, name, \"\");\n          }\n\n          elem.removeAttribute(getSetAttribute ? name : propName);\n        }\n      }\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n            // Setting the type on a radio button after the value resets the value in IE6-9\n            // Reset value to default in case type is set after value during creation\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    propFix: {\n      tabindex: \"tabIndex\",\n      readonly: \"readOnly\",\n      \"for\": \"htmlFor\",\n      \"class\": \"className\",\n      maxlength: \"maxLength\",\n      cellspacing: \"cellSpacing\",\n      cellpadding: \"cellPadding\",\n      rowspan: \"rowSpan\",\n      colspan: \"colSpan\",\n      usemap: \"useMap\",\n      frameborder: \"frameBorder\",\n      contenteditable: \"contentEditable\"\n    },\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          notxml,\n          nType = elem.nodeType; // don't get/set properties on text, comment and attribute nodes\n\n      if (!elem || nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);\n\n      if (notxml) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        } else {\n          return elem[name] = value;\n        }\n      } else {\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n          return ret;\n        } else {\n          return elem[name];\n        }\n      }\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          var attributeNode = elem.getAttributeNode(\"tabindex\");\n          return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined;\n        }\n      }\n    }\n  }); // Hook for boolean attributes\n\n  boolHook = {\n    get: function get(elem, name) {\n      var // Use .prop to determine if this attribute is understood as boolean\n      prop = jQuery.prop(elem, name),\n          // Fetch it accordingly\n      attr = typeof prop === \"boolean\" && elem.getAttribute(name),\n          detail = typeof prop === \"boolean\" ? getSetInput && getSetAttribute ? attr != null : // oldIE fabricates an empty string for missing boolean attributes\n      // and conflates checked/selected into attroperties\n      ruseDefault.test(name) ? elem[jQuery.camelCase(\"default-\" + name)] : !!attr : // fetch an attribute node for properties not recognized as boolean\n      elem.getAttributeNode(name);\n      return detail && detail.value !== false ? name.toLowerCase() : undefined;\n    },\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n        // IE<8 needs the *property* name\n        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name); // Use defaultChecked and defaultSelected for oldIE\n      } else {\n        elem[jQuery.camelCase(\"default-\" + name)] = elem[name] = true;\n      }\n\n      return name;\n    }\n  }; // fix oldIE value attroperty\n\n  if (!getSetInput || !getSetAttribute) {\n    jQuery.attrHooks.value = {\n      get: function get(elem, name) {\n        var ret = elem.getAttributeNode(name);\n        return jQuery.nodeName(elem, \"input\") ? // Ignore the value *property* by using defaultValue\n        elem.defaultValue : ret && ret.specified ? ret.value : undefined;\n      },\n      set: function set(elem, value, name) {\n        if (jQuery.nodeName(elem, \"input\")) {\n          // Does not return so that setAttribute is also used\n          elem.defaultValue = value;\n        } else {\n          // Use nodeHook if defined (#1954); otherwise setAttribute is fine\n          return nodeHook && nodeHook.set(elem, value, name);\n        }\n      }\n    };\n  } // IE6/7 do not support getting/setting some attributes with get/setAttribute\n\n\n  if (!getSetAttribute) {\n    // Use this for any attribute in IE6/7\n    // This fixes almost every IE6/7 issue\n    nodeHook = jQuery.valHooks.button = {\n      get: function get(elem, name) {\n        var ret = elem.getAttributeNode(name);\n        return ret && (name === \"id\" || name === \"name\" || name === \"coords\" ? ret.value !== \"\" : ret.specified) ? ret.value : undefined;\n      },\n      set: function set(elem, value, name) {\n        // Set the existing or create a new attribute node\n        var ret = elem.getAttributeNode(name);\n\n        if (!ret) {\n          elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));\n        }\n\n        ret.value = value += \"\"; // Break association with cloned elements by also using setAttribute (#9646)\n\n        return name === \"value\" || value === elem.getAttribute(name) ? value : undefined;\n      }\n    }; // Set contenteditable to false on removals(#10429)\n    // Setting to empty string throws an error as an invalid value\n\n    jQuery.attrHooks.contenteditable = {\n      get: nodeHook.get,\n      set: function set(elem, value, name) {\n        nodeHook.set(elem, value === \"\" ? false : value, name);\n      }\n    }; // Set width and height to auto instead of 0 on empty string( Bug #8150 )\n    // This is for removals\n\n    jQuery.each([\"width\", \"height\"], function (i, name) {\n      jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {\n        set: function set(elem, value) {\n          if (value === \"\") {\n            elem.setAttribute(name, \"auto\");\n            return value;\n          }\n        }\n      });\n    });\n  } // Some attributes require a special call on IE\n  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n\n  if (!jQuery.support.hrefNormalized) {\n    jQuery.each([\"href\", \"src\", \"width\", \"height\"], function (i, name) {\n      jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {\n        get: function get(elem) {\n          var ret = elem.getAttribute(name, 2);\n          return ret == null ? undefined : ret;\n        }\n      });\n    }); // href/src property should get the full normalized URL (#10299/#12915)\n\n    jQuery.each([\"href\", \"src\"], function (i, name) {\n      jQuery.propHooks[name] = {\n        get: function get(elem) {\n          return elem.getAttribute(name, 4);\n        }\n      };\n    });\n  }\n\n  if (!jQuery.support.style) {\n    jQuery.attrHooks.style = {\n      get: function get(elem) {\n        // Return undefined in the case of empty string\n        // Note: IE uppercases css property names, but if we were to .toLowerCase()\n        // .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n        return elem.style.cssText || undefined;\n      },\n      set: function set(elem, value) {\n        return elem.style.cssText = value + \"\";\n      }\n    };\n  } // Safari mis-reports the default selected property of an option\n  // Accessing the parent's selectedIndex property fixes it\n\n\n  if (!jQuery.support.optSelected) {\n    jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {\n      get: function get(elem) {\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex; // Make sure that it also works with optgroups, see #5701\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n\n        return null;\n      }\n    });\n  } // IE6/7 call enctype encoding\n\n\n  if (!jQuery.support.enctype) {\n    jQuery.propFix.enctype = \"encoding\";\n  } // Radios and checkboxes getter/setter\n\n\n  if (!jQuery.support.checkOn) {\n    jQuery.each([\"radio\", \"checkbox\"], function () {\n      jQuery.valHooks[this] = {\n        get: function get(elem) {\n          // Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n          return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n        }\n      };\n    });\n  }\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {\n      set: function set(elem, value) {\n        if (jQuery.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\n        }\n      }\n    });\n  });\n  var rformElems = /^(?:input|select|textarea)$/i,\n      rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|contextmenu)|click/,\n      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var tmp,\n          events,\n          t,\n          handleObjIn,\n          special,\n          eventHandle,\n          handleObj,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = jQuery._data(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)\n\n\n      if (!elemData) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return _typeof(jQuery) !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;\n        }; // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\n\n        eventHandle.elem = elem;\n      } // Handle multiple events separated by a space\n      // jQuery(...).bind(\"mouseover mouseout\", fn);\n\n\n      types = (types || \"\").match(core_rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // If event changes its type, use the special event handlers for the changed type\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            // Bind the global event handler to the element\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle, false);\n            } else if (elem.attachEvent) {\n              elem.attachEvent(\"on\" + type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      } // Nullify elem to prevent memory leaks in IE\n\n\n      elem = null;\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          handleObj,\n          tmp,\n          origCount,\n          t,\n          events,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = jQuery.hasData(elem) && jQuery._data(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(core_rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        delete elemData.handle; // removeData also checks for emptiness and clears the expando if empty\n        // so use it instead of delete\n\n        jQuery._removeData(elem, \"events\");\n      }\n    },\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var handle,\n          ontype,\n          cur,\n          bubbleType,\n          special,\n          tmp,\n          i,\n          eventPath = [elem || document],\n          type = core_hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = core_hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") >= 0) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event);\n      event.isTrigger = true;\n      event.namespace = namespaces.join(\".\");\n      event.namespace_re = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (jQuery._data(cur, \"events\") || {})[event.type] && jQuery._data(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {\n          event.preventDefault();\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === \"click\" && jQuery.nodeName(elem, \"a\")) && jQuery.acceptData(elem)) {\n          // Call a native DOM method on the target with the same name name as the event.\n          // Can't use an .isFunction() check here because IE6/7 fails that test.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && elem[type] && !jQuery.isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            try {\n              elem[type]();\n            } catch (e) {// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n              // only reproducible on winXP IE8 native, not IE9 in IE8 mode\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    dispatch: function dispatch(event) {\n      // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(event);\n      var i,\n          ret,\n          handleObj,\n          matched,\n          j,\n          handlerQueue = [],\n          args = core_slice.call(arguments),\n          handlers = (jQuery._data(this, \"events\") || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // Triggered event must either 1) have no namespace, or\n          // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var sel,\n          handleObj,\n          matches,\n          i,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n      // Black-hole SVG <use> instance trees (#13180)\n      // Avoid non-left-click bubbling in Firefox (#3861)\n\n      if (delegateCount && cur.nodeType && (!event.button || event.type !== \"click\")) {\n        for (; cur != this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\")) {\n            matches = [];\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matches[sel] === undefined) {\n                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matches[sel]) {\n                matches.push(handleObj);\n              }\n            }\n\n            if (matches.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matches\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: this,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    fix: function fix(event) {\n      if (event[jQuery.expando]) {\n        return event;\n      } // Create a writable copy of the event object and normalize some properties\n\n\n      var i,\n          prop,\n          copy,\n          type = event.type,\n          originalEvent = event,\n          fixHook = this.fixHooks[type];\n\n      if (!fixHook) {\n        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\n      }\n\n      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n      event = new jQuery.Event(originalEvent);\n      i = copy.length;\n\n      while (i--) {\n        prop = copy[i];\n        event[prop] = originalEvent[prop];\n      } // Support: IE<9\n      // Fix target property (#1925)\n\n\n      if (!event.target) {\n        event.target = originalEvent.srcElement || document;\n      } // Support: Chrome 23+, Safari?\n      // Target should not be a text node (#504, #13143)\n\n\n      if (event.target.nodeType === 3) {\n        event.target = event.target.parentNode;\n      } // Support: IE<9\n      // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\n\n      event.metaKey = !!event.metaKey;\n      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n    },\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n    fixHooks: {},\n    keyHooks: {\n      props: \"char charCode key keyCode\".split(\" \"),\n      filter: function filter(event, original) {\n        // Add which for key events\n        if (event.which == null) {\n          event.which = original.charCode != null ? original.charCode : original.keyCode;\n        }\n\n        return event;\n      }\n    },\n    mouseHooks: {\n      props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n      filter: function filter(event, original) {\n        var body,\n            eventDoc,\n            doc,\n            button = original.button,\n            fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available\n\n        if (event.pageX == null && original.clientX != null) {\n          eventDoc = event.target.ownerDocument || document;\n          doc = eventDoc.documentElement;\n          body = eventDoc.body;\n          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n        } // Add relatedTarget, if necessary\n\n\n        if (!event.relatedTarget && fromElement) {\n          event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n        } // Add which for click: 1 === left; 2 === middle; 3 === right\n        // Note: button is not normalized, so don't use it\n\n\n        if (!event.which && button !== undefined) {\n          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n        }\n\n        return event;\n      }\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // For checkbox, fire native event so checked state will be right\n        trigger: function trigger() {\n          if (jQuery.nodeName(this, \"input\") && this.type === \"checkbox\" && this.click) {\n            this.click();\n            return false;\n          }\n        }\n      },\n      focus: {\n        // Fire native event if possible so blur/focus sequence is correct\n        trigger: function trigger() {\n          if (this !== document.activeElement && this.focus) {\n            try {\n              this.focus();\n              return false;\n            } catch (e) {// Support: IE<9\n              // If we error on focus to hidden element (#1486, #12518),\n              // let .trigger() run the handlers\n            }\n          }\n        },\n        delegateType: \"focusin\"\n      },\n      blur: {\n        trigger: function trigger() {\n          if (this === document.activeElement && this.blur) {\n            this.blur();\n            return false;\n          }\n        },\n        delegateType: \"focusout\"\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Even when returnValue equals to undefined Firefox will still show alert\n          if (event.result !== undefined) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    },\n    simulate: function simulate(type, elem, event, bubble) {\n      // Piggyback on a donor event to simulate a different one.\n      // Fake originalEvent to avoid donor's stopPropagation, but if the\n      // simulated event prevents default then we do the same on the donor.\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true,\n        originalEvent: {}\n      });\n\n      if (bubble) {\n        jQuery.event.trigger(e, null, elem);\n      } else {\n        jQuery.event.dispatch.call(elem, e);\n      }\n\n      if (e.isDefaultPrevented()) {\n        event.preventDefault();\n      }\n    }\n  };\n  jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle, false);\n    }\n  } : function (elem, type, handle) {\n    var name = \"on\" + type;\n\n    if (elem.detachEvent) {\n      // #8545, #7054, preventing memory leaks for custom events in IE6-8\n      // detachEvent needed property on element, by name of that event, to properly expose it to GC\n      if (_typeof(elem[name]) === core_strundefined) {\n        elem[name] = null;\n      }\n\n      elem.detachEvent(name, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (!e) {\n        return;\n      } // If preventDefault exists, run it on the original event\n\n\n      if (e.preventDefault) {\n        e.preventDefault(); // Support: IE\n        // Otherwise set the returnValue property of the original event to false\n      } else {\n        e.returnValue = false;\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (!e) {\n        return;\n      } // If stopPropagation exists, run it on the original event\n\n\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } // Support: IE\n      // Set the cancelBubble property of the original event to true\n\n\n      e.cancelBubble = true;\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      this.isImmediatePropagationStopped = returnTrue;\n      this.stopPropagation();\n    }\n  }; // Create mouseenter/leave events using mouseover/out and event-time checks\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mousenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  }); // IE submit delegation\n\n  if (!jQuery.support.submitBubbles) {\n    jQuery.event.special.submit = {\n      setup: function setup() {\n        // Only need this for delegated form submit events\n        if (jQuery.nodeName(this, \"form\")) {\n          return false;\n        } // Lazy-add a submit handler when a descendant form may potentially be submitted\n\n\n        jQuery.event.add(this, \"click._submit keypress._submit\", function (e) {\n          // Node name check avoids a VML-related crash in IE (#9807)\n          var elem = e.target,\n              form = jQuery.nodeName(elem, \"input\") || jQuery.nodeName(elem, \"button\") ? elem.form : undefined;\n\n          if (form && !jQuery._data(form, \"submitBubbles\")) {\n            jQuery.event.add(form, \"submit._submit\", function (event) {\n              event._submit_bubble = true;\n            });\n\n            jQuery._data(form, \"submitBubbles\", true);\n          }\n        }); // return undefined since we don't need an event listener\n      },\n      postDispatch: function postDispatch(event) {\n        // If form was submitted by the user, bubble the event up the tree\n        if (event._submit_bubble) {\n          delete event._submit_bubble;\n\n          if (this.parentNode && !event.isTrigger) {\n            jQuery.event.simulate(\"submit\", this.parentNode, event, true);\n          }\n        }\n      },\n      teardown: function teardown() {\n        // Only need this for delegated form submit events\n        if (jQuery.nodeName(this, \"form\")) {\n          return false;\n        } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\n\n        jQuery.event.remove(this, \"._submit\");\n      }\n    };\n  } // IE change delegation and checkbox/radio fix\n\n\n  if (!jQuery.support.changeBubbles) {\n    jQuery.event.special.change = {\n      setup: function setup() {\n        if (rformElems.test(this.nodeName)) {\n          // IE doesn't fire change on a check/radio until blur; trigger it on click\n          // after a propertychange. Eat the blur-change in special.change.handle.\n          // This still fires onchange a second time for check/radio after blur.\n          if (this.type === \"checkbox\" || this.type === \"radio\") {\n            jQuery.event.add(this, \"propertychange._change\", function (event) {\n              if (event.originalEvent.propertyName === \"checked\") {\n                this._just_changed = true;\n              }\n            });\n            jQuery.event.add(this, \"click._change\", function (event) {\n              if (this._just_changed && !event.isTrigger) {\n                this._just_changed = false;\n              } // Allow triggered, simulated change events (#11500)\n\n\n              jQuery.event.simulate(\"change\", this, event, true);\n            });\n          }\n\n          return false;\n        } // Delegated event; lazy-add a change handler on descendant inputs\n\n\n        jQuery.event.add(this, \"beforeactivate._change\", function (e) {\n          var elem = e.target;\n\n          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, \"changeBubbles\")) {\n            jQuery.event.add(elem, \"change._change\", function (event) {\n              if (this.parentNode && !event.isSimulated && !event.isTrigger) {\n                jQuery.event.simulate(\"change\", this.parentNode, event, true);\n              }\n            });\n\n            jQuery._data(elem, \"changeBubbles\", true);\n          }\n        });\n      },\n      handle: function handle(event) {\n        var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above\n\n        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== \"radio\" && elem.type !== \"checkbox\") {\n          return event.handleObj.handler.apply(this, arguments);\n        }\n      },\n      teardown: function teardown() {\n        jQuery.event.remove(this, \"._change\");\n        return !rformElems.test(this.nodeName);\n      }\n    };\n  } // Create \"bubbling\" focus and blur events\n\n\n  if (!jQuery.support.focusinBubbles) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler while someone wants focusin/focusout\n      var attaches = 0,\n          handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          if (attaches++ === 0) {\n            document.addEventListener(orig, handler, true);\n          }\n        },\n        teardown: function teardown() {\n          if (--attaches === 0) {\n            document.removeEventListener(orig, handler, true);\n          }\n        }\n      };\n    });\n  }\n\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn,\n    /*INTERNAL*/\n    one) {\n      var type, origFn; // Types can be a map of types/handlers\n\n      if (_typeof(types) === \"object\") {\n        // ( types-Object, selector, data )\n        if (typeof selector !== \"string\") {\n          // ( types-Object, data )\n          data = data || selector;\n          selector = undefined;\n        }\n\n        for (type in types) {\n          this.on(type, selector, data, types[type], one);\n        }\n\n        return this;\n      }\n\n      if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n      } else if (fn == null) {\n        if (typeof selector === \"string\") {\n          // ( types, selector, fn )\n          fn = data;\n          data = undefined;\n        } else {\n          // ( types, data, fn )\n          fn = data;\n          data = selector;\n          selector = undefined;\n        }\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      } else if (!fn) {\n        return this;\n      }\n\n      if (one === 1) {\n        origFn = fn;\n\n        fn = function fn(event) {\n          // Can use an empty set, since event contains the info\n          jQuery().off(event);\n          return origFn.apply(this, arguments);\n        }; // Use same guid so caller can remove using origFn\n\n\n        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n      }\n\n      return this.each(function () {\n        jQuery.event.add(this, types, fn, data, selector);\n      });\n    },\n    one: function one(types, selector, data, fn) {\n      return this.on(types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    },\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    },\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  });\n  /*!\n   * Sizzle CSS Selector Engine\n   * Copyright 2012 jQuery Foundation and other contributors\n   * Released under the MIT license\n   * http://sizzlejs.com/\n   */\n\n  (function (window, undefined) {\n    var i,\n        cachedruns,\n        Expr,\n        getText,\n        isXML,\n        compile,\n        hasDuplicate,\n        outermostContext,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsXML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        sortOrder,\n        // Instance-specific data\n    expando = \"sizzle\" + -new Date(),\n        preferredDoc = window.document,\n        support = {},\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        // General-purpose constants\n    strundefined = _typeof(undefined),\n        MAX_NEGATIVE = 1 << 31,\n        // Array methods\n    arr = [],\n        pop = arr.pop,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf if we can't use a native one\n    indexOf = arr.indexOf || function (elem) {\n      var i = 0,\n          len = this.length;\n\n      for (; i < len; i++) {\n        if (this[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        // Regular expressions\n    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // http://www.w3.org/TR/css3-syntax/#characters\n    characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        // Loosely modeled on CSS identifier characters\n    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = characterEncoding.replace(\"w\", \"w#\"),\n        // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n    operators = \"([*^$|!~]?=)\",\n        attributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace + \"*(?:\" + operators + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n        // Prefer arguments quoted,\n    //   then not containing pseudos/brackets,\n    //   then attribute selectors/non-parenthetical expressions,\n    //   then anything else\n    // These preferences are here to reduce the number of selectors\n    //   needing tokenize in the PSEUDO preFilter\n    pseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace(3, 8) + \")*)|.*)\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])\" + whitespace + \"*\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + characterEncoding + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + characterEncoding + \")\"),\n      \"NAME\": new RegExp(\"^\\\\[name=['\\\"]?(\" + characterEncoding + \")['\\\"]?\\\\]\"),\n      \"TAG\": new RegExp(\"^(\" + characterEncoding.replace(\"w\", \"w*\") + \")\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rsibling = /[\\x20\\t\\r\\n\\f]*[+~]/,\n        rnative = /^[^{]+\\{\\s*\\[native code/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rescape = /'|\\\\/g,\n        rattributeQuotes = /\\=[\\x20\\t\\r\\n\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n        funescape = function funescape(_, escaped) {\n      var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n\n      return high !== high ? escaped : // BMP codepoint\n      high < 0 ? String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    }; // Use a stripped-down slice if we can't use a native one\n\n\n    try {\n      slice.call(preferredDoc.documentElement.childNodes, 0)[0].nodeType;\n    } catch (e) {\n      slice = function slice(i) {\n        var elem,\n            results = [];\n\n        while (elem = this[i++]) {\n          results.push(elem);\n        }\n\n        return results;\n      };\n    }\n    /**\n     * For feature detection\n     * @param {Function} fn The function to test for native support\n     */\n\n\n    function isNative(fn) {\n      return rnative.test(fn + \"\");\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var _cache,\n          keys = [];\n\n      return _cache = function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key += \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete _cache[keys.shift()];\n        }\n\n        return _cache[key] = value;\n      };\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created div and expects a boolean result\n     */\n\n\n    function assert(fn) {\n      var div = document.createElement(\"div\");\n\n      try {\n        return fn(div);\n      } catch (e) {\n        return false;\n      } finally {\n        // release memory in IE\n        div = null;\n      }\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var match, elem, m, nodeType, // QSA vars\n      i, groups, old, nid, newContext, newSelector;\n\n      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n        setDocument(context);\n      }\n\n      context = context || document;\n      results = results || [];\n\n      if (!selector || typeof selector !== \"string\") {\n        return results;\n      }\n\n      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {\n        return [];\n      }\n\n      if (!documentIsXML && !seed) {\n        // Shortcuts\n        if (match = rquickExpr.exec(selector)) {\n          // Speed-up: Sizzle(\"#ID\")\n          if (m = match[1]) {\n            if (nodeType === 9) {\n              elem = context.getElementById(m); // Check parentNode to catch when Blackberry 4.6 returns\n              // nodes that are no longer in the document #6963\n\n              if (elem && elem.parentNode) {\n                // Handle the case where IE, Opera, and Webkit return items\n                // by name instead of ID\n                if (elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } else {\n                return results;\n              }\n            } else {\n              // Context is not a document\n              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                results.push(elem);\n                return results;\n              }\n            } // Speed-up: Sizzle(\"TAG\")\n\n          } else if (match[2]) {\n            push.apply(results, slice.call(context.getElementsByTagName(selector), 0));\n            return results; // Speed-up: Sizzle(\".CLASS\")\n          } else if ((m = match[3]) && support.getByClassName && context.getElementsByClassName) {\n            push.apply(results, slice.call(context.getElementsByClassName(m), 0));\n            return results;\n          }\n        } // QSA path\n\n\n        if (support.qsa && !rbuggyQSA.test(selector)) {\n          old = true;\n          nid = expando;\n          newContext = context;\n          newSelector = nodeType === 9 && selector; // qSA works strangely on Element-rooted queries\n          // We can work around this by specifying an extra ID on the root\n          // and working up from there (Thanks to Andrew Dupont for the technique)\n          // IE 8 doesn't work on object elements\n\n          if (nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n            groups = tokenize(selector);\n\n            if (old = context.getAttribute(\"id\")) {\n              nid = old.replace(rescape, \"\\\\$&\");\n            } else {\n              context.setAttribute(\"id\", nid);\n            }\n\n            nid = \"[id='\" + nid + \"'] \";\n            i = groups.length;\n\n            while (i--) {\n              groups[i] = nid + toSelector(groups[i]);\n            }\n\n            newContext = rsibling.test(selector) && context.parentNode || context;\n            newSelector = groups.join(\",\");\n          }\n\n          if (newSelector) {\n            try {\n              push.apply(results, slice.call(newContext.querySelectorAll(newSelector), 0));\n              return results;\n            } catch (qsaError) {} finally {\n              if (!old) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Detect xml\n     * @param {Element|Object} elem An element or a document\n     */\n\n\n    isXML = Sizzle.isXML = function (elem) {\n      // documentElement is verified for cases where it doesn't yet exist\n      // (such as loading iframes in IE - #4833)\n      var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n      return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var doc = node ? node.ownerDocument || node : preferredDoc; // If no document and documentElement is available, return\n\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Set our document\n\n\n      document = doc;\n      docElem = doc.documentElement; // Support tests\n\n      documentIsXML = isXML(doc); // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.tagNameNoComments = assert(function (div) {\n        div.appendChild(doc.createComment(\"\"));\n        return !div.getElementsByTagName(\"*\").length;\n      }); // Check if attributes should be retrieved by attribute nodes\n\n      support.attributes = assert(function (div) {\n        div.innerHTML = \"<select></select>\";\n\n        var type = _typeof(div.lastChild.getAttribute(\"multiple\")); // IE8 returns a string for some attributes even when not present\n\n\n        return type !== \"boolean\" && type !== \"string\";\n      }); // Check if getElementsByClassName can be trusted\n\n      support.getByClassName = assert(function (div) {\n        // Opera can't find a second classname (in 9.6)\n        div.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\";\n\n        if (!div.getElementsByClassName || !div.getElementsByClassName(\"e\").length) {\n          return false;\n        } // Safari 3.2 caches class attributes and doesn't catch changes\n\n\n        div.lastChild.className = \"e\";\n        return div.getElementsByClassName(\"e\").length === 2;\n      }); // Check if getElementById returns elements by name\n      // Check if getElementsByName privileges form controls or returns elements by ID\n\n      support.getByName = assert(function (div) {\n        // Inject content\n        div.id = expando + 0;\n        div.innerHTML = \"<a name='\" + expando + \"'></a><div name='\" + expando + \"'></div>\";\n        docElem.insertBefore(div, docElem.firstChild); // Test\n\n        var pass = doc.getElementsByName && // buggy browsers will return fewer than the correct 2\n        doc.getElementsByName(expando).length === 2 + // buggy browsers will return more than the correct 0\n        doc.getElementsByName(expando + 0).length;\n        support.getIdNotName = !doc.getElementById(expando); // Cleanup\n\n        docElem.removeChild(div);\n        return pass;\n      }); // IE6/7 return modified attributes\n\n      Expr.attrHandle = assert(function (div) {\n        div.innerHTML = \"<a href='#'></a>\";\n        return div.firstChild && _typeof(div.firstChild.getAttribute) !== strundefined && div.firstChild.getAttribute(\"href\") === \"#\";\n      }) ? {} : {\n        \"href\": function href(elem) {\n          return elem.getAttribute(\"href\", 2);\n        },\n        \"type\": function type(elem) {\n          return elem.getAttribute(\"type\");\n        }\n      }; // ID find and filter\n\n      if (support.getIdNotName) {\n        Expr.find[\"ID\"] = function (id, context) {\n          if (_typeof(context.getElementById) !== strundefined && !documentIsXML) {\n            var m = context.getElementById(id); // Check parentNode to catch when Blackberry 4.6 returns\n            // nodes that are no longer in the document #6963\n\n            return m && m.parentNode ? [m] : [];\n          }\n        };\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n      } else {\n        Expr.find[\"ID\"] = function (id, context) {\n          if (_typeof(context.getElementById) !== strundefined && !documentIsXML) {\n            var m = context.getElementById(id);\n            return m ? m.id === id || _typeof(m.getAttributeNode) !== strundefined && m.getAttributeNode(\"id\").value === id ? [m] : undefined : [];\n          }\n        };\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = _typeof(elem.getAttributeNode) !== strundefined && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.tagNameNoComments ? function (tag, context) {\n        if (_typeof(context.getElementsByTagName) !== strundefined) {\n          return context.getElementsByTagName(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Name\n\n      Expr.find[\"NAME\"] = support.getByName && function (tag, context) {\n        if (_typeof(context.getElementsByName) !== strundefined) {\n          return context.getElementsByName(name);\n        }\n      }; // Class\n\n\n      Expr.find[\"CLASS\"] = support.getByClassName && function (className, context) {\n        if (_typeof(context.getElementsByClassName) !== strundefined && !documentIsXML) {\n          return context.getElementsByClassName(className);\n        }\n      }; // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21),\n      // no need to also add to buggyMatches since matches checks buggyQSA\n      // A support test would require too much code (would include document ready)\n\n      rbuggyQSA = [\":focus\"];\n\n      if (support.qsa = isNative(doc.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (div) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explictly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // http://bugs.jquery.com/ticket/12359\n          div.innerHTML = \"<select><option selected=''></option></select>\"; // IE8 - Some boolean attributes are not treated correctly\n\n          if (!div.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          }\n        });\n        assert(function (div) {\n          // Opera 10-12/IE8 - ^= $= *= and empty values\n          // Should not select anything\n          div.innerHTML = \"<input type='hidden' i=''/>\";\n\n          if (div.querySelectorAll(\"[i^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:\\\"\\\"|'')\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":enabled\").length) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          div.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = isNative(matches = docElem.matchesSelector || docElem.mozMatchesSelector || docElem.webkitMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (div) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(div, \"div\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(div, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = new RegExp(rbuggyMatches.join(\"|\")); // Element contains another\n      // Purposefully does not implement inclusive descendent\n      // As in, an element does not contain itself\n\n      contains = isNative(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }; // Document order sorting\n\n      sortOrder = docElem.compareDocumentPosition ? function (a, b) {\n        var compare;\n\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        if (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b)) {\n          if (compare & 1 || a.parentNode && a.parentNode.nodeType === 11) {\n            if (a === doc || contains(preferredDoc, a)) {\n              return -1;\n            }\n\n            if (b === doc || contains(preferredDoc, b)) {\n              return 1;\n            }\n\n            return 0;\n          }\n\n          return compare & 4 ? -1 : 1;\n        }\n\n        return a.compareDocumentPosition ? -1 : 1;\n      } : function (a, b) {\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Exit early if the nodes are identical\n\n        if (a === b) {\n          hasDuplicate = true;\n          return 0; // Parentless nodes are either documents or disconnected\n        } else if (!aup || !bup) {\n          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      }; // Always assume the presence of duplicates if sort doesn't\n      // pass them to our comparison function (as in Google Chrome).\n\n      hasDuplicate = false;\n      [0, 0].sort(sortOrder);\n      support.detectDuplicates = hasDuplicate;\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      } // Make sure that attribute selectors are quoted\n\n\n      expr = expr.replace(rattributeQuotes, \"='$1']\"); // rbuggyQSA always contains :focus, so no need for an existence check\n\n      if (support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr)) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {}\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      var val; // Set document vars if needed\n\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      if (!documentIsXML) {\n        name = name.toLowerCase();\n      }\n\n      if (val = Expr.attrHandle[name]) {\n        return val(elem);\n      }\n\n      if (documentIsXML || support.attributes) {\n        return elem.getAttribute(name);\n      }\n\n      return ((val = elem.getAttributeNode(name)) || elem.getAttribute(name)) && elem[name] === true ? name : val && val.specified ? val.value : null;\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    }; // Document sorting and removing duplicates\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          i = 1,\n          j = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        for (; elem = results[i]; i++) {\n          if (elem === results[i - 1]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      }\n\n      return results;\n    };\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    } // Returns a function to use in pseudos for input types\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    } // Returns a function to use in pseudos for buttons\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    } // Returns a function to use in pseudos for positionals\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        for (; node = elem[i]; i++) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (see #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n              1 type (only|nth|...)\n              2 what (child|of-type)\n              3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n              4 xn-component of xn+y argument ([+-]?\\d*n|)\n              5 sign of xn-component\n              6 x of xn-component\n              7 sign of y-component\n              8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[5] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[4]) {\n            match[2] = match[4]; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeName) {\n          if (nodeName === \"*\") {\n            return function () {\n              return true;\n            };\n          }\n\n          nodeName = nodeName.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(elem.className || _typeof(elem.getAttribute) !== strundefined && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n          };\n        },\n        \"CHILD\": function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                outerCache,\n                node,\n                diff,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                outerCache = parent[expando] || (parent[expando] = {});\n                cache = outerCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = cache[0] === dirruns && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    outerCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                } // Use previously-cached element index if available\n\n              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\n                diff = cache[1]; // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n              } else {\n                // Use the same loop as above to seek `elem` from the start\n                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                    // Cache the index of each encountered element\n                    if (useCache) {\n                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];\n                    }\n\n                    if (node === elem) {\n                      break;\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf.call(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results);\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          return function (elem) {\n            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifider\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsXML ? elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\") : elem.lang) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": function enabled(elem) {\n          return elem.disabled === false;\n        },\n        \"disabled\": function disabled(elem) {\n          return elem.disabled === true;\n        },\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n          //   not comment, processing instructions, or others\n          // Thanks to Diego Perini for the nodeName shortcut\n          //   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr; // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n          // use getAttribute instead to test this case\n\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ((attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type);\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    }; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    }\n\n    function tokenize(selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    }\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          checkNonElements = base && dir === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var data,\n            cache,\n            outerCache,\n            dirkey = dirruns + \" \" + doneName; // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {});\n\n              if ((cache = outerCache[dir]) && cache[0] === dirkey) {\n                if ((data = cache[1]) === true || data === cachedruns) {\n                  return data === true;\n                }\n              } else {\n                cache = outerCache[dir] = [dirkey];\n                cache[1] = matcher(elem, context, xml) || cachedruns;\n\n                if (cache[1] === true) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf.call(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1)).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      // A counter to specify which element is currently being matched\n      var matcherCachedRuns = 0,\n          bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, expandContext) {\n        var elem,\n            j,\n            matcher,\n            setMatched = [],\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            outermost = expandContext != null,\n            contextBackup = outermostContext,\n            // We must always have either seed elements or context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", expandContext && context.parentNode || context),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;\n\n        if (outermost) {\n          outermostContext = context !== document && context;\n          cachedruns = matcherCachedRuns;\n        } // Add elements passing elementMatchers directly to results\n        // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\n\n        for (; (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n              cachedruns = ++matcherCachedRuns;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // Apply set filters to unmatched elements\n\n\n        matchedCount += i;\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, group\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!group) {\n          group = tokenize(selector);\n        }\n\n        i = group.length;\n\n        while (i--) {\n          cached = matcherFromTokens(group[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n      }\n\n      return cached;\n    };\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function select(selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          match = tokenize(selector);\n\n      if (!seed) {\n        // Try to minimize operations if there is only one group\n        if (match.length === 1) {\n          // Take a shortcut and set the context if the root selector is an ID\n          tokens = match[0] = match[0].slice(0);\n\n          if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && !documentIsXML && Expr.relative[tokens[1].type]) {\n            context = Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context)[0];\n\n            if (!context) {\n              return results;\n            }\n\n            selector = selector.slice(tokens.shift().value.length);\n          } // Fetch a seed set for right-to-left matching\n\n\n          i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n          while (i--) {\n            token = tokens[i]; // Abort if we hit a combinator\n\n            if (Expr.relative[type = token.type]) {\n              break;\n            }\n\n            if (find = Expr.find[type]) {\n              // Search, expanding context for leading sibling combinators\n              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {\n                // If seed is empty or no tokens remain, we can return early\n                tokens.splice(i, 1);\n                selector = seed.length && toSelector(tokens);\n\n                if (!selector) {\n                  push.apply(results, slice.call(seed, 0));\n                  return results;\n                }\n\n                break;\n              }\n            }\n          }\n        }\n      } // Compile and execute a filtering function\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      compile(selector, match)(seed, context, documentIsXML, results, rsibling.test(selector));\n      return results;\n    } // Deprecated\n\n\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Easy API for creating new setFilters\n\n    function setFilters() {}\n\n    Expr.filters = setFilters.prototype = Expr.pseudos;\n    Expr.setFilters = new setFilters(); // Initialize with the default document\n\n    setDocument(); // Override sizzle attribute retrieval\n\n    Sizzle.attr = jQuery.attr;\n    jQuery.find = Sizzle;\n    jQuery.expr = Sizzle.selectors;\n    jQuery.expr[\":\"] = jQuery.expr.pseudos;\n    jQuery.unique = Sizzle.uniqueSort;\n    jQuery.text = Sizzle.getText;\n    jQuery.isXMLDoc = Sizzle.isXML;\n    jQuery.contains = Sizzle.contains;\n  })(window);\n\n  var runtil = /Until$/,\n      rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      isSimple = /^.[^:#\\[\\.,]*$/,\n      rneedsContext = jQuery.expr.match.needsContext,\n      // methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          self,\n          len = this.length;\n\n      if (typeof selector !== \"string\") {\n        self = this;\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = [];\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, this[i], ret);\n      } // Needed because $( selector, context ) becomes $( context ).find( selector )\n\n\n      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\n      ret.selector = (this.selector ? this.selector + \" \" : \"\") + selector;\n      return ret;\n    },\n    has: function has(target) {\n      var i,\n          targets = jQuery(target, this),\n          len = targets.length;\n      return this.filter(function () {\n        for (i = 0; i < len; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector, false));\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector, true));\n    },\n    is: function is(selector) {\n      return !!selector && (typeof selector === \"string\" ? // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      rneedsContext.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0);\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          ret = [],\n          pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n      for (; i < l; i++) {\n        cur = this[i];\n\n        while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {\n          if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {\n            ret.push(cur);\n            break;\n          }\n\n          cur = cur.parentNode;\n        }\n      }\n\n      return this.pushStack(ret.length > 1 ? jQuery.unique(ret) : ret);\n    },\n    // Determine the position of an element within\n    // the matched set of elements\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // index in selector\n\n\n      if (typeof elem === \"string\") {\n        return jQuery.inArray(this[0], jQuery(elem));\n      } // Locate the position of the desired element\n\n\n      return jQuery.inArray( // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem, this);\n    },\n    add: function add(selector, context) {\n      var set = typeof selector === \"string\" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),\n          all = jQuery.merge(this.get(), set);\n      return this.pushStack(jQuery.unique(all));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n  jQuery.fn.andSelf = jQuery.fn.addBack;\n\n  function sibling(cur, dir) {\n    do {\n      cur = cur[dir];\n    } while (cur && cur.nodeType !== 1);\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return jQuery.dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return jQuery.dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return jQuery.dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return jQuery.dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return jQuery.dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return jQuery.dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return jQuery.sibling(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      return jQuery.nodeName(elem, \"iframe\") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var ret = jQuery.map(this, fn, until);\n\n      if (!runtil.test(name)) {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        ret = jQuery.filter(selector, ret);\n      }\n\n      ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;\n\n      if (this.length > 1 && rparentsprev.test(name)) {\n        ret = ret.reverse();\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  jQuery.extend({\n    filter: function filter(expr, elems, not) {\n      if (not) {\n        expr = \":not(\" + expr + \")\";\n      }\n\n      return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] : jQuery.find.matches(expr, elems);\n    },\n    dir: function dir(elem, _dir, until) {\n      var matched = [],\n          cur = elem[_dir];\n\n      while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {\n        if (cur.nodeType === 1) {\n          matched.push(cur);\n        }\n\n        cur = cur[_dir];\n      }\n\n      return matched;\n    },\n    sibling: function sibling(n, elem) {\n      var r = [];\n\n      for (; n; n = n.nextSibling) {\n        if (n.nodeType === 1 && n !== elem) {\n          r.push(n);\n        }\n      }\n\n      return r;\n    }\n  }); // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, keep) {\n    // Can't pass null or undefined to indexOf in Firefox 4\n    // Set to 0 to skip string check\n    qualifier = qualifier || 0;\n\n    if (jQuery.isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        var retVal = !!qualifier.call(elem, i, elem);\n        return retVal === keep;\n      });\n    } else if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier === keep;\n      });\n    } else if (typeof qualifier === \"string\") {\n      var filtered = jQuery.grep(elements, function (elem) {\n        return elem.nodeType === 1;\n      });\n\n      if (isSimple.test(qualifier)) {\n        return jQuery.filter(qualifier, filtered, !keep);\n      } else {\n        qualifier = jQuery.filter(qualifier, filtered);\n      }\n    }\n\n    return jQuery.grep(elements, function (elem) {\n      return jQuery.inArray(elem, qualifier) >= 0 === keep;\n    });\n  }\n\n  function createSafeFragment(document) {\n    var list = nodeNames.split(\"|\"),\n        safeFrag = document.createDocumentFragment();\n\n    if (safeFrag.createElement) {\n      while (list.length) {\n        safeFrag.createElement(list.pop());\n      }\n    }\n\n    return safeFrag;\n  }\n\n  var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" + \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n      rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n      rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n      rleadingWhitespace = /^\\s+/,\n      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      rtagName = /<([\\w:]+)/,\n      rtbody = /<tbody/i,\n      rhtml = /<|&#?\\w+;/,\n      rnoInnerhtml = /<(?:script|style|link)/i,\n      manipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rscriptType = /^$|\\/(?:java|ecma)script/i,\n      rscriptTypeMasked = /^true\\/(.*)/,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n      // We have to close these tags to support XHTML (#13200)\n  wrapMap = {\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    legend: [1, \"<fieldset>\", \"</fieldset>\"],\n    area: [1, \"<map>\", \"</map>\"],\n    param: [1, \"<object>\", \"</object>\"],\n    thead: [1, \"<table>\", \"</table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    col: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n    // unless wrapped in a div with non-breaking characters in front of it.\n    _default: jQuery.support.htmlSerialize ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"]\n  },\n      safeFragment = createSafeFragment(document),\n      fragmentDiv = safeFragment.appendChild(document.createElement(\"div\"));\n  wrapMap.optgroup = wrapMap.option;\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n  jQuery.fn.extend({\n    text: function text(value) {\n      return jQuery.access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));\n      }, null, value, arguments.length);\n    },\n    wrapAll: function wrapAll(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapAll(html.call(this, i));\n        });\n      }\n\n      if (this[0]) {\n        // The elements to wrap the target around\n        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstChild && elem.firstChild.nodeType === 1) {\n            elem = elem.firstChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var isFunction = jQuery.isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap() {\n      return this.parent().each(function () {\n        if (!jQuery.nodeName(this, \"body\")) {\n          jQuery(this).replaceWith(this.childNodes);\n        }\n      }).end();\n    },\n    append: function append() {\n      return this.domManip(arguments, true, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          this.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return this.domManip(arguments, true, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          this.insertBefore(elem, this.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return this.domManip(arguments, false, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return this.domManip(arguments, false, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    // keepData is for internal use only--do not document\n    remove: function remove(selector, keepData) {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (!selector || jQuery.filter(selector, [elem]).length > 0) {\n          if (!keepData && elem.nodeType === 1) {\n            jQuery.cleanData(getAll(elem));\n          }\n\n          if (elem.parentNode) {\n            if (keepData && jQuery.contains(elem.ownerDocument, elem)) {\n              setGlobalEval(getAll(elem, \"script\"));\n            }\n\n            elem.parentNode.removeChild(elem);\n          }\n        }\n      }\n\n      return this;\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        // Remove element nodes and prevent memory leaks\n        if (elem.nodeType === 1) {\n          jQuery.cleanData(getAll(elem, false));\n        } // Remove any remaining nodes\n\n\n        while (elem.firstChild) {\n          elem.removeChild(elem.firstChild);\n        } // If this is a select, ensure that it displays empty (#12336)\n        // Support: IE<9\n\n\n        if (elem.options && jQuery.nodeName(elem, \"select\")) {\n          elem.options.length = 0;\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return jQuery.access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined) {\n          return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, \"\") : undefined;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n          try {\n            for (; i < l; i++) {\n              // Remove element nodes and prevent memory leaks\n              elem = this[i] || {};\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith(value) {\n      var isFunc = jQuery.isFunction(value); // Make sure that the elements are removed from the DOM before they are inserted\n      // this can help fix replacing a parent with child elements\n\n      if (!isFunc && typeof value !== \"string\") {\n        value = jQuery(value).not(this).detach();\n      }\n\n      return this.domManip([value], true, function (elem) {\n        var next = this.nextSibling,\n            parent = this.parentNode;\n\n        if (parent) {\n          jQuery(this).remove();\n          parent.insertBefore(elem, next);\n        }\n      });\n    },\n    detach: function detach(selector) {\n      return this.remove(selector, true);\n    },\n    domManip: function domManip(args, table, callback) {\n      // Flatten any nested arrays\n      args = core_concat.apply([], args);\n      var first,\n          node,\n          hasScripts,\n          scripts,\n          doc,\n          fragment,\n          i = 0,\n          l = this.length,\n          set = this,\n          iNoClone = l - 1,\n          value = args[0],\n          isFunction = jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n      if (isFunction || !(l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test(value))) {\n        return this.each(function (index) {\n          var self = set.eq(index);\n\n          if (isFunction) {\n            args[0] = value.call(this, index, table ? self.html() : undefined);\n          }\n\n          self.domManip(args, table, callback);\n        });\n      }\n\n      if (l) {\n        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);\n        first = fragment.firstChild;\n\n        if (fragment.childNodes.length === 1) {\n          fragment = first;\n        }\n\n        if (first) {\n          table = table && jQuery.nodeName(first, \"tr\");\n          scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n          hasScripts = scripts.length; // Use the original fragment for the last item instead of the first because it can end up\n          // being emptied incorrectly in certain situations (#8070).\n\n          for (; i < l; i++) {\n            node = fragment;\n\n            if (i !== iNoClone) {\n              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n              if (hasScripts) {\n                jQuery.merge(scripts, getAll(node, \"script\"));\n              }\n            }\n\n            callback.call(table && jQuery.nodeName(this[i], \"table\") ? findOrAppend(this[i], \"tbody\") : this[i], node, i);\n          }\n\n          if (hasScripts) {\n            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n            for (i = 0; i < hasScripts; i++) {\n              node = scripts[i];\n\n              if (rscriptType.test(node.type || \"\") && !jQuery._data(node, \"globalEval\") && jQuery.contains(doc, node)) {\n                if (node.src) {\n                  // Hope ajax is available...\n                  jQuery.ajax({\n                    url: node.src,\n                    type: \"GET\",\n                    dataType: \"script\",\n                    async: false,\n                    global: false,\n                    \"throws\": true\n                  });\n                } else {\n                  jQuery.globalEval((node.text || node.textContent || node.innerHTML || \"\").replace(rcleanScript, \"\"));\n                }\n              }\n            }\n          } // Fix #11809: Avoid leaking memory\n\n\n          fragment = first = null;\n        }\n      }\n\n      return this;\n    }\n  });\n\n  function findOrAppend(elem, tag) {\n    return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    var attr = elem.getAttributeNode(\"type\");\n    elem.type = (attr && attr.specified) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    var match = rscriptTypeMasked.exec(elem.type);\n\n    if (match) {\n      elem.type = match[1];\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var elem,\n        i = 0;\n\n    for (; (elem = elems[i]) != null; i++) {\n      jQuery._data(elem, \"globalEval\", !refElements || jQuery._data(refElements[i], \"globalEval\"));\n    }\n  }\n\n  function cloneCopyEvent(src, dest) {\n    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {\n      return;\n    }\n\n    var type,\n        i,\n        l,\n        oldData = jQuery._data(src),\n        curData = jQuery._data(dest, oldData),\n        events = oldData.events;\n\n    if (events) {\n      delete curData.handle;\n      curData.events = {};\n\n      for (type in events) {\n        for (i = 0, l = events[type].length; i < l; i++) {\n          jQuery.event.add(dest, type, events[type][i]);\n        }\n      }\n    } // make the cloned public data object a copy from the original\n\n\n    if (curData.data) {\n      curData.data = jQuery.extend({}, curData.data);\n    }\n  }\n\n  function fixCloneNodeIssues(src, dest) {\n    var nodeName, e, data; // We do not need to do anything for non-Elements\n\n    if (dest.nodeType !== 1) {\n      return;\n    }\n\n    nodeName = dest.nodeName.toLowerCase(); // IE6-8 copies events bound via attachEvent when using cloneNode.\n\n    if (!jQuery.support.noCloneEvent && dest[jQuery.expando]) {\n      data = jQuery._data(dest);\n\n      for (e in data.events) {\n        jQuery.removeEvent(dest, e, data.handle);\n      } // Event data gets referenced instead of copied if the expando gets copied too\n\n\n      dest.removeAttribute(jQuery.expando);\n    } // IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\n\n    if (nodeName === \"script\" && dest.text !== src.text) {\n      disableScript(dest).text = src.text;\n      restoreScript(dest); // IE6-10 improperly clones children of object elements using classid.\n      // IE10 throws NoModificationAllowedError if parent is null, #12132.\n    } else if (nodeName === \"object\") {\n      if (dest.parentNode) {\n        dest.outerHTML = src.outerHTML;\n      } // This path appears unavoidable for IE9. When cloning an object\n      // element in IE9, the outerHTML strategy above is not sufficient.\n      // If the src has innerHTML and the destination does not,\n      // copy the src.innerHTML into the dest.innerHTML. #10324\n\n\n      if (jQuery.support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {\n        dest.innerHTML = src.innerHTML;\n      }\n    } else if (nodeName === \"input\" && manipulation_rcheckableType.test(src.type)) {\n      // IE6-8 fails to persist the checked state of a cloned checkbox\n      // or radio button. Worse, IE6-7 fail to give the cloned element\n      // a checked appearance if the defaultChecked value isn't also set\n      dest.defaultChecked = dest.checked = src.checked; // IE6-7 get confused and end up setting the value of a cloned\n      // checkbox/radio button to an empty string instead of \"on\"\n\n      if (dest.value !== src.value) {\n        dest.value = src.value;\n      } // IE6-8 fails to return the selected option to the default selected\n      // state when cloning options\n\n    } else if (nodeName === \"option\") {\n      dest.defaultSelected = dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when\n      // cloning other types of input fields\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          i = 0,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\n        core_push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n\n  function getAll(context, tag) {\n    var elems,\n        elem,\n        i = 0,\n        found = _typeof(context.getElementsByTagName) !== core_strundefined ? context.getElementsByTagName(tag || \"*\") : _typeof(context.querySelectorAll) !== core_strundefined ? context.querySelectorAll(tag || \"*\") : undefined;\n\n    if (!found) {\n      for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {\n        if (!tag || jQuery.nodeName(elem, tag)) {\n          found.push(elem);\n        } else {\n          jQuery.merge(found, getAll(elem, tag));\n        }\n      }\n    }\n\n    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;\n  } // Used in buildFragment, fixes the defaultChecked property\n\n\n  function fixDefaultChecked(elem) {\n    if (manipulation_rcheckableType.test(elem.type)) {\n      elem.defaultChecked = elem.checked;\n    }\n  }\n\n  jQuery.extend({\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var destElements,\n          node,\n          clone,\n          i,\n          srcElements,\n          inPage = jQuery.contains(elem.ownerDocument, elem);\n\n      if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test(\"<\" + elem.nodeName + \">\")) {\n        clone = elem.cloneNode(true); // IE<=8 does not properly clone detached, unknown element nodes\n      } else {\n        fragmentDiv.innerHTML = elem.outerHTML;\n        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);\n      }\n\n      if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem); // Fix all IE cloning issues\n\n        for (i = 0; (node = srcElements[i]) != null; ++i) {\n          // Ensure that the destination node is not null; Fixes #9587\n          if (destElements[i]) {\n            fixCloneNodeIssues(node, destElements[i]);\n          }\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0; (node = srcElements[i]) != null; i++) {\n            cloneCopyEvent(node, destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      }\n\n      destElements = srcElements = node = null; // Return the cloned set\n\n      return clone;\n    },\n    buildFragment: function buildFragment(elems, context, scripts, selection) {\n      var j,\n          elem,\n          contains,\n          tmp,\n          tag,\n          tbody,\n          wrap,\n          l = elems.length,\n          // Ensure a safe fragment\n      safe = createSafeFragment(context),\n          nodes = [],\n          i = 0;\n\n      for (; i < l; i++) {\n        elem = elems[i];\n\n        if (elem || elem === 0) {\n          // Add nodes directly\n          if (jQuery.type(elem) === \"object\") {\n            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n          } else if (!rhtml.test(elem)) {\n            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n          } else {\n            tmp = tmp || safe.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n            tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n            wrap = wrapMap[tag] || wrapMap._default;\n            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, \"<$1></$2>\") + wrap[2]; // Descend through wrappers to the right content\n\n            j = wrap[0];\n\n            while (j--) {\n              tmp = tmp.lastChild;\n            } // Manually add leading whitespace removed by IE\n\n\n            if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {\n              nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));\n            } // Remove IE's autoinserted <tbody> from table fragments\n\n\n            if (!jQuery.support.tbody) {\n              // String was a <table>, *may* have spurious <tbody>\n              elem = tag === \"table\" && !rtbody.test(elem) ? tmp.firstChild : // String was a bare <thead> or <tfoot>\n              wrap[1] === \"<table>\" && !rtbody.test(elem) ? tmp : 0;\n              j = elem && elem.childNodes.length;\n\n              while (j--) {\n                if (jQuery.nodeName(tbody = elem.childNodes[j], \"tbody\") && !tbody.childNodes.length) {\n                  elem.removeChild(tbody);\n                }\n              }\n            }\n\n            jQuery.merge(nodes, tmp.childNodes); // Fix #12392 for WebKit and IE > 9\n\n            tmp.textContent = \"\"; // Fix #12392 for oldIE\n\n            while (tmp.firstChild) {\n              tmp.removeChild(tmp.firstChild);\n            } // Remember the top-level container for proper cleanup\n\n\n            tmp = safe.lastChild;\n          }\n        }\n      } // Fix #11356: Clear elements from fragment\n\n\n      if (tmp) {\n        safe.removeChild(tmp);\n      } // Reset defaultChecked for any radios and checkboxes\n      // about to be appended to the DOM in IE 6/7 (#8060)\n\n\n      if (!jQuery.support.appendChecked) {\n        jQuery.grep(getAll(nodes, \"input\"), fixDefaultChecked);\n      }\n\n      i = 0;\n\n      while (elem = nodes[i++]) {\n        // #4087 - If origin and destination elements are the same, and this is\n        // that element, do not do anything\n        if (selection && jQuery.inArray(elem, selection) !== -1) {\n          continue;\n        }\n\n        contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment\n\n        tmp = getAll(safe.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n        if (contains) {\n          setGlobalEval(tmp);\n        } // Capture executables\n\n\n        if (scripts) {\n          j = 0;\n\n          while (elem = tmp[j++]) {\n            if (rscriptType.test(elem.type || \"\")) {\n              scripts.push(elem);\n            }\n          }\n        }\n      }\n\n      tmp = null;\n      return safe;\n    },\n    cleanData: function cleanData(elems,\n    /* internal */\n    acceptData) {\n      var elem,\n          type,\n          id,\n          data,\n          i = 0,\n          internalKey = jQuery.expando,\n          cache = jQuery.cache,\n          deleteExpando = jQuery.support.deleteExpando,\n          special = jQuery.event.special;\n\n      for (; (elem = elems[i]) != null; i++) {\n        if (acceptData || jQuery.acceptData(elem)) {\n          id = elem[internalKey];\n          data = id && cache[id];\n\n          if (data) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Remove cache only if it was not already removed by jQuery.event.remove\n\n\n            if (cache[id]) {\n              delete cache[id]; // IE does not allow us to delete expando properties from nodes,\n              // nor does it have a removeAttribute function on Document nodes;\n              // we must handle all of these cases\n\n              if (deleteExpando) {\n                delete elem[internalKey];\n              } else if (_typeof(elem.removeAttribute) !== core_strundefined) {\n                elem.removeAttribute(internalKey);\n              } else {\n                elem[internalKey] = null;\n              }\n\n              core_deletedIds.push(id);\n            }\n          }\n        }\n      }\n    }\n  });\n  var iframe,\n      getStyles,\n      curCSS,\n      ralpha = /alpha\\([^)]*\\)/i,\n      ropacity = /opacity\\s*=\\s*([^)]*)/,\n      rposition = /^(top|right|bottom|left)$/,\n      // swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n  // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rmargin = /^margin/,\n      rnumsplit = new RegExp(\"^(\" + core_pnum + \")(.*)$\", \"i\"),\n      rnumnonpx = new RegExp(\"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\"),\n      rrelNum = new RegExp(\"^([+-])=(\" + core_pnum + \")\", \"i\"),\n      elemdisplay = {\n    BODY: \"block\"\n  },\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: 0,\n    fontWeight: 400\n  },\n      cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"]; // return a css property mapped to a potentially vendor prefixed property\n\n  function vendorPropName(style, name) {\n    // shortcut for names that are not vendor prefixed\n    if (name in style) {\n      return name;\n    } // check for vendor prefixed names\n\n\n    var capName = name.charAt(0).toUpperCase() + name.slice(1),\n        origName = name,\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in style) {\n        return name;\n      }\n    }\n\n    return origName;\n  }\n\n  function isHidden(elem, el) {\n    // isHidden might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n    return jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        hidden,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      values[index] = jQuery._data(elem, \"olddisplay\");\n      display = elem.style.display;\n\n      if (show) {\n        // Reset the inline display of this element to learn if it is\n        // being hidden by cascaded rules or not\n        if (!values[index] && display === \"none\") {\n          elem.style.display = \"\";\n        } // Set elements which have been overridden with display: none\n        // in a stylesheet to whatever the default browser style is\n        // for such an element\n\n\n        if (elem.style.display === \"\" && isHidden(elem)) {\n          values[index] = jQuery._data(elem, \"olddisplay\", css_defaultDisplay(elem.nodeName));\n        }\n      } else {\n        if (!values[index]) {\n          hidden = isHidden(elem);\n\n          if (display && display !== \"none\" || !hidden) {\n            jQuery._data(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\n          }\n        }\n      }\n    } // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      if (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\n        elem.style.display = show ? values[index] || \"\" : \"none\";\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return jQuery.access(this, function (elem, name, value) {\n        var len,\n            styles,\n            map = {},\n            i = 0;\n\n        if (jQuery.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    },\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      var bool = typeof state === \"boolean\";\n      return this.each(function () {\n        if (bool ? state : isHidden(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Exclude the following css properties to add px\n    cssNumber: {\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"fontWeight\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n      // normalize float css property\n      \"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    },\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = jQuery.camelCase(name),\n          style = elem.style;\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)); // gets hook for the prefixed version\n      // followed by the unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // convert relative number strings (+= or -=) to relative numbers. #7345\n\n        if (type === \"string\" && (ret = rrelNum.exec(value))) {\n          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that NaN and null values aren't set. See: #7116\n\n\n        if (value == null || type === \"number\" && isNaN(value)) {\n          return;\n        } // If a number was passed in, add 'px' to the (except for certain CSS properties)\n\n\n        if (type === \"number\" && !jQuery.cssNumber[origName]) {\n          value += \"px\";\n        } // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n        // but it would mean to define eight (for every problematic property) identical functions\n\n\n        if (!jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          // Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n          // Fixes bug #5509\n          try {\n            style[name] = value;\n          } catch (e) {}\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var num,\n          val,\n          hooks,\n          origName = jQuery.camelCase(name); // Make sure that we're working with the right name\n\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)); // gets hook for the prefixed version\n      // followed by the unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } //convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Return, converting to number if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;\n      }\n\n      return val;\n    },\n    // A method for quickly swapping in/out CSS properties to get correct calculations\n    swap: function swap(elem, options, callback, args) {\n      var ret,\n          name,\n          old = {}; // Remember the old values, and insert the new ones\n\n      for (name in options) {\n        old[name] = elem.style[name];\n        elem.style[name] = options[name];\n      }\n\n      ret = callback.apply(elem, args || []); // Revert the old values\n\n      for (name in options) {\n        elem.style[name] = old[name];\n      }\n\n      return ret;\n    }\n  }); // NOTE: we've included the \"window\" in window.getComputedStyle\n  // because jsdom on node.js will break without it.\n\n  if (window.getComputedStyle) {\n    getStyles = function getStyles(elem) {\n      return window.getComputedStyle(elem, null);\n    };\n\n    curCSS = function curCSS(elem, name, _computed) {\n      var width,\n          minWidth,\n          maxWidth,\n          computed = _computed || getStyles(elem),\n          // getPropertyValue is only needed for .css('filter') in IE9, see #12537\n      ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined,\n          style = elem.style;\n\n      if (computed) {\n        if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n          ret = jQuery.style(elem, name);\n        } // A tribute to the \"awesome hack by Dean Edwards\"\n        // Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\n\n        if (rnumnonpx.test(ret) && rmargin.test(name)) {\n          // Remember the original values\n          width = style.width;\n          minWidth = style.minWidth;\n          maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n          style.minWidth = style.maxWidth = style.width = ret;\n          ret = computed.width; // Revert the changed values\n\n          style.width = width;\n          style.minWidth = minWidth;\n          style.maxWidth = maxWidth;\n        }\n      }\n\n      return ret;\n    };\n  } else if (document.documentElement.currentStyle) {\n    getStyles = function getStyles(elem) {\n      return elem.currentStyle;\n    };\n\n    curCSS = function curCSS(elem, name, _computed) {\n      var left,\n          rs,\n          rsLeft,\n          computed = _computed || getStyles(elem),\n          ret = computed ? computed[name] : undefined,\n          style = elem.style; // Avoid setting ret to empty string here\n      // so we don't default to auto\n\n\n      if (ret == null && style && style[name]) {\n        ret = style[name];\n      } // From the awesome hack by Dean Edwards\n      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n      // If we're not dealing with a regular pixel number\n      // but a number that has a weird ending, we need to convert it to pixels\n      // but not position css attributes, as those are proportional to the parent element instead\n      // and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\n\n      if (rnumnonpx.test(ret) && !rposition.test(name)) {\n        // Remember the original values\n        left = style.left;\n        rs = elem.runtimeStyle;\n        rsLeft = rs && rs.left; // Put in the new values to get a computed value out\n\n        if (rsLeft) {\n          rs.left = elem.currentStyle.left;\n        }\n\n        style.left = name === \"fontSize\" ? \"1em\" : ret;\n        ret = style.pixelLeft + \"px\"; // Revert the changed values\n\n        style.left = left;\n\n        if (rsLeft) {\n          rs.left = rsLeft;\n        }\n      }\n\n      return ret === \"\" ? \"auto\" : ret;\n    };\n  }\n\n  function setPositiveNumber(elem, value, subtract) {\n    var matches = rnumsplit.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\n  }\n\n  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n    var i = extra === (isBorderBox ? \"border\" : \"content\") ? // If we already have the right measurement, avoid augmentation\n    4 : // Otherwise initialize for horizontal or vertical properties\n    name === \"width\" ? 1 : 0,\n        val = 0;\n\n    for (; i < 4; i += 2) {\n      // both box models exclude margin, so add it if we want it\n      if (extra === \"margin\") {\n        val += jQuery.css(elem, extra + cssExpand[i], true, styles);\n      }\n\n      if (isBorderBox) {\n        // border-box includes padding, so remove it if we want content\n        if (extra === \"content\") {\n          val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // at this point, extra isn't border nor margin, so remove border\n\n\n        if (extra !== \"margin\") {\n          val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      } else {\n        // at this point, extra isn't content, so add padding\n        val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // at this point, extra isn't content nor padding, so add border\n\n        if (extra !== \"padding\") {\n          val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    }\n\n    return val;\n  }\n\n  function getWidthOrHeight(elem, name, extra) {\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n        val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n        styles = getStyles(elem),\n        isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\n    if (val <= 0 || val == null) {\n      // Fall back to computed then uncomputed css if necessary\n      val = curCSS(elem, name, styles);\n\n      if (val < 0 || val == null) {\n        val = elem.style[name];\n      } // Computed unit is not pixels. Stop here and return.\n\n\n      if (rnumnonpx.test(val)) {\n        return val;\n      } // we need the check for style in case a browser which returns unreliable values\n      // for getComputedStyle silently falls back to the reliable elem.style\n\n\n      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]); // Normalize \"\", auto, and prepare for extra\n\n      val = parseFloat(val) || 0;\n    } // use the active box-sizing model to add/subtract irrelevant styles\n\n\n    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\n  } // Try to determine the default display value of an element\n\n\n  function css_defaultDisplay(nodeName) {\n    var doc = document,\n        display = elemdisplay[nodeName];\n\n    if (!display) {\n      display = actualDisplay(nodeName, doc); // If the simple way fails, read from inside an iframe\n\n      if (display === \"none\" || !display) {\n        // Use the already-created iframe if possible\n        iframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\").css(\"cssText\", \"display:block !important\")).appendTo(doc.documentElement); // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\n        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;\n        doc.write(\"<!doctype html><html><body>\");\n        doc.close();\n        display = actualDisplay(nodeName, doc);\n        iframe.detach();\n      } // Store the correct default display\n\n\n      elemdisplay[nodeName] = display;\n    }\n\n    return display;\n  } // Called ONLY from within css_defaultDisplay\n\n\n  function actualDisplay(name, doc) {\n    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n        display = jQuery.css(elem[0], \"display\");\n    elem.remove();\n    return display;\n  }\n\n  jQuery.each([\"height\", \"width\"], function (i, name) {\n    jQuery.cssHooks[name] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // certain elements can have dimension info if we invisibly show them\n          // however, it must have a current display style that would benefit from this\n          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, \"display\")) ? jQuery.swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, name, extra);\n          }) : getWidthOrHeight(elem, name, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var styles = extra && getStyles(elem);\n        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\n      }\n    };\n  });\n\n  if (!jQuery.support.opacity) {\n    jQuery.cssHooks.opacity = {\n      get: function get(elem, computed) {\n        // IE uses filters for opacity\n        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\") ? 0.01 * parseFloat(RegExp.$1) + \"\" : computed ? \"1\" : \"\";\n      },\n      set: function set(elem, value) {\n        var style = elem.style,\n            currentStyle = elem.currentStyle,\n            opacity = jQuery.isNumeric(value) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n            filter = currentStyle && currentStyle.filter || style.filter || \"\"; // IE has trouble with opacity if it does not have layout\n        // Force it by setting the zoom level\n\n        style.zoom = 1; // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n        // if value === \"\", then remove inline opacity #12685\n\n        if ((value >= 1 || value === \"\") && jQuery.trim(filter.replace(ralpha, \"\")) === \"\" && style.removeAttribute) {\n          // Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n          // if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n          // style.removeAttribute is IE Only, but so apparently is this code path...\n          style.removeAttribute(\"filter\"); // if there is no filter style applied in a css rule or unset inline opacity, we are done\n\n          if (value === \"\" || currentStyle && !currentStyle.filter) {\n            return;\n          }\n        } // otherwise, set new filter values\n\n\n        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + \" \" + opacity;\n      }\n    };\n  } // These hooks cannot be added until DOM ready because the support test\n  // for it is not run until after DOM ready\n\n\n  jQuery(function () {\n    if (!jQuery.support.reliableMarginRight) {\n      jQuery.cssHooks.marginRight = {\n        get: function get(elem, computed) {\n          if (computed) {\n            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n            // Work around by temporarily setting element display to inline-block\n            return jQuery.swap(elem, {\n              \"display\": \"inline-block\"\n            }, curCSS, [elem, \"marginRight\"]);\n          }\n        }\n      };\n    } // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n    // getComputedStyle returns percent when specified for top/left/bottom/right\n    // rather than make the css module depend on the offset module, we just check for it here\n\n\n    if (!jQuery.support.pixelPosition && jQuery.fn.position) {\n      jQuery.each([\"top\", \"left\"], function (i, prop) {\n        jQuery.cssHooks[prop] = {\n          get: function get(elem, computed) {\n            if (computed) {\n              computed = curCSS(elem, prop); // if curCSS returns percentage, fallback to offset\n\n              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n            }\n          }\n        };\n      });\n    }\n  });\n\n  if (jQuery.expr && jQuery.expr.filters) {\n    jQuery.expr.filters.hidden = function (elem) {\n      // Support: Opera <= 12.12\n      // Opera reports offsetWidths and offsetHeights less than zero on some elements\n      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !jQuery.support.reliableHiddenOffsets && (elem.style && elem.style.display || jQuery.css(elem, \"display\")) === \"none\";\n    };\n\n    jQuery.expr.filters.visible = function (elem) {\n      return !jQuery.expr.filters.hidden(elem);\n    };\n  } // These hooks are used by animate to expand properties\n\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (!rmargin.test(prefix)) {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  var r20 = /%20/g,\n      rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is(\":disabled\") so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\n          return {\n            name: elem.name,\n            value: val.replace(rCRLF, \"\\r\\n\")\n          };\n        }) : {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  }); //Serialize an array of form elements or a set of\n  //key/values into a query string\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, value) {\n      // If value is a function, invoke it and return its value\n      value = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n    }; // Set traditional to true for jQuery <= 1.3.2 behavior.\n\n\n    if (traditional === undefined) {\n      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\").replace(r20, \"+\");\n  };\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (jQuery.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && jQuery.type(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  }\n\n  jQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n\n  jQuery.fn.hover = function (fnOver, fnOut) {\n    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n  };\n\n  var // Document location\n  ajaxLocParts,\n      ajaxLocation,\n      ajax_nonce = jQuery.now(),\n      ajax_rquery = /\\?/,\n      rhash = /#.*$/,\n      rts = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n      // IE leaves an \\r character at EOL\n  // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n      rurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n      // Keep a copy of the old load method\n  _load = jQuery.fn.load,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"); // #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n\n  try {\n    ajaxLocation = location.href;\n  } catch (e) {\n    // Use the href attribute of an A element\n    // since IE will modify it given document.location\n    ajaxLocation = document.createElement(\"a\");\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  } // Segment location into parts\n\n\n  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];\n\n      if (jQuery.isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var deep,\n        key,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n\n  jQuery.fn.load = function (url, params, callback) {\n    if (typeof url !== \"string\" && _load) {\n      return _load.apply(this, arguments);\n    }\n\n    var selector,\n        response,\n        type,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off >= 0) {\n      selector = url.slice(off, url.length);\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (jQuery.isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // if \"type\" variable is undefined, then \"GET\" method will be used\n        type: type,\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText);\n      }).complete(callback && function (jqXHR, status) {\n        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);\n      });\n    }\n\n    return this;\n  }; // Attach a bunch of functions for handling common AJAX events\n\n\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n  jQuery.each([\"get\", \"post\"], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // shift arguments if data argument was omitted\n      if (jQuery.isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      }\n\n      return jQuery.ajax({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      });\n    };\n  });\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: ajaxLocation,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(ajaxLocParts[1]),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /xml/,\n        html: /html/,\n        json: /json/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": window.String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": jQuery.parseJSON,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var // Cross-domain detection vars\n      parts,\n          // Loop variable\n      i,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers as string\n      responseHeadersString,\n          // timeout handle\n      timeoutTimer,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          transport,\n          // Response headers\n      responseHeaders,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // The jqXHR state\n      state = 0,\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (state === 2) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase()] = match[2];\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase()];\n          }\n\n          return match == null ? null : match;\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return state === 2 ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          var lname = name.toLowerCase();\n\n          if (!state) {\n            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (!state) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (state < 2) {\n              for (code in map) {\n                // Lazy-add the new callback in a way that preserves old ones\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            } else {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR).complete = completeDeferred.add;\n      jqXHR.success = jqXHR.done;\n      jqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion)\n      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(core_rnotwhite) || [\"\"]; // A cross-domain request is in order when we have a protocol:host:port mismatch\n\n      if (s.crossDomain == null) {\n        parts = rurl.exec(s.url.toLowerCase());\n        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))));\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (state === 2) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n\n\n      fireGlobals = s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n\n      cacheURL = s.url; // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // If data is available, append data to url\n        if (s.data) {\n          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add anti-cache in url if needed\n\n\n        if (s.cache === false) {\n          s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value\n          cacheURL.replace(rts, \"$1_=\" + ajax_nonce++) : // Otherwise add one to the end\n          cacheURL + (ajax_rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + ajax_nonce++;\n        }\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      for (i in {\n        success: 1,\n        error: 1,\n        complete: 1\n      }) {\n        jqXHR[i](s[i]);\n      } // Get transport\n\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          state = 1;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Propagate exception as error if not done\n          if (state < 2) {\n            done(-1, e); // Simply rethrow otherwise\n          } else {\n            throw e;\n          }\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Called once\n\n        if (state === 2) {\n          return;\n        } // State is \"done\" now\n\n\n        state = 2; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // If successful, handle type chaining\n\n\n        if (status >= 200 && status < 300 || status === 304) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204) {\n            isSuccess = true;\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            isSuccess = true;\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            isSuccess = ajaxConvert(s, response);\n            statusText = isSuccess.state;\n            success = isSuccess.data;\n            error = isSuccess.error;\n            isSuccess = !error;\n          }\n        } else {\n          // We extract error from statusText\n          // then normalize statusText and status for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    }\n  });\n  /* Handles responses to an ajax request:\n   * - sets all responseXXX fields accordingly\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var firstDataType,\n        ct,\n        finalDataType,\n        type,\n        contents = s.contents,\n        dataTypes = s.dataTypes,\n        responseFields = s.responseFields; // Fill responseXXX fields\n\n    for (type in responseFields) {\n      if (type in responses) {\n        jqXHR[responseFields[type]] = responses[type];\n      }\n    } // Remove auto dataType and get content-type in the process\n\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  } // Chain conversions given the request and the original response\n\n\n  function ajaxConvert(s, response) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        converters = {},\n        i = 0,\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(),\n        prev = dataTypes[0]; // Apply the dataFilter if provided\n\n    if (s.dataFilter) {\n      response = s.dataFilter(response, s.dataType);\n    } // Create converters map with lowercased keys\n\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    } // Convert to each sequential dataType, tolerating list modification\n\n\n    for (; current = dataTypes[++i];) {\n      // There's only work to do if current dataType is non-auto\n      if (current !== \"*\") {\n        // Convert response if prev dataType is non-auto and differs from current\n        if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.splice(i--, 0, current);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        } // Update prev for next iteration\n\n\n        prev = current;\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  } // Install script dataType\n\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /(?:java|ecma)script/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and global\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n      s.global = false;\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain requests\n    if (s.crossDomain) {\n      var script,\n          head = document.head || jQuery(\"head\")[0] || document.documentElement;\n      return {\n        send: function send(_, callback) {\n          script = document.createElement(\"script\");\n          script.async = true;\n\n          if (s.scriptCharset) {\n            script.charset = s.scriptCharset;\n          }\n\n          script.src = s.url; // Attach handlers for all browsers\n\n          script.onload = script.onreadystatechange = function (_, isAbort) {\n            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n              // Handle memory leak in IE\n              script.onload = script.onreadystatechange = null; // Remove the script\n\n              if (script.parentNode) {\n                script.parentNode.removeChild(script);\n              } // Dereference the script\n\n\n              script = null; // Callback if not abort\n\n              if (!isAbort) {\n                callback(200, \"success\");\n              }\n            }\n          }; // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n\n          head.insertBefore(script, head.firstChild);\n        },\n        abort: function abort() {\n          if (script) {\n            script.onload(undefined, true);\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + ajax_nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && !(s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (ajax_rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // Restore preexisting value\n        window[callbackName] = overwritten; // Save back as free\n\n        if (s[callbackName]) {\n          // make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && jQuery.isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  });\n\n  var xhrCallbacks,\n      xhrSupported,\n      xhrId = 0,\n      // #5280: Internet Explorer will keep connections alive if we don't abort on unload\n  xhrOnUnloadAbort = window.ActiveXObject && function () {\n    // Abort all pending requests\n    var key;\n\n    for (key in xhrCallbacks) {\n      xhrCallbacks[key](undefined, true);\n    }\n  }; // Functions to create xhrs\n\n\n  function createStandardXHR() {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  }\n\n  function createActiveXHR() {\n    try {\n      return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n    } catch (e) {}\n  } // Create the request object\n  // (This is still attached to ajaxSettings for backward compatibility)\n\n\n  jQuery.ajaxSettings.xhr = window.ActiveXObject ?\n  /* Microsoft failed to properly\n   * implement the XMLHttpRequest in IE7 (can't request local files),\n   * so we use the ActiveXObject when it is available\n   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n   * we need a fallback.\n   */\n  function () {\n    return !this.isLocal && createStandardXHR() || createActiveXHR();\n  } : // For all other browsers, use the standard XMLHttpRequest object\n  createStandardXHR; // Determine support properties\n\n  xhrSupported = jQuery.ajaxSettings.xhr();\n  jQuery.support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  xhrSupported = jQuery.support.ajax = !!xhrSupported; // Create transport if the browser can provide an xhr\n\n  if (xhrSupported) {\n    jQuery.ajaxTransport(function (s) {\n      // Cross domain only allowed if supported through XMLHttpRequest\n      if (!s.crossDomain || jQuery.support.cors) {\n        var _callback;\n\n        return {\n          send: function send(headers, complete) {\n            // Get a new xhr\n            var handle,\n                i,\n                xhr = s.xhr(); // Open the socket\n            // Passing null username, generates a login popup on Opera (#2865)\n\n            if (s.username) {\n              xhr.open(s.type, s.url, s.async, s.username, s.password);\n            } else {\n              xhr.open(s.type, s.url, s.async);\n            } // Apply custom fields if provided\n\n\n            if (s.xhrFields) {\n              for (i in s.xhrFields) {\n                xhr[i] = s.xhrFields[i];\n              }\n            } // Override mime type if needed\n\n\n            if (s.mimeType && xhr.overrideMimeType) {\n              xhr.overrideMimeType(s.mimeType);\n            } // X-Requested-With header\n            // For cross-domain requests, seeing as conditions for a preflight are\n            // akin to a jigsaw puzzle, we simply never set it to be sure.\n            // (it can always be set on a per-request basis or even using ajaxSetup)\n            // For same-domain requests, won't change header if already provided.\n\n\n            if (!s.crossDomain && !headers[\"X-Requested-With\"]) {\n              headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n            } // Need an extra try/catch for cross domain requests in Firefox 3\n\n\n            try {\n              for (i in headers) {\n                xhr.setRequestHeader(i, headers[i]);\n              }\n            } catch (err) {} // Do send the request\n            // This may raise an exception which is actually\n            // handled in jQuery.ajax (so no try/catch here)\n\n\n            xhr.send(s.hasContent && s.data || null); // Listener\n\n            _callback = function callback(_, isAbort) {\n              var status, responseHeaders, statusText, responses; // Firefox throws exceptions when accessing properties\n              // of an xhr when a network error occurred\n              // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\n              try {\n                // Was never called and is aborted or complete\n                if (_callback && (isAbort || xhr.readyState === 4)) {\n                  // Only called once\n                  _callback = undefined; // Do not keep as active anymore\n\n                  if (handle) {\n                    xhr.onreadystatechange = jQuery.noop;\n\n                    if (xhrOnUnloadAbort) {\n                      delete xhrCallbacks[handle];\n                    }\n                  } // If it's an abort\n\n\n                  if (isAbort) {\n                    // Abort it manually if needed\n                    if (xhr.readyState !== 4) {\n                      xhr.abort();\n                    }\n                  } else {\n                    responses = {};\n                    status = xhr.status;\n                    responseHeaders = xhr.getAllResponseHeaders(); // When requesting binary data, IE6-9 will throw an exception\n                    // on any attempt to access responseText (#11426)\n\n                    if (typeof xhr.responseText === \"string\") {\n                      responses.text = xhr.responseText;\n                    } // Firefox throws an exception when accessing\n                    // statusText for faulty cross-domain requests\n\n\n                    try {\n                      statusText = xhr.statusText;\n                    } catch (e) {\n                      // We normalize with Webkit giving an empty statusText\n                      statusText = \"\";\n                    } // Filter status for non standard behaviors\n                    // If the request is local and we have data: assume a success\n                    // (success with no data won't get notified, that's the best we\n                    // can do given current implementations)\n\n\n                    if (!status && s.isLocal && !s.crossDomain) {\n                      status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204\n                    } else if (status === 1223) {\n                      status = 204;\n                    }\n                  }\n                }\n              } catch (firefoxAccessException) {\n                if (!isAbort) {\n                  complete(-1, firefoxAccessException);\n                }\n              } // Call complete if needed\n\n\n              if (responses) {\n                complete(status, statusText, responses, responseHeaders);\n              }\n            };\n\n            if (!s.async) {\n              // if we're in sync mode we fire the callback\n              _callback();\n            } else if (xhr.readyState === 4) {\n              // (IE6 & IE7) if it's in cache and has been\n              // retrieved directly we need to fire the callback\n              setTimeout(_callback);\n            } else {\n              handle = ++xhrId;\n\n              if (xhrOnUnloadAbort) {\n                // Create the active xhrs callbacks list if needed\n                // and attach the unload handler\n                if (!xhrCallbacks) {\n                  xhrCallbacks = {};\n                  jQuery(window).unload(xhrOnUnloadAbort);\n                } // Add to list of active xhrs callbacks\n\n\n                xhrCallbacks[handle] = _callback;\n              }\n\n              xhr.onreadystatechange = _callback;\n            }\n          },\n          abort: function abort() {\n            if (_callback) {\n              _callback(undefined, true);\n            }\n          }\n        };\n      }\n    });\n  }\n\n  var fxNow,\n      timerId,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rfxnum = new RegExp(\"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\"),\n      rrun = /queueHooks$/,\n      animationPrefilters = [defaultPrefilter],\n      tweeners = {\n    \"*\": [function (prop, value) {\n      var end,\n          unit,\n          tween = this.createTween(prop, value),\n          parts = rfxnum.exec(value),\n          target = tween.cur(),\n          start = +target || 0,\n          scale = 1,\n          maxIterations = 20;\n\n      if (parts) {\n        end = +parts[2];\n        unit = parts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"); // We need to compute starting value\n\n        if (unit !== \"px\" && start) {\n          // Iteratively approximate from a nonzero starting point\n          // Prefer the current property, because this process will be trivial if it uses the same units\n          // Fallback to end or a simple constant\n          start = jQuery.css(tween.elem, prop, true) || end || 1;\n\n          do {\n            // If previous iteration zeroed out, double until we get *something*\n            // Use a string for doubling factor so we don't accidentally see scale as unchanged below\n            scale = scale || \".5\"; // Adjust and apply\n\n            start = start / scale;\n            jQuery.style(tween.elem, prop, start + unit); // Update scale, tolerating zero or NaN from tween.cur()\n            // And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n          } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);\n        }\n\n        tween.unit = unit;\n        tween.start = start; // If a +=/-= token was provided, we're doing a relative animation\n\n        tween.end = parts[1] ? start + (parts[1] + 1) * end : end;\n      }\n\n      return tween;\n    }]\n  }; // Animations created synchronously will run synchronously\n\n  function createFxNow() {\n    setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = jQuery.now();\n  }\n\n  function createTweens(animation, props) {\n    jQuery.each(props, function (prop, value) {\n      var collection = (tweeners[prop] || []).concat(tweeners[\"*\"]),\n          index = 0,\n          length = collection.length;\n\n      for (; index < length; index++) {\n        if (collection[index].call(animation, prop, value)) {\n          // we're done with this property\n          return;\n        }\n      }\n    });\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = animationPrefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]);\n\n      if (percent < 1 && length) {\n        return remaining;\n      } else {\n        deferred.resolveWith(elem, [animation]);\n        return false;\n      }\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {}\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // if we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // resolve when we played the last frame\n        // otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = animationPrefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    createTweens(animation, props);\n\n    if (jQuery.isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    }\n\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    })); // attach callbacks from options\n\n    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n  }\n\n  function propFilter(props, specialEasing) {\n    var value, name, index, easing, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = jQuery.camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (jQuery.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // not quite $.extend, this wont overwrite keys already present.\n        // also - reusing 'index' from above because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweener: function tweener(props, callback) {\n      if (jQuery.isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.split(\" \");\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        tweeners[prop] = tweeners[prop] || [];\n        tweeners[prop].unshift(callback);\n      }\n    },\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        animationPrefilters.unshift(callback);\n      } else {\n        animationPrefilters.push(callback);\n      }\n    }\n  });\n\n  function defaultPrefilter(elem, props, opts) {\n    /*jshint validthis:true */\n    var prop,\n        index,\n        length,\n        value,\n        dataShow,\n        toggle,\n        tween,\n        hooks,\n        oldfire,\n        anim = this,\n        style = elem.style,\n        orig = {},\n        handled = [],\n        hidden = elem.nodeType && isHidden(elem); // handle queue: false promises\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // doing this makes sure that the complete handler will be called\n        // before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // height/width overflow pass\n\n\n    if (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\n      // Make sure that nothing sneaks out\n      // Record all 3 overflow attributes because IE does not\n      // change the overflow attribute when overflowX and\n      // overflowY are set to the same value\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Set display property to inline-block for height/width\n      // animations on inline elements that are having width/height animated\n\n      if (jQuery.css(elem, \"display\") === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\n        // inline-level elements accept inline-block;\n        // block-level elements need to be inline with layout\n        if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === \"inline\") {\n          style.display = \"inline-block\";\n        } else {\n          style.zoom = 1;\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n\n      if (!jQuery.support.shrinkWrapBlocks) {\n        anim.always(function () {\n          style.overflow = opts.overflow[0];\n          style.overflowX = opts.overflow[1];\n          style.overflowY = opts.overflow[2];\n        });\n      }\n    } // show/hide pass\n\n\n    for (index in props) {\n      value = props[index];\n\n      if (rfxtypes.exec(value)) {\n        delete props[index];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          continue;\n        }\n\n        handled.push(index);\n      }\n    }\n\n    length = handled.length;\n\n    if (length) {\n      dataShow = jQuery._data(elem, \"fxshow\") || jQuery._data(elem, \"fxshow\", {});\n\n      if (\"hidden\" in dataShow) {\n        hidden = dataShow.hidden;\n      } // store state if its toggle - enables .stop().toggle() to \"reverse\"\n\n\n      if (toggle) {\n        dataShow.hidden = !hidden;\n      }\n\n      if (hidden) {\n        jQuery(elem).show();\n      } else {\n        anim.done(function () {\n          jQuery(elem).hide();\n        });\n      }\n\n      anim.done(function () {\n        var prop;\n\n        jQuery._removeData(elem, \"fxshow\");\n\n        for (prop in orig) {\n          jQuery.style(elem, prop, orig[prop]);\n        }\n      });\n\n      for (index = 0; index < length; index++) {\n        prop = handled[index];\n        tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);\n        orig[prop] = dataShow[prop] || jQuery.style(elem, prop);\n\n        if (!(prop in dataShow)) {\n          dataShow[prop] = tween.start;\n\n          if (hidden) {\n            tween.end = tween.start;\n            tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n          }\n        }\n      }\n    }\n  }\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || \"swing\";\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result;\n\n        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {\n          return tween.elem[tween.prop];\n        } // passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails\n        // so, simple values such as \"10px\" are parsed to Float.\n        // complex values such as \"rotate(1rad)\" are returned as is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // use step hook for back compat - use cssHook if its there - use .style if its\n        // available and use plain properties where available\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Remove in 2.0 - this supports IE8's panic based approach\n  // to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  });\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // show any hidden elements after setting opacity to 0\n      return this.filter(isHidden).css(\"opacity\", 0).show() // animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall);\n\n        doAnimation.finish = function () {\n          anim.stop(true);\n        }; // Empty animations, or finishing resolves immediately\n\n\n        if (empty || jQuery._data(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue && type !== false) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = jQuery._data(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // start the next in the queue if the last step wasn't forced\n        // timers currently will call their complete callbacks, which will dequeue\n        // but only if they were gotoEnd\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = jQuery._data(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // enable finishing flag on private data\n\n\n        data.finish = true; // empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.cur && hooks.cur.finish) {\n          hooks.cur.finish.call(this);\n        } // look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  }); // Generate parameters to create a standard animation\n\n  function genFx(type, includeWidth) {\n    var which,\n        attrs = {\n      height: type\n    },\n        i = 0; // if we include width, step value is 1 to do all cssExpand values,\n    // if we don't include width, step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  } // Generate shortcuts for custom animations\n\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n    };\n    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -> \"fx\"\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (jQuery.isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    }\n  };\n  jQuery.timers = [];\n  jQuery.fx = Tween.prototype.init;\n\n  jQuery.fx.tick = function () {\n    var timer,\n        timers = jQuery.timers,\n        i = 0;\n    fxNow = jQuery.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Checks the timer has not already been removed\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    if (timer() && jQuery.timers.push(timer)) {\n      jQuery.fx.start();\n    }\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (!timerId) {\n      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);\n    }\n  };\n\n  jQuery.fx.stop = function () {\n    clearInterval(timerId);\n    timerId = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Back Compat <1.8 extension point\n\n  jQuery.fx.step = {};\n\n  if (jQuery.expr && jQuery.expr.filters) {\n    jQuery.expr.filters.animated = function (elem) {\n      return jQuery.grep(jQuery.timers, function (fn) {\n        return elem === fn.elem;\n      }).length;\n    };\n  }\n\n  jQuery.fn.offset = function (options) {\n    if (arguments.length) {\n      return options === undefined ? this : this.each(function (i) {\n        jQuery.offset.setOffset(this, options, i);\n      });\n    }\n\n    var docElem,\n        win,\n        box = {\n      top: 0,\n      left: 0\n    },\n        elem = this[0],\n        doc = elem && elem.ownerDocument;\n\n    if (!doc) {\n      return;\n    }\n\n    docElem = doc.documentElement; // Make sure it's not a disconnected DOM node\n\n    if (!jQuery.contains(docElem, elem)) {\n      return box;\n    } // If we don't have gBCR, just use 0,0 rather than error\n    // BlackBerry 5, iOS 3 (original iPhone)\n\n\n    if (_typeof(elem.getBoundingClientRect) !== core_strundefined) {\n      box = elem.getBoundingClientRect();\n    }\n\n    win = getWindow(doc);\n    return {\n      top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n      left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n    };\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var position = jQuery.css(elem, \"position\"); // set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      var curElem = jQuery(elem),\n          curOffset = curElem.offset(),\n          curCSSTop = jQuery.css(elem, \"top\"),\n          curCSSLeft = jQuery.css(elem, \"left\"),\n          calculatePosition = (position === \"absolute\" || position === \"fixed\") && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n          props = {},\n          curPosition = {},\n          curTop,\n          curLeft; // need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (jQuery.isFunction(options)) {\n        options = options.call(elem, i, curOffset);\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          parentOffset = {\n        top: 0,\n        left: 0\n      },\n          elem = this[0]; // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // we assume that getBoundingClientRect is available when computed position is fixed\n        offset = elem.getBoundingClientRect();\n      } else {\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(); // Get correct offsets\n\n        offset = this.offset();\n\n        if (!jQuery.nodeName(offsetParent[0], \"html\")) {\n          parentOffset = offsetParent.offset();\n        } // Add offsetParent borders\n\n\n        parentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\n        parentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\n      } // Subtract parent offsets and element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent || document.documentElement;\n\n        while (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || document.documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = /Y/.test(prop);\n\n    jQuery.fn[method] = function (val) {\n      return jQuery.access(this, function (elem, method, val) {\n        var win = getWindow(elem);\n\n        if (val === undefined) {\n          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length, null);\n    };\n  });\n\n  function getWindow(elem) {\n    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;\n  } // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return jQuery.access(this, function (elem, type, value) {\n          var doc;\n\n          if (jQuery.isWindow(elem)) {\n            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n            // isn't a whole lot we can do. See pull request at this URL for discussion:\n            // https://github.com/jquery/jquery/pull/764\n            return elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n            // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable, null);\n      };\n    });\n  }); // Limit scope pollution from any deprecated API\n  // (function() {\n  // })();\n  // Expose jQuery to the global object\n\n  window.jQuery = window.$ = jQuery; // Expose jQuery as an AMD module, but only for AMD loaders that\n  // understand the issues with loading multiple versions of jQuery\n  // in a page that all might call define(). The loader will indicate\n  // they have special allowances for multiple jQuery versions by\n  // specifying define.amd.jQuery = true. Register as a named module,\n  // since jQuery can be concatenated with other files that may use define,\n  // but not use a proper concatenation script that understands anonymous\n  // AMD modules. A named AMD is safest and most robust way to register.\n  // Lowercase jquery is used because AMD module names are derived from\n  // file names, and jQuery is normally delivered in a lowercase file name.\n  // Do this after creating the global so that if an AMD module wants to call\n  // noConflict to hide this version of jQuery, it will work.\n\n  if ( true && __webpack_require__.amdO.jQuery) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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N0MsQ0FBUDtBQThCSCxPQWxDRDtBQW1DSCxLQXJDRDtBQXNDSCxHQXZDRCxFQWh6UzJCLENBdzFTM0I7QUFDQTtBQUVBO0FBQ0E7O0FBQ0EzTCxFQUFBQSxNQUFNLENBQUNRLE1BQVAsR0FBZ0JSLE1BQU0sQ0FBQ1UsQ0FBUCxHQUFXRixNQUEzQixDQTcxUzJCLENBKzFTM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUssU0FBOENvb0Msd0JBQUEsQ0FBV3BvQyxNQUE5RCxFQUF1RTtBQUNuRW9vQyxJQUFBQSxpQ0FBa0IsRUFBWixtQ0FBZ0IsWUFBWTtBQUFFLGFBQU9wb0MsTUFBUDtBQUFnQixLQUE5QztBQUFBLGtHQUFOO0FBQ0g7QUFFQSxDQS8yU0wsRUErMlNRUixNQS8yU1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvanF1ZXJ5LTEuOS4xLmpzPzVkZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjkuMVxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA1LCAyMDEyIGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTMtMi00XG4gKi9cbihmdW5jdGlvbiggd2luZG93LCB1bmRlZmluZWQgKSB7XG5cbiAgICAvLyBDYW4ndCBkbyB0aGlzIGJlY2F1c2Ugc2V2ZXJhbCBhcHBzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4gICAgLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4gICAgLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4gICAgLy9cInVzZSBzdHJpY3RcIjtcbiAgICB2YXJcbiAgICAgICAgLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG4gICAgICAgIHJlYWR5TGlzdCxcblxuICAgICAgICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgICAgICAgcm9vdGpRdWVyeSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgIC8vIEZvciBgdHlwZW9mIG5vZGUubWV0aG9kYCBpbnN0ZWFkIG9mIGBub2RlLm1ldGhvZCAhPT0gdW5kZWZpbmVkYFxuICAgICAgICBjb3JlX3N0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQsXG5cbiAgICAgICAgLy8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuICAgICAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG5cbiAgICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG4gICAgICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF8kID0gd2luZG93LiQsXG5cbiAgICAgICAgLy8gW1tDbGFzc11dIC0+IHR5cGUgcGFpcnNcbiAgICAgICAgY2xhc3MydHlwZSA9IHt9LFxuXG4gICAgICAgIC8vIExpc3Qgb2YgZGVsZXRlZCBkYXRhIGNhY2hlIGlkcywgc28gd2UgY2FuIHJldXNlIHRoZW1cbiAgICAgICAgY29yZV9kZWxldGVkSWRzID0gW10sXG5cbiAgICAgICAgY29yZV92ZXJzaW9uID0gXCIxLjkuMVwiLFxuXG4gICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gc29tZSBjb3JlIG1ldGhvZHNcbiAgICAgICAgY29yZV9jb25jYXQgPSBjb3JlX2RlbGV0ZWRJZHMuY29uY2F0LFxuICAgICAgICBjb3JlX3B1c2ggPSBjb3JlX2RlbGV0ZWRJZHMucHVzaCxcbiAgICAgICAgY29yZV9zbGljZSA9IGNvcmVfZGVsZXRlZElkcy5zbGljZSxcbiAgICAgICAgY29yZV9pbmRleE9mID0gY29yZV9kZWxldGVkSWRzLmluZGV4T2YsXG4gICAgICAgIGNvcmVfdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nLFxuICAgICAgICBjb3JlX2hhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvcmVfdHJpbSA9IGNvcmVfdmVyc2lvbi50cmltLFxuXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgICAgIGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcbiAgICAgICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3RqUXVlcnkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVc2VkIGZvciBtYXRjaGluZyBudW1iZXJzXG4gICAgICAgIGNvcmVfcG51bSA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSxcblxuICAgICAgICAvLyBVc2VkIGZvciBzcGxpdHRpbmcgb24gd2hpdGVzcGFjZVxuICAgICAgICBjb3JlX3Jub3R3aGl0ZSA9IC9cXFMrL2csXG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQIChoZXJlJ3MgbG9va2luZyBhdCB5b3UsIFNhZmFyaSA1LjAgYW5kIElFKVxuICAgICAgICBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAgICAgICAvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG4gICAgICAgIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuICAgICAgICBycXVpY2tFeHByID0gL14oPzooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuICAgICAgICAvLyBNYXRjaCBhIHN0YW5kYWxvbmUgdGFnXG4gICAgICAgIHJzaW5nbGVUYWcgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8sXG5cbiAgICAgICAgLy8gSlNPTiBSZWdFeHBcbiAgICAgICAgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLyxcbiAgICAgICAgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLFxuICAgICAgICBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVtcXGRhLWZBLUZdezR9KS9nLFxuICAgICAgICBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcclxcbl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/KD86XFxkK1xcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS9nLFxuXG4gICAgICAgIC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuICAgICAgICBybXNQcmVmaXggPSAvXi1tcy0vLFxuICAgICAgICByZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG4gICAgICAgIC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbiAgICAgICAgZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcbiAgICAgICAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlclxuICAgICAgICBjb21wbGV0ZWQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIC8vIHJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiBpcyBnb29kIGVub3VnaCBmb3IgdXMgdG8gY2FsbCB0aGUgZG9tIHJlYWR5IGluIG9sZElFXG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgfHwgZXZlbnQudHlwZSA9PT0gXCJsb2FkXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuICAgICAgICAgICAgICAgIGRldGFjaCgpO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBDbGVhbi11cCBtZXRob2QgZm9yIGRvbSByZWFkeSBldmVudHNcbiAgICAgICAgZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kZXRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgY29tcGxldGVkICk7XG4gICAgICAgICAgICAgICAgd2luZG93LmRldGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBjb21wbGV0ZWQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcbiAgICAgICAganF1ZXJ5OiBjb3JlX3ZlcnNpb24sXG5cbiAgICAgICAgY29uc3RydWN0b3I6IGpRdWVyeSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5ICkge1xuICAgICAgICAgICAgdmFyIG1hdGNoLCBlbGVtO1xuXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcbiAgICAgICAgICAgIGlmICggIXNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCI8XCIgJiYgc2VsZWN0b3IuY2hhckF0KCBzZWxlY3Rvci5sZW5ndGggLSAxICkgPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbMV0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoI2lkKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUgYW5kIE9wZXJhIHJldHVybiBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5pZCAhPT0gbWF0Y2hbMl0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb290alF1ZXJ5LmZpbmQoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBpbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuICAgICAgICAgICAgfSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgLy8gSEFORExFOiAkKGZ1bmN0aW9uKVxuICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG4gICAgICAgIHNlbGVjdG9yOiBcIlwiLFxuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuICAgICAgICBsZW5ndGg6IDAsXG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZV9zbGljZS5jYWxsKCB0aGlzICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuICAgICAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtID09IG51bGwgP1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgJ2NsZWFuJyBhcnJheVxuICAgICAgICAgICAgICAgIHRoaXMudG9BcnJheSgpIDpcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBqdXN0IHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAoIG51bSA8IDAgPyB0aGlzWyB0aGlzLmxlbmd0aCArIG51bSBdIDogdGhpc1sgbnVtIF0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG4gICAgICAgIC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuICAgICAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuICAgICAgICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgIHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcbiAgICAgICAgICAgIHJldC5wcmV2T2JqZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuICAgICAgICAvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuICAgICAgICAvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkeTogZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgalF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGNvcmVfc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoIDAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKCAtMSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVxOiBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICAgICAgcHVzaDogY29yZV9wdXNoLFxuICAgICAgICBzb3J0OiBbXS5zb3J0LFxuICAgICAgICBzcGxpY2U6IFtdLnNwbGljZVxuICAgIH07XG5cbiAgICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG4gICAgalF1ZXJ5LmZuLmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNyYywgY29weUlzQXJyYXksIGNvcHksIG5hbWUsIG9wdGlvbnMsIGNsb25lLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBpID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgICBpZiAoIGxlbmd0aCA9PT0gaSApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAtLWk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBub0NvbmZsaWN0OiBmdW5jdGlvbiggZGVlcCApIHtcbiAgICAgICAgICAgIGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuXG4gICAgICAgIC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcbiAgICAgICAgcmVhZHlXYWl0OiAxLFxuXG4gICAgICAgIC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuICAgICAgICBob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuICAgICAgICAgICAgaWYgKCBob2xkICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KCB0cnVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuICAgICAgICByZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cbiAgICAgICAgICAgIC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcbiAgICAgICAgICAgIGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGJvZHkgZXhpc3RzLCBhdCBsZWFzdCwgaW4gY2FzZSBJRSBnZXRzIGEgbGl0dGxlIG92ZXJ6ZWFsb3VzICh0aWNrZXQgIzU0NDMpLlxuICAgICAgICAgICAgaWYgKCAhZG9jdW1lbnQuYm9keSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgICAgICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuICAgICAgICAgICAgaWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG4gICAgICAgICAgICByZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuICAgICAgICAgICAgaWYgKCBqUXVlcnkuZm4udHJpZ2dlciApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlcihcInJlYWR5XCIpLm9mZihcInJlYWR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlZSB0ZXN0L3VuaXQvY29yZS5qcyBmb3IgZGV0YWlscyBjb25jZXJuaW5nIGlzRnVuY3Rpb24uXG4gICAgICAgIC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcbiAgICAgICAgLy8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS5cbiAgICAgICAgaXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiYXJyYXlcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbiAgICAgICAgfSxcblxuICAgICAgICBpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KG9iaikgKSAmJiBpc0Zpbml0ZSggb2JqICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHlwZTogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIGlmICggb2JqID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyggb2JqICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuICAgICAgICAgICAgICAgIGNsYXNzMnR5cGVbIGNvcmVfdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9iajtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBhbiBPYmplY3QuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAoICFvYmogfHwgalF1ZXJ5LnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuICAgICAgICAgICAgICAgIGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICFjb3JlX2hhc093bi5jYWxsKG9iaiwgXCJjb25zdHJ1Y3RvclwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhY29yZV9oYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAvLyBJRTgsOSBXaWxsIHRocm93IGV4Y2VwdGlvbnMgb24gY2VydGFpbiBob3N0IG9iamVjdHMgIzk4OTdcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuICAgICAgICAgICAgLy8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKCBrZXkgaW4gb2JqICkge31cblxuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGNvcmVfaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvYmogKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4gICAgICAgIC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCwgZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgICAgICAgLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xuICAgICAgICBwYXJzZUhUTUw6IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcbiAgICAgICAgICAgIGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgICAgICBrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG4gICAgICAgICAgICAvLyBTaW5nbGUgdGFnXG4gICAgICAgICAgICBpZiAoIHBhcnNlZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuICAgICAgICAgICAgaWYgKCBzY3JpcHRzICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VKU09OOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICAgICAgICAgICAgaWYgKCB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LkpTT04ucGFyc2UoIGRhdGEgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkYXRhID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyByZW1vdmVkIChJRSBjYW4ndCBoYW5kbGUgaXQpXG4gICAgICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS50cmltKCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5jb21pbmcgZGF0YSBpcyBhY3R1YWwgSlNPTlxuICAgICAgICAgICAgICAgICAgICAvLyBMb2dpYyBib3Jyb3dlZCBmcm9tIGh0dHA6Ly9qc29uLm9yZy9qc29uMi5qc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJ2YWxpZGNoYXJzLnRlc3QoIGRhdGEucmVwbGFjZSggcnZhbGlkZXNjYXBlLCBcIkBcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSggcnZhbGlkdG9rZW5zLCBcIl1cIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSggcnZhbGlkYnJhY2VzLCBcIlwiKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIG5ldyBGdW5jdGlvbiggXCJyZXR1cm4gXCIgKyBkYXRhICkgKSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG4gICAgICAgIHBhcnNlWE1MOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgIHZhciB4bWwsIHRtcDtcbiAgICAgICAgICAgIGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICggd2luZG93LkRPTVBhcnNlciApIHsgLy8gU3RhbmRhcmRcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICB4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhICwgXCJ0ZXh0L3htbFwiICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSUVcbiAgICAgICAgICAgICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTERPTVwiICk7XG4gICAgICAgICAgICAgICAgICAgIHhtbC5hc3luYyA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgICAgICAgICAgeG1sLmxvYWRYTUwoIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAgICAgICAgIHhtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHhtbDtcbiAgICAgICAgfSxcblxuICAgICAgICBub29wOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG4gICAgICAgIC8vIFdvcmthcm91bmRzIGJhc2VkIG9uIGZpbmRpbmdzIGJ5IEppbSBEcmlzY29sbFxuICAgICAgICAvLyBodHRwOi8vd2VibG9ncy5qYXZhLm5ldC9ibG9nL2RyaXNjb2xsL2FyY2hpdmUvMjAwOS8wOS8wOC9ldmFsLWphdmFzY3JpcHQtZ2xvYmFsLWNvbnRleHRcbiAgICAgICAgZ2xvYmFsRXZhbDogZnVuY3Rpb24oIGRhdGEgKSB7XG4gICAgICAgICAgICBpZiAoIGRhdGEgJiYgalF1ZXJ5LnRyaW0oIGRhdGEgKSApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZXhlY1NjcmlwdCBvbiBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gc28gdGhhdCBjb250ZXh0IGlzIHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGpRdWVyeSBpbiBGaXJlZm94XG4gICAgICAgICAgICAgICAgKCB3aW5kb3cuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93WyBcImV2YWxcIiBdLmNhbGwoIHdpbmRvdywgZGF0YSApO1xuICAgICAgICAgICAgICAgIH0gKSggZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbiAgICAgICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuICAgICAgICBjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IGlzQXJyYXlsaWtlKCBvYmogKTtcblxuICAgICAgICAgICAgaWYgKCBhcmdzICkge1xuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVXNlIG5hdGl2ZSBTdHJpbmcudHJpbSBmdW5jdGlvbiB3aGVyZXZlciBwb3NzaWJsZVxuICAgICAgICB0cmltOiBjb3JlX3RyaW0gJiYgIWNvcmVfdHJpbS5jYWxsKFwiXFx1RkVGRlxceEEwXCIpID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBcIlwiIDpcbiAgICAgICAgICAgICAgICAgICAgY29yZV90cmltLmNhbGwoIHRleHQgKTtcbiAgICAgICAgICAgIH0gOlxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIG91ciBvd24gdHJpbW1pbmcgZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgZnVuY3Rpb24oIHRleHQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICAoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCBhcnIgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHJldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgWyBhcnIgXSA6IGFyclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfcHVzaC5jYWxsKCByZXQsIGFyciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuICAgICAgICAgICAgdmFyIGxlbjtcblxuICAgICAgICAgICAgaWYgKCBhcnIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb3JlX2luZGV4T2YgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlX2luZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpID0gaSA/IGkgPCAwID8gTWF0aC5tYXgoIDAsIGxlbiArIGkgKSA6IGkgOiAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgYWNjZXNzaW5nIGluIHNwYXJzZSBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpIGluIGFyciAmJiBhcnJbIGkgXSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuICAgICAgICAgICAgdmFyIGwgPSBzZWNvbmQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGkgPSBmaXJzdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGwgPT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBqIDwgbDsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdC5sZW5ndGggPSBpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ICkge1xuICAgICAgICAgICAgdmFyIHJldFZhbCxcbiAgICAgICAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBpbnYgPSAhIWludjtcblxuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuICAgICAgICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIHJldFZhbCA9ICEhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGludiAhPT0gcmV0VmFsICkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCggZWxlbXNbIGkgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgICAgbWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGlzQXJyYXkgPSBpc0FycmF5bGlrZSggZWxlbXMgKSxcbiAgICAgICAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyXG4gICAgICAgICAgICBpZiAoIGlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFsgcmV0Lmxlbmd0aCBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gZWxlbXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFsgcmV0Lmxlbmd0aCBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIHJldHVybiBjb3JlX2NvbmNhdC5hcHBseSggW10sIHJldCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuICAgICAgICBndWlkOiAxLFxuXG4gICAgICAgIC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuICAgICAgICAvLyBhcmd1bWVudHMuXG4gICAgICAgIHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG4gICAgICAgICAgICB2YXIgYXJncywgcHJveHksIHRtcDtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBmblsgY29udGV4dCBdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBmbjtcbiAgICAgICAgICAgICAgICBmbiA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcbiAgICAgICAgICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICBpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaW11bGF0ZWQgYmluZFxuICAgICAgICAgICAgYXJncyA9IGNvcmVfc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG4gICAgICAgICAgICBwcm94eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG4gICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4gICAgICAgIC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuICAgICAgICBhY2Nlc3M6IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYnVsayA9IGtleSA9PSBudWxsO1xuXG4gICAgICAgICAgICAvLyBTZXRzIG1hbnkgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoIGkgaW4ga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0cyBvbmUgdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICByYXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggYnVsayApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICggcmF3ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVsayA9IGZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZuICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKCBlbGVtc1tpXSwga2V5LCByYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoIGVsZW1zW2ldLCBpLCBmbiggZWxlbXNbaV0sIGtleSApICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYWluYWJsZSA/XG4gICAgICAgICAgICAgICAgZWxlbXMgOlxuXG4gICAgICAgICAgICAgICAgLy8gR2V0c1xuICAgICAgICAgICAgICAgIGJ1bGsgP1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcyApIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIGlmICggIXJlYWR5TGlzdCApIHtcblxuICAgICAgICAgICAgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuICAgICAgICAgICAgLy8gd2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG4gICAgICAgICAgICAvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuICAgICAgICAgICAgLy8gU3RhbmRhcmRzLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnQgRE9NQ29udGVudExvYWRlZFxuICAgICAgICAgICAgfSBlbHNlIGlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuICAgICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cbiAgICAgICAgICAgIC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLCBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXNcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgY29tcGxldGVkICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbmxvYWRcIiwgY29tcGxldGVkICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcbiAgICAgICAgICAgICAgICAvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gd2luZG93LmZyYW1lRWxlbWVudCA9PSBudWxsICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRvcCAmJiB0b3AuZG9TY3JvbGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LmlzUmVhZHkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCggZG9TY3JvbGxDaGVjaywgNTAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXRhY2ggYWxsIGRvbSByZWFkeSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2goKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBleGVjdXRlIGFueSB3YWl0aW5nIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xuICAgIH07XG5cbiAgICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbiAgICBqUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5bGlrZSggb2JqICkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cbiAgICAgICAgaWYgKCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgKCBsZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmogKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgalF1ZXJ5IG9iamVjdHMgc2hvdWxkIHBvaW50IGJhY2sgdG8gdGhlc2VcbiAgICByb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcbiAgICAvLyBTdHJpbmcgdG8gT2JqZWN0IG9wdGlvbnMgZm9ybWF0IGNhY2hlXG4gICAgdmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xuXG4gICAgLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdID0ge307XG4gICAgICAgIGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcbiAgICAgICAgICAgIG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gICAgICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICAgICAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gICAgICpcbiAgICAgKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gICAgICpcbiAgICAgKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAgICAgKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gICAgICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gICAgICpcbiAgICAgKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICAgICAqXG4gICAgICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gICAgICpcbiAgICAgKi9cbiAgICBqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuICAgICAgICAvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG4gICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAoIG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdIHx8IGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSApIDpcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cbiAgICAgICAgdmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgICAgICAgIGZpcmluZyxcbiAgICAgICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcbiAgICAgICAgICAgIG1lbW9yeSxcbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICAgICAgICBmaXJlZCxcbiAgICAgICAgICAgIC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLFxuICAgICAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcbiAgICAgICAgICAgIGZpcmluZ0luZGV4LFxuICAgICAgICAgICAgLy8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG4gICAgICAgICAgICBmaXJpbmdTdGFydCxcbiAgICAgICAgICAgIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG4gICAgICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgICAgICAvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG4gICAgICAgICAgICBzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICAgICAgICAgIG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XG4gICAgICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcbiAgICAgICAgICAgICAgICBmaXJpbmdTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggZGF0YVsgMCBdLCBkYXRhWyAxIF0gKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YWNrLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCBzdGFjay5zaGlmdCgpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG4gICAgICAgICAgICBzZWxmID0ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIGFkZCggYXJncyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goIGFyZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKCBhcmcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoP1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmaXJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCBtZW1vcnkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRleCA8PSBmaXJpbmdMZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOiAhISggbGlzdCAmJiBsaXN0Lmxlbmd0aCApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG4gICAgICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBJcyBpdCBkaXNhYmxlZD9cbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhbGlzdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1lbW9yeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gSXMgaXQgbG9ja2VkP1xuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RhY2s7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0ICYmICggIWZpcmVkIHx8IHN0YWNrICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpcmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuICAgICAgICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZmlyZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGpRdWVyeS5leHRlbmQoe1xuXG4gICAgICAgIERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcbiAgICAgICAgICAgIHZhciB0dXBsZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlc29sdmVkXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgWyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlamVjdGVkXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgWyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIikgXVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBcInBlbmRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9taXNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gdHVwbGVbIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZFsgdHVwbGVbMV0gXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbIGFjdGlvbiArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcblxuICAgICAgICAgICAgLy8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgcHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG4gICAgICAgICAgICAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuICAgICAgICAgICAgICAgIHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICggc3RhdGVTdHJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0cmluZztcblxuICAgICAgICAgICAgICAgICAgICAvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG4gICAgICAgICAgICAgICAgICAgIH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcbiAgICAgICAgICAgIHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuICAgICAgICAgICAgaWYgKCBmdW5jICkge1xuICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbCBkb25lIVxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERlZmVycmVkIGhlbHBlclxuICAgICAgICB3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzID0gY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvcmVfc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuICAgICAgICAgICAgLy8gYWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuICAgICAgICAgICAgaWYgKCBsZW5ndGggPiAxICkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1yZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcbiAgICAgICAgICAgIGlmICggIXJlbWFpbmluZyApIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBqUXVlcnkuc3VwcG9ydCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3VwcG9ydCwgYWxsLCBhLFxuICAgICAgICAgICAgaW5wdXQsIHNlbGVjdCwgZnJhZ21lbnQsXG4gICAgICAgICAgICBvcHQsIGV2ZW50TmFtZSwgaXNTdXBwb3J0ZWQsIGksXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIC8vIFNldHVwXG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIsIFwidFwiICk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgdGVzdHMgd29uJ3QgcnVuIGluIHNvbWUgbGltaXRlZCBvciBub24tYnJvd3NlciBlbnZpcm9ubWVudHNcbiAgICAgICAgYWxsID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKTtcbiAgICAgICAgYSA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIilbIDAgXTtcbiAgICAgICAgaWYgKCAhYWxsIHx8ICFhIHx8ICFhbGwubGVuZ3RoICkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgYmF0Y2ggb2YgdGVzdHNcbiAgICAgICAgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICAgICAgb3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpICk7XG4gICAgICAgIGlucHV0ID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbIDAgXTtcblxuICAgICAgICBhLnN0eWxlLmNzc1RleHQgPSBcInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCI7XG4gICAgICAgIHN1cHBvcnQgPSB7XG4gICAgICAgICAgICAvLyBUZXN0IHNldEF0dHJpYnV0ZSBvbiBjYW1lbENhc2UgY2xhc3MuIElmIGl0IHdvcmtzLCB3ZSBuZWVkIGF0dHJGaXhlcyB3aGVuIGRvaW5nIGdldC9zZXRBdHRyaWJ1dGUgKGllNi83KVxuICAgICAgICAgICAgZ2V0U2V0QXR0cmlidXRlOiBkaXYuY2xhc3NOYW1lICE9PSBcInRcIixcblxuICAgICAgICAgICAgLy8gSUUgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIC5pbm5lckhUTUwgaXMgdXNlZFxuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2U6IGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gSUUgd2lsbCBpbnNlcnQgdGhlbSBpbnRvIGVtcHR5IHRhYmxlc1xuICAgICAgICAgICAgdGJvZHk6ICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKS5sZW5ndGgsXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuICAgICAgICAgICAgLy8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuICAgICAgICAgICAgaHRtbFNlcmlhbGl6ZTogISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLmxlbmd0aCxcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gKElFIHVzZXMgLmNzc1RleHQgaW5zdGVhZClcbiAgICAgICAgICAgIHN0eWxlOiAvdG9wLy50ZXN0KCBhLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpICksXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IFVSTHMgYXJlbid0IG1hbmlwdWxhdGVkXG4gICAgICAgICAgICAvLyAoSUUgbm9ybWFsaXplcyBpdCBieSBkZWZhdWx0KVxuICAgICAgICAgICAgaHJlZk5vcm1hbGl6ZWQ6IGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50IG9wYWNpdHkgZXhpc3RzXG4gICAgICAgICAgICAvLyAoSUUgdXNlcyBmaWx0ZXIgaW5zdGVhZClcbiAgICAgICAgICAgIC8vIFVzZSBhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGlzc3VlLiBTZWUgIzUxNDVcbiAgICAgICAgICAgIG9wYWNpdHk6IC9eMC41Ly50ZXN0KCBhLnN0eWxlLm9wYWNpdHkgKSxcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZVxuICAgICAgICAgICAgLy8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KVxuICAgICAgICAgICAgY3NzRmxvYXQ6ICEhYS5zdHlsZS5jc3NGbG9hdCxcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZmF1bHQgY2hlY2tib3gvcmFkaW8gdmFsdWUgKFwiXCIgb24gV2ViS2l0OyBcIm9uXCIgZWxzZXdoZXJlKVxuICAgICAgICAgICAgY2hlY2tPbjogISFpbnB1dC52YWx1ZSxcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3RlZC1ieS1kZWZhdWx0IG9wdGlvbiBoYXMgYSB3b3JraW5nIHNlbGVjdGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gKFdlYktpdCBkZWZhdWx0cyB0byBmYWxzZSBpbnN0ZWFkIG9mIHRydWUsIElFIHRvbywgaWYgaXQncyBpbiBhbiBvcHRncm91cClcbiAgICAgICAgICAgIG9wdFNlbGVjdGVkOiBvcHQuc2VsZWN0ZWQsXG5cbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBlbmN0eXBlIHN1cHBvcnQgb24gYSBmb3JtICgjNjc0MylcbiAgICAgICAgICAgIGVuY3R5cGU6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSxcblxuICAgICAgICAgICAgLy8gTWFrZXMgc3VyZSBjbG9uaW5nIGFuIGh0bWw1IGVsZW1lbnQgZG9lcyBub3QgY2F1c2UgcHJvYmxlbXNcbiAgICAgICAgICAgIC8vIFdoZXJlIG91dGVySFRNTCBpcyB1bmRlZmluZWQsIHRoaXMgc3RpbGwgd29ya3NcbiAgICAgICAgICAgIGh0bWw1Q2xvbmU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJuYXZcIikuY2xvbmVOb2RlKCB0cnVlICkub3V0ZXJIVE1MICE9PSBcIjw6bmF2PjwvOm5hdj5cIixcblxuICAgICAgICAgICAgLy8galF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgREVQUkVDQVRFRCBpbiAxLjggc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydCBRdWlya3MgTW9kZVxuICAgICAgICAgICAgYm94TW9kZWw6IGRvY3VtZW50LmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiLFxuXG4gICAgICAgICAgICAvLyBXaWxsIGJlIGRlZmluZWQgbGF0ZXJcbiAgICAgICAgICAgIGRlbGV0ZUV4cGFuZG86IHRydWUsXG4gICAgICAgICAgICBub0Nsb25lRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBpbmxpbmVCbG9ja05lZWRzTGF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgIHNocmlua1dyYXBCbG9ja3M6IGZhbHNlLFxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5SaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgY2hlY2tlZCBzdGF0dXMgaXMgcHJvcGVybHkgY2xvbmVkXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICBzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gaW5wdXQuY2xvbmVOb2RlKCB0cnVlICkuY2hlY2tlZDtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmVuJ3QgbWFya2VkIGFzIGRpc2FibGVkXG4gICAgICAgIC8vIChXZWJLaXQgbWFya3MgdGhlbSBhcyBkaXNhYmxlZClcbiAgICAgICAgc2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgc3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIGRpdi50ZXN0O1xuICAgICAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAgICAgc3VwcG9ydC5kZWxldGVFeHBhbmRvID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gdHJ1c3QgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG4gICAgICAgIHN1cHBvcnQuaW5wdXQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGFuIGlucHV0IG1haW50YWlucyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgICAgICBpbnB1dC52YWx1ZSA9IFwidFwiO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcbiAgICAgICAgc3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuXG4gICAgICAgIC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcInRcIiApO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG4gICAgICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxuICAgICAgICAvLyB2YWx1ZSBvZiB0cnVlIGFmdGVyIGFwcGVuZGVkIHRvIHRoZSBET00gKElFNi83KVxuICAgICAgICBzdXBwb3J0LmFwcGVuZENoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXG4gICAgICAgIC8vIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuICAgICAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBmcmFnbWVudC5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgIC8vIE9wZXJhIGRvZXMgbm90IGNsb25lIGV2ZW50cyAoYW5kIHR5cGVvZiBkaXYuYXR0YWNoRXZlbnQgPT09IHVuZGVmaW5lZCkuXG4gICAgICAgIC8vIElFOS0xMCBjbG9uZXMgZXZlbnRzIGJvdW5kIHZpYSBhdHRhY2hFdmVudCwgYnV0IHRoZXkgZG9uJ3QgdHJpZ2dlciB3aXRoIC5jbGljaygpXG4gICAgICAgIGlmICggZGl2LmF0dGFjaEV2ZW50ICkge1xuICAgICAgICAgICAgZGl2LmF0dGFjaEV2ZW50KCBcIm9uY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xpY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDkgKGxhY2sgc3VibWl0L2NoYW5nZSBidWJibGUpLCBGaXJlZm94IDE3KyAobGFjayBmb2N1c2luIGV2ZW50KVxuICAgICAgICAvLyBCZXdhcmUgb2YgQ1NQIHJlc3RyaWN0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU2VjdXJpdHkvQ1NQKSwgdGVzdC9jc3AucGhwXG4gICAgICAgIGZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIGNoYW5nZTogdHJ1ZSwgZm9jdXNpbjogdHJ1ZSB9KSB7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCBldmVudE5hbWUgPSBcIm9uXCIgKyBpLCBcInRcIiApO1xuXG4gICAgICAgICAgICBzdXBwb3J0WyBpICsgXCJCdWJibGVzXCIgXSA9IGV2ZW50TmFtZSBpbiB3aW5kb3cgfHwgZGl2LmF0dHJpYnV0ZXNbIGV2ZW50TmFtZSBdLmV4cGFuZG8gPT09IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuICAgICAgICBzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG4gICAgICAgIC8vIFJ1biB0ZXN0cyB0aGF0IG5lZWQgYSBib2R5IGF0IGRvYyByZWFkeVxuICAgICAgICBqUXVlcnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyLCBtYXJnaW5EaXYsIHRkcyxcbiAgICAgICAgICAgICAgICBkaXZSZXNldCA9IFwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiLFxuICAgICAgICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG5cbiAgICAgICAgICAgIGlmICggIWJvZHkgKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZvciBmcmFtZXNldCBkb2NzIHRoYXQgZG9uJ3QgaGF2ZSBhIGJvZHlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0Oi05OTk5cHg7bWFyZ2luLXRvcDoxcHhcIjtcblxuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XG4gICAgICAgICAgICAvLyB0byBkaXNwbGF5Om5vbmUgYW5kIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB2aXNpYmxlIHRhYmxlIGNlbGxzIGluIGFcbiAgICAgICAgICAgIC8vIHRhYmxlIHJvdzsgaWYgc28sIG9mZnNldFdpZHRoL0hlaWdodCBhcmUgbm90IHJlbGlhYmxlIGZvciB1c2Ugd2hlblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcbiAgICAgICAgICAgIC8vIGRpc3BsYXk6bm9uZSAoaXQgaXMgc3RpbGwgc2FmZSB0byB1c2Ugb2Zmc2V0cyBpZiBhIHBhcmVudCBlbGVtZW50IGlzXG4gICAgICAgICAgICAvLyBoaWRkZW47IGRvbiBzYWZldHkgZ29nZ2xlcyBhbmQgc2VlIGJ1ZyAjNDUxMiBmb3IgbW9yZSBpbmZvcm1hdGlvbikuXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGFibGU+PHRyPjx0ZD48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCI7XG4gICAgICAgICAgICB0ZHMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKTtcbiAgICAgICAgICAgIHRkc1sgMCBdLnN0eWxlLmNzc1RleHQgPSBcInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5Om5vbmVcIjtcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gKCB0ZHNbIDAgXS5vZmZzZXRIZWlnaHQgPT09IDAgKTtcblxuICAgICAgICAgICAgdGRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICB0ZHNbIDEgXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZW1wdHkgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHRcbiAgICAgICAgICAgIHN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzID0gaXNTdXBwb3J0ZWQgJiYgKCB0ZHNbIDAgXS5vZmZzZXRIZWlnaHQgPT09IDAgKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgYm94LXNpemluZyBhbmQgbWFyZ2luIGJlaGF2aW9yXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzoxcHg7Ym9yZGVyOjFweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjRweDttYXJnaW4tdG9wOjElO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxJTtcIjtcbiAgICAgICAgICAgIHN1cHBvcnQuYm94U2l6aW5nID0gKCBkaXYub2Zmc2V0V2lkdGggPT09IDQgKTtcbiAgICAgICAgICAgIHN1cHBvcnQuZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQgPSAoIGJvZHkub2Zmc2V0VG9wICE9PSAxICk7XG5cbiAgICAgICAgICAgIC8vIFVzZSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSBiZWNhdXNlIGpzZG9tIG9uIG5vZGUuanMgd2lsbCBicmVhayB3aXRob3V0IGl0LlxuICAgICAgICAgICAgaWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0LnBpeGVsUG9zaXRpb24gPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7fSApLnRvcCAhPT0gXCIxJVwiO1xuICAgICAgICAgICAgICAgIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUgPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7IHdpZHRoOiBcIjRweFwiIH0gKS53aWR0aCA9PT0gXCI0cHhcIjtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIuICgjMzMzMylcbiAgICAgICAgICAgICAgICAvLyBGYWlscyBpbiBXZWJLaXQgYmVmb3JlIEZlYiAyMDExIG5pZ2h0bGllc1xuICAgICAgICAgICAgICAgIC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuICAgICAgICAgICAgICAgIG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuICAgICAgICAgICAgICAgIG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPSBkaXZSZXNldDtcbiAgICAgICAgICAgICAgICBtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgIXBhcnNlRmxvYXQoICggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApIHx8IHt9ICkubWFyZ2luUmlnaHQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IGNvcmVfc3RydW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyB3aGVuIHNldHRpbmcgdGhlaXIgZGlzcGxheSB0byAnaW5saW5lJyBhbmQgZ2l2aW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBsYXlvdXRcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IGRpdlJlc2V0ICsgXCJ3aWR0aDoxcHg7cGFkZGluZzoxcHg7ZGlzcGxheTppbmxpbmU7em9vbToxXCI7XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gKCBkaXYub2Zmc2V0V2lkdGggPT09IDMgKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFNlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnRzIHdpdGggbGF5b3V0IHNocmluay13cmFwIHRoZWlyIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGRpdj48L2Rpdj5cIjtcbiAgICAgICAgICAgICAgICBkaXYuZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFwiNXB4XCI7XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzID0gKCBkaXYub2Zmc2V0V2lkdGggIT09IDMgKTtcblxuICAgICAgICAgICAgICAgIGlmICggc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IElFIDYgZnJvbSBhZmZlY3RpbmcgbGF5b3V0IGZvciBwb3NpdGlvbmVkIGVsZW1lbnRzICMxMTA0OFxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IElFIGZyb20gc2hyaW5raW5nIHRoZSBib2R5IGluIElFIDcgbW9kZSAjMTI4NjlcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxuICAgICAgICAgICAgICAgICAgICBib2R5LnN0eWxlLnpvb20gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cbiAgICAgICAgICAgIC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUVcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRpdiA9IHRkcyA9IG1hcmdpbkRpdiA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUVcbiAgICAgICAgYWxsID0gc2VsZWN0ID0gZnJhZ21lbnQgPSBvcHQgPSBhID0gaW5wdXQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgIH0pKCk7XG5cbiAgICB2YXIgcmJyYWNlID0gLyg/Olxce1tcXHNcXFNdKlxcfXxcXFtbXFxzXFxTXSpcXF0pJC8sXG4gICAgICAgIHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKXtcbiAgICAgICAgaWYgKCAhalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQ2FjaGUsIHJldCxcbiAgICAgICAgICAgIGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG4gICAgICAgICAgICBnZXRCeU5hbWUgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIixcblxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBoYW5kbGUgRE9NIG5vZGVzIGFuZCBKUyBvYmplY3RzIGRpZmZlcmVudGx5IGJlY2F1c2UgSUU2LTdcbiAgICAgICAgICAgIC8vIGNhbid0IEdDIG9iamVjdCByZWZlcmVuY2VzIHByb3Blcmx5IGFjcm9zcyB0aGUgRE9NLUpTIGJvdW5kYXJ5XG4gICAgICAgICAgICBpc05vZGUgPSBlbGVtLm5vZGVUeXBlLFxuXG4gICAgICAgICAgICAvLyBPbmx5IERPTSBub2RlcyBuZWVkIHRoZSBnbG9iYWwgalF1ZXJ5IGNhY2hlOyBKUyBvYmplY3QgZGF0YSBpc1xuICAgICAgICAgICAgLy8gYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdCBzbyBHQyBjYW4gb2NjdXIgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgY2FjaGUgPSBpc05vZGUgPyBqUXVlcnkuY2FjaGUgOiBlbGVtLFxuXG4gICAgICAgICAgICAvLyBPbmx5IGRlZmluaW5nIGFuIElEIGZvciBKUyBvYmplY3RzIGlmIGl0cyBjYWNoZSBhbHJlYWR5IGV4aXN0cyBhbGxvd3NcbiAgICAgICAgICAgIC8vIHRoZSBjb2RlIHRvIHNob3J0Y3V0IG9uIHRoZSBzYW1lIHBhdGggYXMgYSBET00gbm9kZSB3aXRoIG5vIGNhY2hlXG4gICAgICAgICAgICBpZCA9IGlzTm9kZSA/IGVsZW1bIGludGVybmFsS2V5IF0gOiBlbGVtWyBpbnRlcm5hbEtleSBdICYmIGludGVybmFsS2V5O1xuXG4gICAgICAgIC8vIEF2b2lkIGRvaW5nIGFueSBtb3JlIHdvcmsgdGhhbiB3ZSBuZWVkIHRvIHdoZW4gdHJ5aW5nIHRvIGdldCBkYXRhIG9uIGFuXG4gICAgICAgIC8vIG9iamVjdCB0aGF0IGhhcyBubyBkYXRhIGF0IGFsbFxuICAgICAgICBpZiAoICghaWQgfHwgIWNhY2hlW2lkXSB8fCAoIXB2dCAmJiAhY2FjaGVbaWRdLmRhdGEpKSAmJiBnZXRCeU5hbWUgJiYgZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhaWQgKSB7XG4gICAgICAgICAgICAvLyBPbmx5IERPTSBub2RlcyBuZWVkIGEgbmV3IHVuaXF1ZSBJRCBmb3IgZWFjaCBlbGVtZW50IHNpbmNlIHRoZWlyIGRhdGFcbiAgICAgICAgICAgIC8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZVxuICAgICAgICAgICAgaWYgKCBpc05vZGUgKSB7XG4gICAgICAgICAgICAgICAgZWxlbVsgaW50ZXJuYWxLZXkgXSA9IGlkID0gY29yZV9kZWxldGVkSWRzLnBvcCgpIHx8IGpRdWVyeS5ndWlkKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkID0gaW50ZXJuYWxLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICFjYWNoZVsgaWQgXSApIHtcbiAgICAgICAgICAgIGNhY2hlWyBpZCBdID0ge307XG5cbiAgICAgICAgICAgIC8vIEF2b2lkcyBleHBvc2luZyBqUXVlcnkgbWV0YWRhdGEgb24gcGxhaW4gSlMgb2JqZWN0cyB3aGVuIHRoZSBvYmplY3RcbiAgICAgICAgICAgIC8vIGlzIHNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnlcbiAgICAgICAgICAgIGlmICggIWlzTm9kZSApIHtcbiAgICAgICAgICAgICAgICBjYWNoZVsgaWQgXS50b0pTT04gPSBqUXVlcnkubm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuIG9iamVjdCBjYW4gYmUgcGFzc2VkIHRvIGpRdWVyeS5kYXRhIGluc3RlYWQgb2YgYSBrZXkvdmFsdWUgcGFpcjsgdGhpcyBnZXRzXG4gICAgICAgIC8vIHNoYWxsb3cgY29waWVkIG92ZXIgb250byB0aGUgZXhpc3RpbmcgY2FjaGVcbiAgICAgICAgaWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgaWYgKCBwdnQgKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbIGlkIF0gPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXSwgbmFtZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWNoZVsgaWQgXS5kYXRhID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0uZGF0YSwgbmFtZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc0NhY2hlID0gY2FjaGVbIGlkIF07XG5cbiAgICAgICAgLy8galF1ZXJ5IGRhdGEoKSBpcyBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBvYmplY3QgaW5zaWRlIHRoZSBvYmplY3QncyBpbnRlcm5hbCBkYXRhXG4gICAgICAgIC8vIGNhY2hlIGluIG9yZGVyIHRvIGF2b2lkIGtleSBjb2xsaXNpb25zIGJldHdlZW4gaW50ZXJuYWwgZGF0YSBhbmQgdXNlci1kZWZpbmVkXG4gICAgICAgIC8vIGRhdGEuXG4gICAgICAgIGlmICggIXB2dCApIHtcbiAgICAgICAgICAgIGlmICggIXRoaXNDYWNoZS5kYXRhICkge1xuICAgICAgICAgICAgICAgIHRoaXNDYWNoZS5kYXRhID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNDYWNoZSA9IHRoaXNDYWNoZS5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0aGlzQ2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSBdID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBib3RoIGNvbnZlcnRlZC10by1jYW1lbCBhbmQgbm9uLWNvbnZlcnRlZCBkYXRhIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIC8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGlmICggZ2V0QnlOYW1lICkge1xuXG4gICAgICAgICAgICAvLyBGaXJzdCBUcnkgdG8gZmluZCBhcy1pcyBwcm9wZXJ0eSBkYXRhXG4gICAgICAgICAgICByZXQgPSB0aGlzQ2FjaGVbIG5hbWUgXTtcblxuICAgICAgICAgICAgLy8gVGVzdCBmb3IgbnVsbHx1bmRlZmluZWQgcHJvcGVydHkgZGF0YVxuICAgICAgICAgICAgaWYgKCByZXQgPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXNDYWNoZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCBwdnQgKSB7XG4gICAgICAgIGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSwgbCwgdGhpc0NhY2hlLFxuICAgICAgICAgICAgaXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuICAgICAgICAgICAgLy8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG4gICAgICAgICAgICBpZCA9IGlzTm9kZSA/IGVsZW1bIGpRdWVyeS5leHBhbmRvIF0gOiBqUXVlcnkuZXhwYW5kbztcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gcHVycG9zZSBpbiBjb250aW51aW5nXG4gICAgICAgIGlmICggIWNhY2hlWyBpZCBdICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBuYW1lICkge1xuXG4gICAgICAgICAgICB0aGlzQ2FjaGUgPSBwdnQgPyBjYWNoZVsgaWQgXSA6IGNhY2hlWyBpZCBdLmRhdGE7XG5cbiAgICAgICAgICAgIGlmICggdGhpc0NhY2hlICkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG5hbWVzIGZvciBkYXRhIGtleXNcbiAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gWyBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBjYW1lbCBjYXNlZCB2ZXJzaW9uIGJ5IHNwYWNlcyB1bmxlc3MgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5jb25jYXQoIGpRdWVyeS5tYXAoIG5hbWUsIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzQ2FjaGVbIG5hbWVbaV0gXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIGxlZnQgaW4gdGhlIGNhY2hlLCB3ZSB3YW50IHRvIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgLy8gYW5kIGxldCB0aGUgY2FjaGUgb2JqZWN0IGl0c2VsZiBnZXQgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBwdnQgPyBpc0VtcHR5RGF0YU9iamVjdCA6IGpRdWVyeS5pc0VtcHR5T2JqZWN0ICkoIHRoaXNDYWNoZSApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICAgIGlmICggIXB2dCApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXS5kYXRhO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBkZXN0cm95IHRoZSBwYXJlbnQgY2FjaGUgdW5sZXNzIHRoZSBpbnRlcm5hbCBkYXRhIG9iamVjdFxuICAgICAgICAgICAgLy8gaGFkIGJlZW4gdGhlIG9ubHkgdGhpbmcgbGVmdCBpbiBpdFxuICAgICAgICAgICAgaWYgKCAhaXNFbXB0eURhdGFPYmplY3QoIGNhY2hlWyBpZCBdICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzdHJveSB0aGUgY2FjaGVcbiAgICAgICAgaWYgKCBpc05vZGUgKSB7XG4gICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXG4gICAgICAgIC8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKVxuICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuc3VwcG9ydC5kZWxldGVFeHBhbmRvIHx8IGNhY2hlICE9IGNhY2hlLndpbmRvdyApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXTtcblxuICAgICAgICAvLyBXaGVuIGFsbCBlbHNlIGZhaWxzLCBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZVsgaWQgXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgY2FjaGU6IHt9LFxuXG4gICAgICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuICAgICAgICAvLyBOb24tZGlnaXRzIHJlbW92ZWQgdG8gbWF0Y2ggcmlubGluZWpRdWVyeVxuICAgICAgICBleHBhbmRvOiBcImpRdWVyeVwiICsgKCBjb3JlX3ZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBlbGVtZW50cyB0aHJvdyB1bmNhdGNoYWJsZSBleGNlcHRpb25zIGlmIHlvdVxuICAgICAgICAvLyBhdHRlbXB0IHRvIGFkZCBleHBhbmRvIHByb3BlcnRpZXMgdG8gdGhlbS5cbiAgICAgICAgbm9EYXRhOiB7XG4gICAgICAgICAgICBcImVtYmVkXCI6IHRydWUsXG4gICAgICAgICAgICAvLyBCYW4gYWxsIG9iamVjdHMgZXhjZXB0IGZvciBGbGFzaCAod2hpY2ggaGFuZGxlIGV4cGFuZG9zKVxuICAgICAgICAgICAgXCJvYmplY3RcIjogXCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIixcbiAgICAgICAgICAgIFwiYXBwbGV0XCI6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLm5vZGVUeXBlID8galF1ZXJ5LmNhY2hlWyBlbGVtW2pRdWVyeS5leHBhbmRvXSBdIDogZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTtcbiAgICAgICAgICAgIHJldHVybiAhIWVsZW0gJiYgIWlzRW1wdHlEYXRhT2JqZWN0KCBlbGVtICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAgICBfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCB0cnVlICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsUmVtb3ZlRGF0YSggZWxlbSwgbmFtZSwgdHJ1ZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIERPTSBub2RlIGNhbiBoYW5kbGUgdGhlIGRhdGEgZXhwYW5kb1xuICAgICAgICBhY2NlcHREYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBzZXQgZGF0YSBvbiBub24tZWxlbWVudCBiZWNhdXNlIGl0IHdpbGwgbm90IGJlIGNsZWFyZWQgKCM4MzM1KS5cbiAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSAmJiBlbGVtLm5vZGVUeXBlICE9PSAxICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9EYXRhID0gZWxlbS5ub2RlTmFtZSAmJiBqUXVlcnkubm9EYXRhWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuICAgICAgICAgICAgLy8gbm9kZXMgYWNjZXB0IGRhdGEgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQ7IHJlamVjdGlvbiBjYW4gYmUgY29uZGl0aW9uYWxcbiAgICAgICAgICAgIHJldHVybiAhbm9EYXRhIHx8IG5vRGF0YSAhPT0gdHJ1ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIikgPT09IG5vRGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGF0dHJzLCBuYW1lLFxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBlbGVtLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKDUpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggZWxlbSwgXCJwYXJzZWRBdHRyc1wiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSggdGhpcywga2V5ICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmZXRjaCBhbnkgaW50ZXJuYWxseSBzdG9yZWQgZGF0YSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA/IGRhdGFBdHRyKCBlbGVtLCBrZXksIGpRdWVyeS5kYXRhKCBlbGVtLCBrZXkgKSApIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKCB0aGlzLCBrZXksIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcbiAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuICAgICAgICAvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuICAgICAgICAgICAgdmFyIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICArZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG4gICAgICAgICAgICAgICAgICAgICAgICByYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7fVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEoIGVsZW0sIGtleSwgZGF0YSApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLyBjaGVja3MgYSBjYWNoZSBvYmplY3QgZm9yIGVtcHRpbmVzc1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlEYXRhT2JqZWN0KCBvYmogKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBmb3IgKCBuYW1lIGluIG9iaiApIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHB1YmxpYyBkYXRhIG9iamVjdCBpcyBlbXB0eSwgdGhlIHByaXZhdGUgaXMgc3RpbGwgZW1wdHlcbiAgICAgICAgICAgIGlmICggbmFtZSA9PT0gXCJkYXRhXCIgJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9ialtuYW1lXSApICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBuYW1lICE9PSBcInRvSlNPTlwiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICAgICAgICAgIGlmICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoZGF0YSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCggZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG4gICAgICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgICAgIGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBzdGFydExlbmd0aC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob29rcy5jdXIgPSBmbjtcbiAgICAgICAgICAgIGlmICggZm4gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcbiAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbm90IGludGVuZGVkIGZvciBwdWJsaWMgY29uc3VtcHRpb24gLSBnZW5lcmF0ZXMgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJucyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSApIHx8IGpRdWVyeS5fZGF0YSggZWxlbSwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgdHlwZSArIFwicXVldWVcIiApO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIGtleSApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHZhciBzZXR0ZXIgPSAyO1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImZ4XCI7XG4gICAgICAgICAgICAgICAgc2V0dGVyLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4gICAgICAgIC8vIGh0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuICAgICAgICAgICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcbiAgICAgICAgICAgICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcbiAgICAgICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG4gICAgICAgICAgICB2YXIgdG1wLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gMSxcbiAgICAgICAgICAgICAgICBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICEoIC0tY291bnQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgd2hpbGUoIGktLSApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBqUXVlcnkuX2RhdGEoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuICAgICAgICAgICAgICAgIGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBub2RlSG9vaywgYm9vbEhvb2ssXG4gICAgICAgIHJjbGFzcyA9IC9bXFx0XFxyXFxuXS9nLFxuICAgICAgICBycmV0dXJuID0gL1xcci9nLFxuICAgICAgICByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkL2ksXG4gICAgICAgIHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2ksXG4gICAgICAgIHJib29sZWFuID0gL14oPzpjaGVja2VkfHNlbGVjdGVkfGF1dG9mb2N1c3xhdXRvcGxheXxhc3luY3xjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZCkkL2ksXG4gICAgICAgIHJ1c2VEZWZhdWx0ID0gL14oPzpjaGVja2VkfHNlbGVjdGVkKSQvaSxcbiAgICAgICAgZ2V0U2V0QXR0cmlidXRlID0galF1ZXJ5LnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLFxuICAgICAgICBnZXRTZXRJbnB1dCA9IGpRdWVyeS5zdXBwb3J0LmlucHV0O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5L2NhdGNoIGhhbmRsZXMgY2FzZXMgd2hlcmUgSUUgYmFsa3MgKHN1Y2ggYXMgcmVtb3ZpbmcgYSBwcm9wZXJ0eSBvbiB3aW5kb3cpXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1sgbmFtZSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1sgbmFtZSBdO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBwcm9jZWVkICkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcHJvY2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHByb2NlZWQgKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGN1ciApIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc0Jvb2wgPSB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiO1xuXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0galF1ZXJ5KCB0aGlzICksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlVmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBpc0Jvb2wgPyBzdGF0ZSA6ICFzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZbIHN0YXRlID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiIF0oIGNsYXNzTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09IGNvcmVfc3RydW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY2xhc3NOYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIFwiZmFsc2VcIixcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/IFwiXCIgOiBqUXVlcnkuX2RhdGEoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcywgaXNGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1swXTtcblxuICAgICAgICAgICAgaWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXQgPSBlbGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIHNlbGYudmFsKCkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG4gICAgICAgICAgICAgICAgaWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHZhbEhvb2tzOiB7XG4gICAgICAgICAgICBvcHRpb246IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzLnZhbHVlIGlzIHVuZGVmaW5lZCBpbiBCbGFja2JlcnJ5IDQuNyBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlcyAudmFsdWUuIFNlZSAjNjkzMlxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZWxlbS5hdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXZhbCB8fCB2YWwuc3BlY2lmaWVkID8gZWxlbS52YWx1ZSA6IGVsZW0udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4IDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgPyBpbmRleCA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkSUUgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGpRdWVyeS5zdXBwb3J0Lm9wdERpc2FibGVkID8gIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PT0gbnVsbCApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeShlbGVtKS5maW5kKFwib3B0aW9uXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSh0aGlzKS52YWwoKSwgdmFsdWVzICkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhdmFsdWVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBob29rcywgbm90eG1sLCByZXQsXG4gICAgICAgICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICAgICAgICBpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBjb3JlX3N0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuICAgICAgICAgICAgLy8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuICAgICAgICAgICAgLy8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCBub3R4bWwgKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fCAoIHJib29sZWFuLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGhvb2tzICYmIG5vdHhtbCAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGhvb2tzICYmIG5vdHhtbCAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIEluIElFOSssIEZsYXNoIG9iamVjdHMgZG9uJ3QgaGF2ZSAuZ2V0QXR0cmlidXRlICgjMTI5NDUpXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5K1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBjb3JlX3N0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgICAgICByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIG5hbWUsIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApO1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgIHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByYm9vbGVhbi50ZXN0KCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIGNsZWFyIGRlZmF1bHRDaGVja2VkL2RlZmF1bHRTZWxlY3RlZCAoaWYgYXBwcm9wcmlhdGUpIGZvciBJRTw4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFnZXRTZXRBdHRyaWJ1dGUgJiYgcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIGpRdWVyeS5jYW1lbENhc2UoIFwiZGVmYXVsdC1cIiArIG5hbWUgKSBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlICM5Njk5IGZvciBleHBsYW5hdGlvbiBvZiB0aGlzIGFwcHJvYWNoIChzZXR0aW5nIGZpcnN0LCB0aGVuIHJlbW92YWwpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXR0ciggZWxlbSwgbmFtZSwgXCJcIiApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGdldFNldEF0dHJpYnV0ZSA/IG5hbWUgOiBwcm9wTmFtZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRySG9va3M6IHtcbiAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcImlucHV0XCIpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0aGUgdHlwZSBvbiBhIHJhZGlvIGJ1dHRvbiBhZnRlciB0aGUgdmFsdWUgcmVzZXRzIHRoZSB2YWx1ZSBpbiBJRTYtOVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdmFsdWUgdG8gZGVmYXVsdCBpbiBjYXNlIHR5cGUgaXMgc2V0IGFmdGVyIHZhbHVlIGR1cmluZyBjcmVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByb3BGaXg6IHtcbiAgICAgICAgICAgIHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG4gICAgICAgICAgICByZWFkb25seTogXCJyZWFkT25seVwiLFxuICAgICAgICAgICAgXCJmb3JcIjogXCJodG1sRm9yXCIsXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgICAgICBtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gICAgICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICAgICAgY2VsbHBhZGRpbmc6IFwiY2VsbFBhZGRpbmdcIixcbiAgICAgICAgICAgIHJvd3NwYW46IFwicm93U3BhblwiLFxuICAgICAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiXG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsIG5vdHhtbCxcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgICAgIGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cbiAgICAgICAgICAgIGlmICggbm90eG1sICkge1xuICAgICAgICAgICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcbiAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtWyBuYW1lIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByb3BIb29rczoge1xuICAgICAgICAgICAgdGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwidGFiaW5kZXhcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5vZGUgJiYgYXR0cmlidXRlTm9kZS5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoIGF0dHJpYnV0ZU5vZGUudmFsdWUsIDEwICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIb29rIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbiAgICBib29sSG9vayA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIC8vIFVzZSAucHJvcCB0byBkZXRlcm1pbmUgaWYgdGhpcyBhdHRyaWJ1dGUgaXMgdW5kZXJzdG9vZCBhcyBib29sZWFuXG4gICAgICAgICAgICAgICAgcHJvcCA9IGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lICksXG5cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBpdCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgIGF0dHIgPSB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSxcbiAgICAgICAgICAgICAgICBkZXRhaWwgPSB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIgP1xuXG4gICAgICAgICAgICAgICAgICAgIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyICE9IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkSUUgZmFicmljYXRlcyBhbiBlbXB0eSBzdHJpbmcgZm9yIG1pc3NpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29uZmxhdGVzIGNoZWNrZWQvc2VsZWN0ZWQgaW50byBhdHRyb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhYXR0ciA6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2ggYW4gYXR0cmlidXRlIG5vZGUgZm9yIHByb3BlcnRpZXMgbm90IHJlY29nbml6ZWQgYXMgYm9vbGVhblxuICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbCAmJiBkZXRhaWwudmFsdWUgIT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG4gICAgICAgICAgICBpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkge1xuICAgICAgICAgICAgICAgIC8vIElFPDggbmVlZHMgdGhlICpwcm9wZXJ0eSogbmFtZVxuICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCAhZ2V0U2V0QXR0cmlidXRlICYmIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSwgbmFtZSApO1xuXG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdENoZWNrZWQgYW5kIGRlZmF1bHRTZWxlY3RlZCBmb3Igb2xkSUVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPSBlbGVtWyBuYW1lIF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBmaXggb2xkSUUgdmFsdWUgYXR0cm9wZXJ0eVxuICAgIGlmICggIWdldFNldElucHV0IHx8ICFnZXRTZXRBdHRyaWJ1dGUgKSB7XG4gICAgICAgIGpRdWVyeS5hdHRySG9va3MudmFsdWUgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSA/XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZSB2YWx1ZSAqcHJvcGVydHkqIGJ5IHVzaW5nIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICBlbGVtLmRlZmF1bHRWYWx1ZSA6XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0ICYmIHJldC5zcGVjaWZpZWQgPyByZXQudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5vZGVIb29rIGlmIGRlZmluZWQgKCMxOTU0KTsgb3RoZXJ3aXNlIHNldEF0dHJpYnV0ZSBpcyBmaW5lXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlSG9vayAmJiBub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElFNi83IGRvIG5vdCBzdXBwb3J0IGdldHRpbmcvc2V0dGluZyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBnZXQvc2V0QXR0cmlidXRlXG4gICAgaWYgKCAhZ2V0U2V0QXR0cmlidXRlICkge1xuXG4gICAgICAgIC8vIFVzZSB0aGlzIGZvciBhbnkgYXR0cmlidXRlIGluIElFNi83XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgYWxtb3N0IGV2ZXJ5IElFNi83IGlzc3VlXG4gICAgICAgIG5vZGVIb29rID0galF1ZXJ5LnZhbEhvb2tzLmJ1dHRvbiA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQgJiYgKCBuYW1lID09PSBcImlkXCIgfHwgbmFtZSA9PT0gXCJuYW1lXCIgfHwgbmFtZSA9PT0gXCJjb29yZHNcIiA/IHJldC52YWx1ZSAhPT0gXCJcIiA6IHJldC5zcGVjaWZpZWQgKSA/XG4gICAgICAgICAgICAgICAgICAgIHJldC52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGV4aXN0aW5nIG9yIGNyZWF0ZSBhIG5ldyBhdHRyaWJ1dGUgbm9kZVxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcbiAgICAgICAgICAgICAgICBpZiAoICFyZXQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXQgPSBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKCBuYW1lICkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0LnZhbHVlID0gdmFsdWUgKz0gXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vIEJyZWFrIGFzc29jaWF0aW9uIHdpdGggY2xvbmVkIGVsZW1lbnRzIGJ5IGFsc28gdXNpbmcgc2V0QXR0cmlidXRlICgjOTY0NilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJ2YWx1ZVwiIHx8IHZhbHVlID09PSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApID9cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IGNvbnRlbnRlZGl0YWJsZSB0byBmYWxzZSBvbiByZW1vdmFscygjMTA0MjkpXG4gICAgICAgIC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXG4gICAgICAgIGpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0ge1xuICAgICAgICAgICAgZ2V0OiBub2RlSG9vay5nZXQsXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgICAgICAgICAgICBub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlID09PSBcIlwiID8gZmFsc2UgOiB2YWx1ZSwgbmFtZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGF1dG8gaW5zdGVhZCBvZiAwIG9uIGVtcHR5IHN0cmluZyggQnVnICM4MTUwIClcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgcmVtb3ZhbHNcbiAgICAgICAgalF1ZXJ5LmVhY2goWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG4gICAgICAgICAgICBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0sIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBcImF1dG9cIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLy8gU29tZSBhdHRyaWJ1dGVzIHJlcXVpcmUgYSBzcGVjaWFsIGNhbGwgb24gSUVcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKFsgXCJocmVmXCIsIFwic3JjXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICAgICAgICAgIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgMiApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGhyZWYvc3JjIHByb3BlcnR5IHNob3VsZCBnZXQgdGhlIGZ1bGwgbm9ybWFsaXplZCBVUkwgKCMxMDI5OS8jMTI5MTUpXG4gICAgICAgIGpRdWVyeS5lYWNoKFsgXCJocmVmXCIsIFwic3JjXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG4gICAgICAgICAgICBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCA0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3R5bGUgKSB7XG4gICAgICAgIGpRdWVyeS5hdHRySG9va3Muc3R5bGUgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2YgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogSUUgdXBwZXJjYXNlcyBjc3MgcHJvcGVydHkgbmFtZXMsIGJ1dCBpZiB3ZSB3ZXJlIHRvIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgLy8gLmNzc1RleHQsIHRoYXQgd291bGQgZGVzdHJveSBjYXNlIHNlbnN0aXRpdml0eSBpbiBVUkwncywgbGlrZSBpbiBcImJhY2tncm91bmRcIlxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnN0eWxlLmNzc1RleHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0uc3R5bGUuY3NzVGV4dCA9IHZhbHVlICsgXCJcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNhZmFyaSBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb25cbiAgICAvLyBBY2Nlc3NpbmcgdGhlIHBhcmVudCdzIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgZml4ZXMgaXRcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcbiAgICAgICAgalF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpdCBhbHNvIHdvcmtzIHdpdGggb3B0Z3JvdXBzLCBzZWUgIzU3MDFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIElFNi83IGNhbGwgZW5jdHlwZSBlbmNvZGluZ1xuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmVuY3R5cGUgKSB7XG4gICAgICAgIGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG4gICAgfVxuXG4gICAgLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5jaGVja09uICkge1xuICAgICAgICBqUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGluIFdlYmtpdCBcIlwiIGlzIHJldHVybmVkIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgdmFsdWUgaXNuJ3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgalF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkudmFsSG9va3NbIHRoaXMgXSwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUgKSA+PSAwICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgcmZvcm1FbGVtcyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaSxcbiAgICAgICAgcmtleUV2ZW50ID0gL15rZXkvLFxuICAgICAgICBybW91c2VFdmVudCA9IC9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLyxcbiAgICAgICAgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG4gICAgICAgIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG5cbiAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICAgICAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gICAgICovXG4gICAgalF1ZXJ5LmV2ZW50ID0ge1xuXG4gICAgICAgIGdsb2JhbDoge30sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIHRtcCwgZXZlbnRzLCB0LCBoYW5kbGVPYmpJbixcbiAgICAgICAgICAgICAgICBzcGVjaWFsLCBldmVudEhhbmRsZSwgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGpRdWVyeS5fZGF0YSggZWxlbSApO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuICAgICAgICAgICAgaWYgKCAhZWxlbURhdGEgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgIGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcbiAgICAgICAgICAgIGlmICggIWhhbmRsZXIuZ3VpZCApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgICAgICBpZiAoICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gY29yZV9zdHJ1bmRlZmluZWQgJiYgKCFlIHx8IGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBldmVudEhhbmRsZS5lbGVtLCBhcmd1bWVudHMgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUgZm4gdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrIHdpdGggSUUgbm9uLW5hdGl2ZSBldmVudHNcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZS5lbGVtID0gZWxlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgICAgICAgLy8galF1ZXJ5KC4uLikuYmluZChcIm1vdXNlb3ZlciBtb3VzZW91dFwiLCBmbik7XG4gICAgICAgICAgICB0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtcIlwiXTtcbiAgICAgICAgICAgIHQgPSB0eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIHQtLSApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG4gICAgICAgICAgICAgICAgdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlT2JqSW4gKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCaW5kIHRoZSBnbG9iYWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZWxlbS5hdHRhY2hFdmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBldmVudEhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsLmFkZCApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTnVsbGlmeSBlbGVtIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFXG4gICAgICAgICAgICBlbGVtID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcbiAgICAgICAgICAgIHZhciBqLCBoYW5kbGVPYmosIHRtcCxcbiAgICAgICAgICAgICAgICBvcmlnQ291bnQsIHQsIGV2ZW50cyxcbiAgICAgICAgICAgICAgICBzcGVjaWFsLCBoYW5kbGVycywgdHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cbiAgICAgICAgICAgIGlmICggIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcbiAgICAgICAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIGNvcmVfcm5vdHdoaXRlICkgfHwgW1wiXCJdO1xuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggdC0tICkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG4gICAgICAgICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcbiAgICAgICAgICAgICAgICB0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgIG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBqLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuICAgICAgICAgICAgICAgIC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuICAgICAgICAgICAgICAgIGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmVEYXRhIGFsc28gY2hlY2tzIGZvciBlbXB0aW5lc3MgYW5kIGNsZWFycyB0aGUgZXhwYW5kbyBpZiBlbXB0eVxuICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBpdCBpbnN0ZWFkIG9mIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJldmVudHNcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSwgb250eXBlLCBjdXIsXG4gICAgICAgICAgICAgICAgYnViYmxlVHlwZSwgc3BlY2lhbCwgdG1wLCBpLFxuICAgICAgICAgICAgICAgIGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBjb3JlX2hhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gY29yZV9oYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuICAgICAgICAgICAgY3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuICAgICAgICAgICAgaWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG4gICAgICAgICAgICAgICAgLy8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMuc29ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb250eXBlID0gdHlwZS5pbmRleE9mKFwiOlwiKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICAgICAgICBldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cbiAgICAgICAgICAgICAgICBldmVudCA6XG4gICAgICAgICAgICAgICAgbmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIGV2ZW50LmlzVHJpZ2dlciA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhID09IG51bGwgP1xuICAgICAgICAgICAgICAgIFsgZXZlbnQgXSA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcbiAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcbiAgICAgICAgICAgIC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG4gICAgICAgICAgICAgICAgYnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSBjdXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG4gICAgICAgICAgICAgICAgaWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBpID4gMSA/XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZVR5cGUgOlxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgaGFuZGxlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaGFuZGxlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuICAgICAgICAgICAgICAgIGlmICggaGFuZGxlICYmIGpRdWVyeS5hY2NlcHREYXRhKCBjdXIgKSAmJiBoYW5kbGUuYXBwbHkgJiYgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgICAgIC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcbiAgICAgICAgICAgIGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBlbGVtLm93bmVyRG9jdW1lbnQsIGRhdGEgKSA9PT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICEodHlwZSA9PT0gXCJjbGlja1wiICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJhXCIgKSkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHVzZSBhbiAuaXNGdW5jdGlvbigpIGNoZWNrIGhlcmUgYmVjYXVzZSBJRTYvNyBmYWlscyB0aGF0IHRlc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvbnR5cGUgJiYgZWxlbVsgdHlwZSBdICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gZWxlbVsgb250eXBlIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyB0eXBlIF0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFPDkgZGllcyBvbiBmb2N1cy9ibHVyIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwjMTI1MTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSByZXByb2R1Y2libGUgb24gd2luWFAgSUU4IG5hdGl2ZSwgbm90IElFOSBpbiBJRTggbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0bXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgb250eXBlIF0gPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgLy8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIHZhciBpLCByZXQsIGhhbmRsZU9iaiwgbWF0Y2hlZCwgaixcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcbiAgICAgICAgICAgICAgICBhcmdzID0gY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9ICggalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuICAgICAgICAgICAgYXJnc1swXSA9IGV2ZW50O1xuICAgICAgICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG4gICAgICAgICAgICBpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBoYW5kbGVyc1xuICAgICAgICAgICAgaGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG4gICAgICAgICAgICAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoIChtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICggKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIDIpIGhhdmUgbmFtZXNwYWNlKHMpIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICFldmVudC5uYW1lc3BhY2VfcmUgfHwgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuICAgICAgICAgICAgaWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuICAgICAgICAgICAgdmFyIHNlbCwgaGFuZGxlT2JqLCBtYXRjaGVzLCBpLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuICAgICAgICAgICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuICAgICAgICAgICAgLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcbiAgICAgICAgICAgIC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBjdXIgIT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmIChjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPj0gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG4gICAgICAgICAgICBpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJRdWV1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHZhciBpLCBwcm9wLCBjb3B5LFxuICAgICAgICAgICAgICAgIHR5cGUgPSBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQgPSBldmVudCxcbiAgICAgICAgICAgICAgICBmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG4gICAgICAgICAgICBpZiAoICFmaXhIb29rICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuICAgICAgICAgICAgICAgICAgICBybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuICAgICAgICAgICAgICAgICAgICBya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG4gICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuICAgICAgICAgICAgZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cbiAgICAgICAgICAgIGkgPSBjb3B5Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb3B5WyBpIF07XG4gICAgICAgICAgICAgICAgZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgLy8gRml4IHRhcmdldCBwcm9wZXJ0eSAoIzE5MjUpXG4gICAgICAgICAgICBpZiAoICFldmVudC50YXJnZXQgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgMjMrLCBTYWZhcmk/XG4gICAgICAgICAgICAvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuICAgICAgICAgICAgaWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgIC8vIEZvciBtb3VzZS9rZXkgZXZlbnRzLCBtZXRhS2V5PT1mYWxzZSBpZiBpdCdzIHVuZGVmaW5lZCAoIzMzNjgsICMxMTMyOClcbiAgICAgICAgICAgIGV2ZW50Lm1ldGFLZXkgPSAhIWV2ZW50Lm1ldGFLZXk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcbiAgICAgICAgcHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG4gICAgICAgIGZpeEhvb2tzOiB7fSxcblxuICAgICAgICBrZXlIb29rczoge1xuICAgICAgICAgICAgcHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZUhvb2tzOiB7XG4gICAgICAgICAgICBwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHksIGV2ZW50RG9jLCBkb2MsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsZW1lbnQgPSBvcmlnaW5hbC5mcm9tRWxlbWVudDtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArICggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICsgKCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCByZWxhdGVkVGFyZ2V0LCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoICFldmVudC5yZWxhdGVkVGFyZ2V0ICYmIGZyb21FbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IG9yaWdpbmFsLnRvRWxlbWVudCA6IGZyb21FbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuICAgICAgICAgICAgICAgIGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNwZWNpYWw6IHtcbiAgICAgICAgICAgIGxvYWQ6IHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG4gICAgICAgICAgICAgICAgbm9CdWJibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgICAgIC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSAmJiB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcyAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiB0aGlzLmZvY3VzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGVycm9yIG9uIGZvY3VzIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwgIzEyNTE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgLnRyaWdnZXIoKSBydW4gdGhlIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcyA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiB0aGlzLmJsdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJlZm9yZXVubG9hZDoge1xuICAgICAgICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gd2hlbiByZXR1cm5WYWx1ZSBlcXVhbHMgdG8gdW5kZWZpbmVkIEZpcmVmb3ggd2lsbCBzdGlsbCBzaG93IGFsZXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcbiAgICAgICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cbiAgICAgICAgICAgIC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuICAgICAgICAgICAgLy8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG4gICAgICAgICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG4gICAgICAgICAgICAgICAgbmV3IGpRdWVyeS5FdmVudCgpLFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTaW11bGF0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggYnViYmxlICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5kaXNwYXRjaC5jYWxsKCBlbGVtLCBlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkucmVtb3ZlRXZlbnQgPSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyID9cbiAgICAgICAgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcbiAgICAgICAgICAgIGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlLCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJvblwiICsgdHlwZTtcblxuICAgICAgICAgICAgaWYgKCBlbGVtLmRldGFjaEV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gIzg1NDUsICM3MDU0LCBwcmV2ZW50aW5nIG1lbW9yeSBsZWFrcyBmb3IgY3VzdG9tIGV2ZW50cyBpbiBJRTYtOFxuICAgICAgICAgICAgICAgIC8vIGRldGFjaEV2ZW50IG5lZWRlZCBwcm9wZXJ0eSBvbiBlbGVtZW50LCBieSBuYW1lIG9mIHRoYXQgZXZlbnQsIHRvIHByb3Blcmx5IGV4cG9zZSBpdCB0byBHQ1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW1bIG5hbWUgXSA9PT0gY29yZV9zdHJ1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1bIG5hbWUgXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbS5kZXRhY2hFdmVudCggbmFtZSwgaGFuZGxlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVudCBvYmplY3RcbiAgICAgICAgaWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgICAgICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgICAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoIHNyYy5kZWZhdWx0UHJldmVudGVkIHx8IHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICBzcmMuZ2V0UHJldmVudERlZmF1bHQgJiYgc3JjLmdldFByZXZlbnREZWZhdWx0KCkgKSA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcblxuICAgICAgICAvLyBFdmVudCB0eXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICBpZiAoIHByb3BzICkge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG4gICAgICAgIC8vIE1hcmsgaXQgYXMgZml4ZWRcbiAgICAgICAgdGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuICAgIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG4gICAgICAgICAgICBpZiAoICFlICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgcHJldmVudERlZmF1bHQgZXhpc3RzLCBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgICAgICAgICBpZiAoIGUucHJldmVudERlZmF1bHQgKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgICAgICAgIGlmICggIWUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgICAgICAgaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRVxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIHRydWVcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICAgIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcbiAgICAgICAgICAgIGJpbmRUeXBlOiBmaXgsXG5cbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcbiAgICAgICAgICAgICAgICBpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBJRSBzdWJtaXQgZGVsZWdhdGlvblxuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXMgKSB7XG5cbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWwuc3VibWl0ID0ge1xuICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCBhIHN1Ym1pdCBoYW5kbGVyIHdoZW4gYSBkZXNjZW5kYW50IGZvcm0gbWF5IHBvdGVudGlhbGx5IGJlIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlIG5hbWUgY2hlY2sgYXZvaWRzIGEgVk1MLXJlbGF0ZWQgY3Jhc2ggaW4gSUUgKCM5ODA3KVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSA9IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgfHwgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgPyBlbGVtLmZvcm0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZm9ybSAmJiAhalF1ZXJ5Ll9kYXRhKCBmb3JtLCBcInN1Ym1pdEJ1YmJsZXNcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggZm9ybSwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX3N1Ym1pdF9idWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGZvcm0sIFwic3VibWl0QnViYmxlc1wiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdW5kZWZpbmVkIHNpbmNlIHdlIGRvbid0IG5lZWQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIC8vIElmIGZvcm0gd2FzIHN1Ym1pdHRlZCBieSB0aGUgdXNlciwgYnViYmxlIHRoZSBldmVudCB1cCB0aGUgdHJlZVxuICAgICAgICAgICAgICAgIGlmICggZXZlbnQuX3N1Ym1pdF9idWJibGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudC5fc3VibWl0X2J1YmJsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZGVsZWdhdGVkIGhhbmRsZXJzOyBjbGVhbkRhdGEgZXZlbnR1YWxseSByZWFwcyBzdWJtaXQgaGFuZGxlcnMgYXR0YWNoZWQgYWJvdmVcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBcIi5fc3VibWl0XCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJRSBjaGFuZ2UgZGVsZWdhdGlvbiBhbmQgY2hlY2tib3gvcmFkaW8gZml4XG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hhbmdlQnViYmxlcyApIHtcblxuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7XG5cbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmICggcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2Ugb24gYSBjaGVjay9yYWRpbyB1bnRpbCBibHVyOyB0cmlnZ2VyIGl0IG9uIGNsaWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIGEgcHJvcGVydHljaGFuZ2UuIEVhdCB0aGUgYmx1ci1jaGFuZ2UgaW4gc3BlY2lhbC5jaGFuZ2UuaGFuZGxlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHN0aWxsIGZpcmVzIG9uY2hhbmdlIGEgc2Vjb25kIHRpbWUgZm9yIGNoZWNrL3JhZGlvIGFmdGVyIGJsdXIuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWUgPT09IFwiY2hlY2tlZFwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qdXN0X2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJjbGljay5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX2p1c3RfY2hhbmdlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qdXN0X2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdHJpZ2dlcmVkLCBzaW11bGF0ZWQgY2hhbmdlIGV2ZW50cyAoIzExNTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcywgZXZlbnQsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVsZWdhdGVkIGV2ZW50OyBsYXp5LWFkZCBhIGNoYW5nZSBoYW5kbGVyIG9uIGRlc2NlbmRhbnQgaW5wdXRzXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmZvcm1FbGVtcy50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGVsZW0sIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgICAgICAgICAvLyBTd2FsbG93IG5hdGl2ZSBjaGFuZ2UgZXZlbnRzIGZyb20gY2hlY2tib3gvcmFkaW8sIHdlIGFscmVhZHkgdHJpZ2dlcmVkIHRoZW0gYWJvdmVcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMgIT09IGVsZW0gfHwgZXZlbnQuaXNTaW11bGF0ZWQgfHwgZXZlbnQuaXNUcmlnZ2VyIHx8IChlbGVtLnR5cGUgIT09IFwicmFkaW9cIiAmJiBlbGVtLnR5cGUgIT09IFwiY2hlY2tib3hcIikgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9jaGFuZ2VcIiApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuICAgICAgICBqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcbiAgICAgICAgICAgIHZhciBhdHRhY2hlcyA9IDAsXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcbiAgICAgICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYXR0YWNoZXMrKyA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIC0tYXR0YWNoZXMgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcblxuICAgICAgICBvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSwgb3JpZ0ZuO1xuXG4gICAgICAgICAgICAvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIGZuIClcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGZuID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggIWZuICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9uZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBvcmlnRm4gPSBmbjtcbiAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuICAgICAgICAgICAgICAgIGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuICAgICAgICB9LFxuICAgICAgICBvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9iaiwgdHlwZTtcbiAgICAgICAgICAgIGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuICAgICAgICAgICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuICAgICAgICB9LFxuICAgICAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6IHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcbiAgICAgICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qIVxuICAgICAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lXG4gICAgICogQ29weXJpZ2h0IDIwMTIgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciBpLFxuICAgICAgICBjYWNoZWRydW5zLFxuICAgICAgICBFeHByLFxuICAgICAgICBnZXRUZXh0LFxuICAgICAgICBpc1hNTCxcbiAgICAgICAgY29tcGlsZSxcbiAgICAgICAgaGFzRHVwbGljYXRlLFxuICAgICAgICBvdXRlcm1vc3RDb250ZXh0LFxuXG4gICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcbiAgICAgICAgc2V0RG9jdW1lbnQsXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICBkb2NFbGVtLFxuICAgICAgICBkb2N1bWVudElzWE1MLFxuICAgICAgICByYnVnZ3lRU0EsXG4gICAgICAgIHJidWdneU1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGNvbnRhaW5zLFxuICAgICAgICBzb3J0T3JkZXIsXG5cbiAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgICAgICBleHBhbmRvID0gXCJzaXp6bGVcIiArIC0obmV3IERhdGUoKSksXG4gICAgICAgIHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgc3VwcG9ydCA9IHt9LFxuICAgICAgICBkaXJydW5zID0gMCxcbiAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cbiAgICAgICAgLy8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuICAgICAgICBzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkLFxuICAgICAgICBNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG4gICAgICAgIC8vIEFycmF5IG1ldGhvZHNcbiAgICAgICAgYXJyID0gW10sXG4gICAgICAgIHBvcCA9IGFyci5wb3AsXG4gICAgICAgIHB1c2ggPSBhcnIucHVzaCxcbiAgICAgICAgc2xpY2UgPSBhcnIuc2xpY2UsXG4gICAgICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBpZiB3ZSBjYW4ndCB1c2UgYSBuYXRpdmUgb25lXG4gICAgICAgIGluZGV4T2YgPSBhcnIuaW5kZXhPZiB8fCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpc1tpXSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gUmVndWxhciBleHByZXNzaW9uc1xuXG4gICAgICAgIC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuICAgICAgICB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xuICAgICAgICBjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cbiAgICAgICAgLy8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICAgICAgLy8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG4gICAgICAgIGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG5cbiAgICAgICAgLy8gQWNjZXB0YWJsZSBvcGVyYXRvcnMgaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG4gICAgICAgIG9wZXJhdG9ycyA9IFwiKFsqXiR8IX5dPz0pXCIsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgXCIqKD86XCIgKyBvcGVyYXRvcnMgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsnXFxcIl0pKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXSkqPylcXFxcM3woXCIgKyBpZGVudGlmaWVyICsgXCIpfCl8KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cbiAgICAgICAgLy8gUHJlZmVyIGFyZ3VtZW50cyBxdW90ZWQsXG4gICAgICAgIC8vICAgdGhlbiBub3QgY29udGFpbmluZyBwc2V1ZG9zL2JyYWNrZXRzLFxuICAgICAgICAvLyAgIHRoZW4gYXR0cmlidXRlIHNlbGVjdG9ycy9ub24tcGFyZW50aGV0aWNhbCBleHByZXNzaW9ucyxcbiAgICAgICAgLy8gICB0aGVuIGFueXRoaW5nIGVsc2VcbiAgICAgICAgLy8gVGhlc2UgcHJlZmVyZW5jZXMgYXJlIGhlcmUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzXG4gICAgICAgIC8vICAgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgUFNFVURPIHByZUZpbHRlclxuICAgICAgICBwc2V1ZG9zID0gXCI6KFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcXFxcKCgoWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMucmVwbGFjZSggMywgOCApICsgXCIpKil8LiopXFxcXCl8KVwiLFxuXG4gICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG4gICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuICAgICAgICByY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZj4rfl0pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcbiAgICAgICAgcnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcbiAgICAgICAgcmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG4gICAgICAgIG1hdGNoRXhwciA9IHtcbiAgICAgICAgICAgIFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcbiAgICAgICAgICAgIFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG4gICAgICAgICAgICBcIk5BTUVcIjogbmV3IFJlZ0V4cCggXCJeXFxcXFtuYW1lPVsnXFxcIl0/KFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilbJ1xcXCJdP1xcXFxdXCIgKSxcbiAgICAgICAgICAgIFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncqXCIgKSArIFwiKVwiICksXG4gICAgICAgICAgICBcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG4gICAgICAgICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcbiAgICAgICAgICAgIFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcbiAgICAgICAgICAgIC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuICAgICAgICAgICAgXCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcbiAgICAgICAgfSxcblxuICAgICAgICByc2libGluZyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKlsrfl0vLFxuXG4gICAgICAgIHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBjb2RlLyxcblxuICAgICAgICAvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcbiAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG4gICAgICAgIHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuICAgICAgICByaGVhZGVyID0gL15oXFxkJC9pLFxuXG4gICAgICAgIHJlc2NhcGUgPSAvJ3xcXFxcL2csXG4gICAgICAgIHJhdHRyaWJ1dGVRdW90ZXMgPSAvXFw9W1xceDIwXFx0XFxyXFxuXFxmXSooW14nXCJcXF1dKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcXS9nLFxuXG4gICAgICAgIC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcbiAgICAgICAgcnVuZXNjYXBlID0gL1xcXFwoW1xcZGEtZkEtRl17MSw2fVtcXHgyMFxcdFxcclxcblxcZl0/fC4pL2csXG4gICAgICAgIGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkICkge1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG4gICAgICAgICAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCA/XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA6XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGVwb2ludFxuICAgICAgICAgICAgICAgIGhpZ2ggPCAwID9cbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcbiAgICAgICAgfTtcblxuICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gc2xpY2UgaWYgd2UgY2FuJ3QgdXNlIGEgbmF0aXZlIG9uZVxuICAgIHRyeSB7XG4gICAgICAgIHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcywgMCApWzBdLm5vZGVUeXBlO1xuICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICBzbGljZSA9IGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IHRoaXNbaSsrXSkgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZmVhdHVyZSBkZXRlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gdGVzdCBmb3IgbmF0aXZlIHN1cHBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSggZm4gKSB7XG4gICAgICAgIHJldHVybiBybmF0aXZlLnRlc3QoIGZuICsgXCJcIiApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAgICAgKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAgICAgKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICB2YXIgY2FjaGUsXG4gICAgICAgICAgICBrZXlzID0gW107XG5cbiAgICAgICAgcmV0dXJuIChjYWNoZSA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgICAgICAgIGlmICgga2V5cy5wdXNoKCBrZXkgKz0gXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVbIGtleSBdID0gdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgZm5bIGV4cGFuZG8gXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oIGRpdiApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG4gICAgICAgIHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXG4gICAgICAgICAgICAvLyBRU0EgdmFyc1xuICAgICAgICAgICAgaSwgZ3JvdXBzLCBvbGQsIG5pZCwgbmV3Q29udGV4dCwgbmV3U2VsZWN0b3I7XG5cbiAgICAgICAgaWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgIHNldERvY3VtZW50KCBjb250ZXh0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cbiAgICAgICAgaWYgKCAhc2VsZWN0b3IgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIChub2RlVHlwZSA9IGNvbnRleHQubm9kZVR5cGUpICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhZG9jdW1lbnRJc1hNTCAmJiAhc2VlZCApIHtcblxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICBpZiAoIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlZWQtdXA6IFNpenpsZShcIiNJRFwiKVxuICAgICAgICAgICAgICAgIGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyggY29udGV4dCwgZWxlbSApICYmIGVsZW0uaWQgPT09IG0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbChjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApLCAwKSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblxuICAgICAgICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIuQ0xBU1NcIilcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEJ5Q2xhc3NOYW1lICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbChjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSwgMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBRU0EgcGF0aFxuICAgICAgICAgICAgaWYgKCBzdXBwb3J0LnFzYSAmJiAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpICkge1xuICAgICAgICAgICAgICAgIG9sZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmlkID0gZXhwYW5kbztcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IG5vZGVUeXBlID09PSA5ICYmIHNlbGVjdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxuICAgICAgICAgICAgICAgIC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuaWQgPSBcIltpZD0nXCIgKyBuaWQgKyBcIiddIFwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIGNvbnRleHQucGFyZW50Tm9kZSB8fCBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG5ld1NlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbCggbmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICApLCAwICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKHFzYUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFvbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbCBvdGhlcnNcbiAgICAgICAgcmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IHhtbFxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gICAgICovXG4gICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgLy8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgICAgICAvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcbiAgICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAqL1xuICAgIHNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG4gICAgICAgIHZhciBkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cbiAgICAgICAgLy8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuICAgICAgICBpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IG91ciBkb2N1bWVudFxuICAgICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgLy8gU3VwcG9ydCB0ZXN0c1xuICAgICAgICBkb2N1bWVudElzWE1MID0gaXNYTUwoIGRvYyApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcbiAgICAgICAgc3VwcG9ydC50YWdOYW1lTm9Db21tZW50cyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuICAgICAgICAgICAgcmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYXR0cmlidXRlcyBzaG91bGQgYmUgcmV0cmlldmVkIGJ5IGF0dHJpYnV0ZSBub2Rlc1xuICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzZWxlY3Q+PC9zZWxlY3Q+XCI7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBkaXYubGFzdENoaWxkLmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpO1xuICAgICAgICAgICAgLy8gSUU4IHJldHVybnMgYSBzdHJpbmcgZm9yIHNvbWUgYXR0cmlidXRlcyBldmVuIHdoZW4gbm90IHByZXNlbnRcbiAgICAgICAgICAgIHJldHVybiB0eXBlICE9PSBcImJvb2xlYW5cIiAmJiB0eXBlICE9PSBcInN0cmluZ1wiO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGNhbiBiZSB0cnVzdGVkXG4gICAgICAgIHN1cHBvcnQuZ2V0QnlDbGFzc05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIGNhbid0IGZpbmQgYSBzZWNvbmQgY2xhc3NuYW1lIChpbiA5LjYpXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdoaWRkZW4gZSc+PC9kaXY+PGRpdiBjbGFzcz0naGlkZGVuJz48L2Rpdj5cIjtcbiAgICAgICAgICAgIGlmICggIWRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIHx8ICFkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2FmYXJpIDMuMiBjYWNoZXMgY2xhc3MgYXR0cmlidXRlcyBhbmQgZG9lc24ndCBjYXRjaCBjaGFuZ2VzXG4gICAgICAgICAgICBkaXYubGFzdENoaWxkLmNsYXNzTmFtZSA9IFwiZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggPT09IDI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5TmFtZSBwcml2aWxlZ2VzIGZvcm0gY29udHJvbHMgb3IgcmV0dXJucyBlbGVtZW50cyBieSBJRFxuICAgICAgICBzdXBwb3J0LmdldEJ5TmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgLy8gSW5qZWN0IGNvbnRlbnRcbiAgICAgICAgICAgIGRpdi5pZCA9IGV4cGFuZG8gKyAwO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGEgbmFtZT0nXCIgKyBleHBhbmRvICsgXCInPjwvYT48ZGl2IG5hbWU9J1wiICsgZXhwYW5kbyArIFwiJz48L2Rpdj5cIjtcbiAgICAgICAgICAgIGRvY0VsZW0uaW5zZXJ0QmVmb3JlKCBkaXYsIGRvY0VsZW0uZmlyc3RDaGlsZCApO1xuXG4gICAgICAgICAgICAvLyBUZXN0XG4gICAgICAgICAgICB2YXIgcGFzcyA9IGRvYy5nZXRFbGVtZW50c0J5TmFtZSAmJlxuICAgICAgICAgICAgICAgIC8vIGJ1Z2d5IGJyb3dzZXJzIHdpbGwgcmV0dXJuIGZld2VyIHRoYW4gdGhlIGNvcnJlY3QgMlxuICAgICAgICAgICAgICAgIGRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aCA9PT0gMiArXG4gICAgICAgICAgICAgICAgLy8gYnVnZ3kgYnJvd3NlcnMgd2lsbCByZXR1cm4gbW9yZSB0aGFuIHRoZSBjb3JyZWN0IDBcbiAgICAgICAgICAgICAgICBkb2MuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKyAwICkubGVuZ3RoO1xuICAgICAgICAgICAgc3VwcG9ydC5nZXRJZE5vdE5hbWUgPSAhZG9jLmdldEVsZW1lbnRCeUlkKCBleHBhbmRvICk7XG5cbiAgICAgICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgICAgIGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXG4gICAgICAgICAgICByZXR1cm4gcGFzcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSUU2LzcgcmV0dXJuIG1vZGlmaWVkIGF0dHJpYnV0ZXNcbiAgICAgICAgRXhwci5hdHRySGFuZGxlID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG4gICAgICAgICAgICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQgJiYgdHlwZW9mIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSAhPT0gc3RydW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCI7XG4gICAgICAgIH0pID9cbiAgICAgICAgICAgIHt9IDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImhyZWZcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJocmVmXCIsIDIgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIElEIGZpbmQgYW5kIGZpbHRlclxuICAgICAgICBpZiAoIHN1cHBvcnQuZ2V0SWROb3ROYW1lICkge1xuICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gc3RydW5kZWZpbmVkICYmICFkb2N1bWVudElzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gW21dIDogW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gc3RydW5kZWZpbmVkICYmICFkb2N1bWVudElzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5pZCA9PT0gaWQgfHwgdHlwZW9mIG0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gc3RydW5kZWZpbmVkICYmIG0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLnZhbHVlID09PSBpZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21dIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhZ1xuICAgICAgICBFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LnRhZ05hbWVOb0NvbW1lbnRzID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICB0bXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gTmFtZVxuICAgICAgICBFeHByLmZpbmRbXCJOQU1FXCJdID0gc3VwcG9ydC5nZXRCeU5hbWUgJiYgZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUgIT09IHN0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggbmFtZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENsYXNzXG4gICAgICAgIEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgIWRvY3VtZW50SXNYTUwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG4gICAgICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG4gICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTtcblxuICAgICAgICAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKSxcbiAgICAgICAgLy8gbm8gbmVlZCB0byBhbHNvIGFkZCB0byBidWdneU1hdGNoZXMgc2luY2UgbWF0Y2hlcyBjaGVja3MgYnVnZ3lRU0FcbiAgICAgICAgLy8gQSBzdXBwb3J0IHRlc3Qgd291bGQgcmVxdWlyZSB0b28gbXVjaCBjb2RlICh3b3VsZCBpbmNsdWRlIGRvY3VtZW50IHJlYWR5KVxuICAgICAgICByYnVnZ3lRU0EgPSBbIFwiOmZvY3VzXCIgXTtcblxuICAgICAgICBpZiAoIChzdXBwb3J0LnFzYSA9IGlzTmF0aXZlKGRvYy5xdWVyeVNlbGVjdG9yQWxsKSkgKSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBRU0EgcmVnZXhcbiAgICAgICAgICAgIC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcbiAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY3RseVxuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8c2VsZWN0PjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAvLyBJRTggLSBTb21lIGJvb2xlYW4gYXR0cmlidXRlcyBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzpjaGVja2VkfGRpc2FibGVkfGlzbWFwfG11bHRpcGxlfHJlYWRvbmx5fHNlbGVjdGVkfHZhbHVlKVwiICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gT3BlcmEgMTAtMTIvSUU4IC0gXj0gJD0gKj0gYW5kIGVtcHR5IHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3Qgc2VsZWN0IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaT0nJy8+XCI7XG4gICAgICAgICAgICAgICAgaWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltpXj0nJ11cIikubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzpcXFwiXFxcInwnJylcIiApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG4gICAgICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcbiAgICAgICAgICAgICAgICBpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBpc05hdGl2ZSggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgIGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgIGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG4gICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcbiAgICAgICAgICAgICAgICBtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJidWdneVFTQSA9IG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuICAgICAgICByYnVnZ3lNYXRjaGVzID0gbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG4gICAgICAgIC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuICAgICAgICAvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG4gICAgICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG4gICAgICAgIGNvbnRhaW5zID0gaXNOYXRpdmUoZG9jRWxlbS5jb250YWlucykgfHwgZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcbiAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoIGJ1cCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09PSBhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuICAgICAgICBzb3J0T3JkZXIgPSBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID9cbiAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZTtcblxuICAgICAgICAgICAgaWYgKCBhID09PSBiICkge1xuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggKGNvbXBhcmUgPSBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApKSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXBhcmUgJiAxIHx8IGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGRvYyB8fCBjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09PSBkb2MgfHwgY29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPyAtMSA6IDE7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGJ1cCA9IGIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBhcCA9IFsgYSBdLFxuICAgICAgICAgICAgICAgIGJwID0gWyBiIF07XG5cbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcbiAgICAgICAgICAgIGlmICggYSA9PT0gYiApIHtcbiAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgICAgICAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgfSBlbHNlIGlmICggIWF1cCB8fCAhYnVwICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBkb2MgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgIGIgPT09IGRvYyA/IDEgOlxuICAgICAgICAgICAgICAgICAgICBhdXAgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgIGJ1cCA/IDEgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgICAgfSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuICAgICAgICAgICAgY3VyID0gYTtcbiAgICAgICAgICAgIHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KCBjdXIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGI7XG4gICAgICAgICAgICB3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG4gICAgICAgICAgICAgICAgYnAudW5zaGlmdCggY3VyICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG4gICAgICAgICAgICB3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpID9cbiAgICAgICAgICAgICAgICAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICBzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuICAgICAgICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG4gICAgICAgICAgICAgICAgYnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWx3YXlzIGFzc3VtZSB0aGUgcHJlc2VuY2Ugb2YgZHVwbGljYXRlcyBpZiBzb3J0IGRvZXNuJ3RcbiAgICAgICAgLy8gcGFzcyB0aGVtIHRvIG91ciBjb21wYXJpc29uIGZ1bmN0aW9uIChhcyBpbiBHb29nbGUgQ2hyb21lKS5cbiAgICAgICAgaGFzRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgIFswLCAwXS5zb3J0KCBzb3J0T3JkZXIgKTtcbiAgICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gaGFzRHVwbGljYXRlO1xuXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuXG4gICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG4gICAgICAgIHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG4gICAgfTtcblxuICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcbiAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG4gICAgICAgIC8vIHJidWdneVFTQSBhbHdheXMgY29udGFpbnMgOmZvY3VzLCBzbyBubyBuZWVkIGZvciBhbiBleGlzdGVuY2UgY2hlY2tcbiAgICAgICAgaWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiAhZG9jdW1lbnRJc1hNTCAmJiAoIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdChleHByKSkgJiYgIXJidWdneVFTQS50ZXN0KGV4cHIpICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYWdtZW50IGluIElFIDlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFtlbGVtXSApLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbiAgICB9O1xuXG4gICAgU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQoIGVsZW0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIWRvY3VtZW50SXNYTUwgKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICggKHZhbCA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZSBdKSApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwoIGVsZW0gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGRvY3VtZW50SXNYTUwgfHwgc3VwcG9ydC5hdHRyaWJ1dGVzICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICggKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApICkgJiYgZWxlbVsgbmFtZSBdID09PSB0cnVlID9cbiAgICAgICAgICAgIG5hbWUgOlxuICAgICAgICAgICAgdmFsICYmIHZhbC5zcGVjaWZpZWQgPyB2YWwudmFsdWUgOiBudWxsO1xuICAgIH07XG5cbiAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbiAgICB9O1xuXG4gICAgLy8gRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgZHVwbGljYXRlcyA9IFtdLFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG4gICAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG4gICAgICAgIHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cbiAgICAgICAgaWYgKCBoYXNEdXBsaWNhdGUgKSB7XG4gICAgICAgICAgICBmb3IgKCA7IChlbGVtID0gcmVzdWx0c1tpXSk7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgLSAxIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxuICAgICAgICAgICAgZGlmZiA9IGN1ciAmJiAoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC0gKCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuICAgICAgICAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcbiAgICAgICAgaWYgKCBkaWZmICkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuICAgICAgICBpZiAoIGN1ciApIHtcbiAgICAgICAgICAgIHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjdXIgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG4gICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgYXJndW1lbnQgPSArYXJndW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICAgIHZhciBqLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gICAgICovXG4gICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgcmV0ID0gXCJcIixcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICggIW5vZGVUeXBlICkge1xuICAgICAgICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcbiAgICAgICAgICAgIGZvciAoIDsgKG5vZGUgPSBlbGVtW2ldKTsgaSsrICkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQoIG5vZGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuICAgICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoc2VlICMxMTE1MylcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIGNhY2hlTGVuZ3RoOiA1MCxcblxuICAgICAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuICAgICAgICBtYXRjaDogbWF0Y2hFeHByLFxuXG4gICAgICAgIGZpbmQ6IHt9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgXCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuICAgICAgICAgICAgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwcmVGaWx0ZXI6IHtcbiAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcbiAgICAgICAgICAgICAgICBtYXRjaFszXSA9ICggbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG4gICAgICAgICAgICAgICAgICAgIDEgdHlwZSAob25seXxudGh8Li4uKVxuICAgICAgICAgICAgICAgICAgICAyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG4gICAgICAgICAgICAgICAgICAgIDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG4gICAgICAgICAgICAgICAgICAgIDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuICAgICAgICAgICAgICAgICAgICA1IHNpZ24gb2YgeG4tY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIDYgeCBvZiB4bi1jb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgNyBzaWduIG9mIHktY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIDggeSBvZiB5LWNvbXBvbmVudFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaFszXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICAgICAgICAgIHZhciBleGNlc3MsXG4gICAgICAgICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzVdICYmIG1hdGNoWzJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbNF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbNF07XG5cbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuICAgICAgICAgICAgICAgICAgICAoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICAgICAgICAgICAgICAoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyOiB7XG5cbiAgICAgICAgICAgIFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIG5vZGVOYW1lID09PSBcIipcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IG5vZGVOYW1lLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxuICAgICAgICAgICAgICAgICAgICAocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KCBlbGVtLmNsYXNzTmFtZSB8fCAodHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkgfHwgXCJcIiApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZXN1bHQgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW9wZXJhdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdCArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9IDpcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpbXBsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBkaXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gY2FjaGVbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHVzZUNhY2hlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuICAgICAgICAgICAgICAgIC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgICAgIHZhciBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8ganVzdCBhcyBTaXp6bGUgZG9lc1xuICAgICAgICAgICAgICAgIGlmICggZm5bIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCBhcmd1bWVudCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuICAgICAgICAgICAgICAgIGlmICggZm4ubGVuZ3RoID4gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mLmNhbGwoIHNlZWQsIG1hdGNoZWRbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBzZXVkb3M6IHtcbiAgICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICAgICAgXCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG4gICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgXCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgLy8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG4gICAgICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcbiAgICAgICAgICAgIC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG4gICAgICAgICAgICAvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgICAgICAgIC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cbiAgICAgICAgICAgIFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuICAgICAgICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZGVyXG4gICAgICAgICAgICAgICAgaWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtTGFuZztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzWE1MID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5sYW5nKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAvLyBNaXNjZWxsYW5lb3VzXG4gICAgICAgICAgICBcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXNcbiAgICAgICAgICAgIFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgIFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgb25seSBhZmZlY3RlZCBieSBlbGVtZW50IG5vZGVzIGFuZCBjb250ZW50IG5vZGVzKGluY2x1ZGluZyB0ZXh0KDMpLCBjZGF0YSg0KSksXG4gICAgICAgICAgICAgICAgLy8gICBub3QgY29tbWVudCwgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnMsIG9yIG90aGVyc1xuICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBEaWVnbyBQZXJpbmkgZm9yIHRoZSBub2RlTmFtZSBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIC8vICAgR3JlYXRlciB0aGFuIFwiQFwiIG1lYW5zIGFscGhhIGNoYXJhY3RlcnMgKHNwZWNpZmljYWxseSBub3Qgc3RhcnRpbmcgd2l0aCBcIiNcIiBvciBcIj9cIilcbiAgICAgICAgICAgICAgICBmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVOYW1lID4gXCJAXCIgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRWxlbWVudC9pbnB1dCB0eXBlc1xuICAgICAgICAgICAgXCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyO1xuICAgICAgICAgICAgICAgIC8vIElFNiBhbmQgNyB3aWxsIG1hcCBlbGVtLnR5cGUgdG8gJ3RleHQnIGZvciBuZXcgSFRNTDUgdHlwZXMgKHNlYXJjaCwgZXRjKVxuICAgICAgICAgICAgICAgIC8vIHVzZSBnZXRBdHRyaWJ1dGUgaW5zdGVhZCB0byB0ZXN0IHRoaXMgY2FzZVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG4gICAgICAgICAgICAgICAgICAgICggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBlbGVtLnR5cGUgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cbiAgICAgICAgICAgIFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyAwIF07XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgXCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIGxlbmd0aCAtIDEgXTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgXCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgXCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgICAgIGZvciAoIDsgLS1pID49IDA7ICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG4gICAgZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG4gICAgICAgIEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbiAgICB9XG4gICAgZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcbiAgICAgICAgRXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbml6ZSggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcbiAgICAgICAgdmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG4gICAgICAgICAgICBzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuICAgICAgICAgICAgY2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG4gICAgICAgIGlmICggY2FjaGVkICkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgICBwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cbiAgICAgICAgd2hpbGUgKCBzb0ZhciApIHtcblxuICAgICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgICAgICAgaWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCB0b2tlbnMgPSBbXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENvbWJpbmF0b3JzXG4gICAgICAgICAgICBpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCgge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbHRlcnNcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICFtYXRjaGVkICkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG4gICAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcbiAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/XG4gICAgICAgICAgICBzb0Zhci5sZW5ndGggOlxuICAgICAgICAgICAgc29GYXIgP1xuICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHRva2Vuc1xuICAgICAgICAgICAgICAgIHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG4gICAgICAgIHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcbiAgICAgICAgICAgIGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG4gICAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcblxuICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG4gICAgICAgICAgICAvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDpcblxuICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhLCBjYWNoZSwgb3V0ZXJDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgZGlya2V5ID0gZGlycnVucyArIFwiIFwiICsgZG9uZU5hbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBkaXIgY2FjaGluZ1xuICAgICAgICAgICAgICAgIGlmICggeG1sICkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChjYWNoZSA9IG91dGVyQ2FjaGVbIGRpciBdKSAmJiBjYWNoZVswXSA9PT0gZGlya2V5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChkYXRhID0gY2FjaGVbMV0pID09PSB0cnVlIHx8IGRhdGEgPT09IGNhY2hlZHJ1bnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0gPSBbIGRpcmtleSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVsxXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApIHx8IGNhY2hlZHJ1bnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FjaGVbMV0gPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIG1hdGNoZXJzWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG4gICAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuICAgICAgICAgICAgICAgIGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hcHBlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcbiAgICAgICAgaWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG4gICAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgIHZhciB0ZW1wLCBpLCBlbGVtLFxuICAgICAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcbiAgICAgICAgICAgICAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcbiAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cbiAgICAgICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cbiAgICAgICAgICAgICAgICAgICAgY29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuICAgICAgICAgICAgICAgICAgICBlbGVtcyxcblxuICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzIDpcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckluO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuICAgICAgICAgICAgaWYgKCBtYXRjaGVyICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHBvc3RGaWx0ZXJcbiAgICAgICAgICAgIGlmICggcG9zdEZpbHRlciApIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcbiAgICAgICAgICAgICAgICBwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cbiAgICAgICAgICAgICAgICAvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG4gICAgICAgICAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbmRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcbiAgICAgICAgdmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcbiAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICBsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcbiAgICAgICAgICAgIGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuICAgICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcbiAgICAgICAgICAgIG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG4gICAgICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG4gICAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuICAgICAgICAgICAgbWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG4gICAgICAgICAgICAgICAgICAgIChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcbiAgICAgICAgICAgIH0gXTtcblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGogPSArK2k7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID4gMSAmJiB0b1NlbGVjdG9yKCB0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkgKS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG4gICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG4gICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG4gICAgICAgIC8vIEEgY291bnRlciB0byBzcGVjaWZ5IHdoaWNoIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIG1hdGNoZWRcbiAgICAgICAgdmFyIG1hdGNoZXJDYWNoZWRSdW5zID0gMCxcbiAgICAgICAgICAgIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgc3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgZXhwYW5kQ29udGV4dCApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaiwgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICBpID0gXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgICAgICAgICAgIG91dGVybW9zdCA9IGV4cGFuZENvbnRleHQgIT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3IgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIGV4cGFuZENvbnRleHQgJiYgY29udGV4dC5wYXJlbnROb2RlIHx8IGNvbnRleHQgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcbiAgICAgICAgICAgICAgICAgICAgZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgIT09IGRvY3VtZW50ICYmIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZHJ1bnMgPSBtYXRjaGVyQ2FjaGVkUnVucztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuICAgICAgICAgICAgICAgIGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRydW5zID0gKyttYXRjaGVyQ2FjaGVkUnVucztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBieVNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTtcbiAgICAgICAgICAgICAgICBpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcbiAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB1bm1hdGNoZWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBieVNldCA/XG4gICAgICAgICAgICBtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcbiAgICAgICAgICAgIHN1cGVyTWF0Y2hlcjtcbiAgICB9XG5cbiAgICBjb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGdyb3VwIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHNldE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuICAgICAgICBpZiAoICFjYWNoZWQgKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICggIWdyb3VwICkge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gZ3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIGdyb3VwW2ldICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG4gICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG4gICAgICAgIHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuICAgICAgICBpZiAoICFzZWVkICkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgZ3JvdXBcbiAgICAgICAgICAgIGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG4gICAgICAgICAgICAgICAgaWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiAhZG9jdW1lbnRJc1hNTCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgaSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChzZWVkID0gZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiBjb250ZXh0LnBhcmVudE5vZGUgfHwgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbCggc2VlZCwgMCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvblxuICAgICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG4gICAgICAgIGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApKFxuICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBkb2N1bWVudElzWE1MLFxuICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgIHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLy8gRGVwcmVjYXRlZFxuICAgIEV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4gICAgLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG4gICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG4gICAgRXhwci5maWx0ZXJzID0gc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLnBzZXVkb3M7XG4gICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuICAgIHNldERvY3VtZW50KCk7XG5cbiAgICAvLyBPdmVycmlkZSBzaXp6bGUgYXR0cmlidXRlIHJldHJpZXZhbFxuICAgIFNpenpsZS5hdHRyID0galF1ZXJ5LmF0dHI7XG4gICAgalF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG4gICAgalF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuICAgIGpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG4gICAgalF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xuICAgIGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG4gICAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuICAgIGpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG4gICAgfSkoIHdpbmRvdyApO1xuICAgIHZhciBydW50aWwgPSAvVW50aWwkLyxcbiAgICAgICAgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG4gICAgICAgIGlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvLFxuICAgICAgICBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LFxuICAgICAgICAvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuICAgICAgICBndWFyYW50ZWVkVW5pcXVlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgICBjb250ZW50czogdHJ1ZSxcbiAgICAgICAgICAgIG5leHQ6IHRydWUsXG4gICAgICAgICAgICBwcmV2OiB0cnVlXG4gICAgICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGksIHJldCwgc2VsZixcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWxlY3RvciwgdGhpc1sgaSBdLCByZXQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXG4gICAgICAgICAgICByZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG4gICAgICAgICAgICByZXQuc2VsZWN0b3IgPSAoIHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgOiBcIlwiICkgKyBzZWxlY3RvcjtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG4gICAgICAgICAgICAgICAgbGVuID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yLCBmYWxzZSkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yLCB0cnVlKSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gISFzZWxlY3RvciAmJiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG4gICAgICAgICAgICAgICAgICAgIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbGVjdG9yLCB0aGlzLmNvbnRleHQgKS5pbmRleCggdGhpc1swXSApID49IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKS5sZW5ndGggPiAwIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID4gMCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICB2YXIgY3VyLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG4gICAgICAgICAgICAgICAgICAgIDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBjdXIgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBjdXIgJiYgY3VyLm93bmVyRG9jdW1lbnQgJiYgY3VyICE9PSBjb250ZXh0ICYmIGN1ci5ub2RlVHlwZSAhPT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6IGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0Lmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cbiAgICAgICAgLy8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgICAgLy8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcbiAgICAgICAgICAgIGlmICggIWVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluZGV4IGluIHNlbGVjdG9yXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuaW5BcnJheSggdGhpc1swXSwgalF1ZXJ5KCBlbGVtICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmluQXJyYXkoXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbSwgdGhpcyApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgdmFyIHNldCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yICYmIHNlbGVjdG9yLm5vZGVUeXBlID8gWyBzZWxlY3RvciBdIDogc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICBhbGwgPSBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIHNldCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS51bmlxdWUoYWxsKSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cbiAgICBmdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VyID0gY3VyWyBkaXIgXTtcbiAgICAgICAgfSB3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDEgKTtcblxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgP1xuICAgICAgICAgICAgICAgIGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuICAgICAgICAgICAgaWYgKCAhcnVudGlsLnRlc3QoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICByZXQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgcmV0ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IHRoaXMubGVuZ3RoID4gMSAmJiAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQ7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5sZW5ndGggPiAxICYmIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuICAgICAgICAgICAgaWYgKCBub3QgKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGVsZW1zWzBdLCBleHByKSA/IFsgZWxlbXNbMF0gXSA6IFtdIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGVsZW1zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBjdXIgPSBlbGVtWyBkaXIgXTtcblxuICAgICAgICAgICAgd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KCBjdXIgKS5pcyggdW50aWwgKSkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjdXIubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ciA9IGN1cltkaXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2libGluZzogZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG4gICAgICAgICAgICB2YXIgciA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuICAgICAgICAgICAgICAgIGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2goIG4gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuICAgIGZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwga2VlcCApIHtcblxuICAgICAgICAvLyBDYW4ndCBwYXNzIG51bGwgb3IgdW5kZWZpbmVkIHRvIGluZGV4T2YgaW4gRmlyZWZveCA0XG4gICAgICAgIC8vIFNldCB0byAwIHRvIHNraXAgc3RyaW5nIGNoZWNrXG4gICAgICAgIHF1YWxpZmllciA9IHF1YWxpZmllciB8fCAwO1xuXG4gICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRWYWwgPT09IGtlZXA7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApID09PSBrZWVwO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIGlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZmlsdGVyZWQsICFrZWVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBmaWx0ZXJlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiAoIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBxdWFsaWZpZXIgKSA+PSAwICkgPT09IGtlZXA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICkge1xuICAgICAgICB2YXIgbGlzdCA9IG5vZGVOYW1lcy5zcGxpdCggXCJ8XCIgKSxcbiAgICAgICAgICAgIHNhZmVGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgIGlmICggc2FmZUZyYWcuY3JlYXRlRWxlbWVudCApIHtcbiAgICAgICAgICAgIHdoaWxlICggbGlzdC5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgc2FmZUZyYWcuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wb3AoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhZmVGcmFnO1xuICAgIH1cblxuICAgIHZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xuICAgICAgICAgICAgXCJoZWFkZXJ8aGdyb3VwfG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwcm9ncmVzc3xzZWN0aW9ufHN1bW1hcnl8dGltZXx2aWRlb1wiLFxuICAgICAgICByaW5saW5lalF1ZXJ5ID0gLyBqUXVlcnlcXGQrPVwiKD86bnVsbHxcXGQrKVwiL2csXG4gICAgICAgIHJub3NoaW1jYWNoZSA9IG5ldyBSZWdFeHAoXCI8KD86XCIgKyBub2RlTmFtZXMgKyBcIilbXFxcXHMvPl1cIiwgXCJpXCIpLFxuICAgICAgICBybGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuICAgICAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksXG4gICAgICAgIHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuICAgICAgICBydGJvZHkgPSAvPHRib2R5L2ksXG4gICAgICAgIHJodG1sID0gLzx8JiM/XFx3KzsvLFxuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuICAgICAgICBtYW5pcHVsYXRpb25fcmNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSxcbiAgICAgICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG4gICAgICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcbiAgICAgICAgcnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuICAgICAgICByc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbiAgICAgICAgd3JhcE1hcCA9IHtcbiAgICAgICAgICAgIG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuICAgICAgICAgICAgbGVnZW5kOiBbIDEsIFwiPGZpZWxkc2V0PlwiLCBcIjwvZmllbGRzZXQ+XCIgXSxcbiAgICAgICAgICAgIGFyZWE6IFsgMSwgXCI8bWFwPlwiLCBcIjwvbWFwPlwiIF0sXG4gICAgICAgICAgICBwYXJhbTogWyAxLCBcIjxvYmplY3Q+XCIsIFwiPC9vYmplY3Q+XCIgXSxcbiAgICAgICAgICAgIHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcbiAgICAgICAgICAgIHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcbiAgICAgICAgICAgIGNvbDogWyAyLCBcIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG4gICAgICAgICAgICB0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cbiAgICAgICAgICAgIC8vIElFNi04IGNhbid0IHNlcmlhbGl6ZSBsaW5rLCBzY3JpcHQsIHN0eWxlLCBvciBhbnkgaHRtbDUgKE5vU2NvcGUpIHRhZ3MsXG4gICAgICAgICAgICAvLyB1bmxlc3Mgd3JhcHBlZCBpbiBhIGRpdiB3aXRoIG5vbi1icmVha2luZyBjaGFyYWN0ZXJzIGluIGZyb250IG9mIGl0LlxuICAgICAgICAgICAgX2RlZmF1bHQ6IGpRdWVyeS5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgPyBbIDAsIFwiXCIsIFwiXCIgXSA6IFsgMSwgXCJYPGRpdj5cIiwgXCI8L2Rpdj5cIiAgXVxuICAgICAgICB9LFxuICAgICAgICBzYWZlRnJhZ21lbnQgPSBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICksXG4gICAgICAgIGZyYWdtZW50RGl2ID0gc2FmZUZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG5cbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG4gICAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbiAgICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICB0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnRleHQoIHRoaXMgKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQoICggdGhpc1swXSAmJiB0aGlzWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKS5jcmVhdGVUZXh0Tm9kZSggdmFsdWUgKSApO1xuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXNbMF0gKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcbiAgICAgICAgICAgICAgICB2YXIgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50ICkuZXEoMCkuY2xvbmUodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaXNbMF0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbMF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggZWxlbS5maXJzdENoaWxkICYmIGVsZW0uZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmQoIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoIGh0bWwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVud3JhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmVuZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGtlZXBEYXRhIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS0tZG8gbm90IGRvY3VtZW50XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCA7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggIXNlbGVjdG9yIHx8IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBbIGVsZW0gXSApLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0gKSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgZm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBzZWxlY3QsIGVuc3VyZSB0aGF0IGl0IGRpc3BsYXlzIGVtcHR5ICgjMTIzMzYpXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5vcHRpb25zICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLm9wdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuICAgICAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MLnJlcGxhY2UoIHJpbmxpbmVqUXVlcnksIFwiXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIGpRdWVyeS5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCB2YWx1ZSApICApICYmXG4gICAgICAgICAgICAgICAgICAgICggalF1ZXJ5LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgIXJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCB2YWx1ZSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbXCJcIiwgXCJcIl0gKVsxXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbaV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmMgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhlIERPTSBiZWZvcmUgdGhleSBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGhlbHAgZml4IHJlcGxhY2luZyBhIHBhcmVudCB3aXRoIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoICFpc0Z1bmMgJiYgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KCB2YWx1ZSApLm5vdCggdGhpcyApLmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcCggWyB2YWx1ZSBdLCB0cnVlLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSggZWxlbSwgbmV4dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgdGFibGUsIGNhbGxiYWNrICkge1xuXG4gICAgICAgICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgICAgICBhcmdzID0gY29yZV9jb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cbiAgICAgICAgICAgIHZhciBmaXJzdCwgbm9kZSwgaGFzU2NyaXB0cyxcbiAgICAgICAgICAgICAgICBzY3JpcHRzLCBkb2MsIGZyYWdtZW50LFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24gfHwgISggbCA8PSAxIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCBqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lIHx8ICFyY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gc2V0LmVxKCBpbmRleCApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHRhYmxlID8gc2VsZi5odG1sKCkgOiB1bmRlZmluZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbU1hbmlwKCBhcmdzLCB0YWJsZSwgY2FsbGJhY2sgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBsICkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJzdCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSB0YWJsZSAmJiBqUXVlcnkubm9kZU5hbWUoIGZpcnN0LCBcInRyXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuICAgICAgICAgICAgICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGZyYWdtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc1NjcmlwdHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzW2ldLCBcInRhYmxlXCIgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRPckFwcGVuZCggdGhpc1tpXSwgXCJ0Ym9keVwiICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzU2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZW5hYmxlIHNjcmlwdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWpRdWVyeS5fZGF0YSggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZS5zcmMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3BlIGFqYXggaXMgYXZhaWxhYmxlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBub2RlLnNyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGhyb3dzXCI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwoICggbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lckhUTUwgfHwgXCJcIiApLnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaXggIzExODA5OiBBdm9pZCBsZWFraW5nIG1lbW9yeVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kT3JBcHBlbmQoIGVsZW0sIHRhZyApIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApWzBdIHx8IGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0YWcgKSApO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbiAgICBmdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuICAgICAgICB2YXIgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcInR5cGVcIik7XG4gICAgICAgIGVsZW0udHlwZSA9ICggYXR0ciAmJiBhdHRyLnNwZWNpZmllZCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuICAgICAgICB2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcbiAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgIGVsZW0udHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcbiAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgZm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgalF1ZXJ5Ll9kYXRhKCByZWZFbGVtZW50c1tpXSwgXCJnbG9iYWxFdmFsXCIgKSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblxuICAgICAgICBpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgfHwgIWpRdWVyeS5oYXNEYXRhKCBzcmMgKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0eXBlLCBpLCBsLFxuICAgICAgICAgICAgb2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG4gICAgICAgICAgICBjdXJEYXRhID0galF1ZXJ5Ll9kYXRhKCBkZXN0LCBvbGREYXRhICksXG4gICAgICAgICAgICBldmVudHMgPSBvbGREYXRhLmV2ZW50cztcblxuICAgICAgICBpZiAoIGV2ZW50cyApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcbiAgICAgICAgICAgIGN1ckRhdGEuZXZlbnRzID0ge307XG5cbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSB0aGUgY2xvbmVkIHB1YmxpYyBkYXRhIG9iamVjdCBhIGNvcHkgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgaWYgKCBjdXJEYXRhLmRhdGEgKSB7XG4gICAgICAgICAgICBjdXJEYXRhLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyRGF0YS5kYXRhICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhDbG9uZU5vZGVJc3N1ZXMoIHNyYywgZGVzdCApIHtcbiAgICAgICAgdmFyIG5vZGVOYW1lLCBlLCBkYXRhO1xuXG4gICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHNcbiAgICAgICAgaWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gSUU2LTggY29waWVzIGV2ZW50cyBib3VuZCB2aWEgYXR0YWNoRXZlbnQgd2hlbiB1c2luZyBjbG9uZU5vZGUuXG4gICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiBkZXN0WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCApO1xuXG4gICAgICAgICAgICBmb3IgKCBlIGluIGRhdGEuZXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZGVzdCwgZSwgZGF0YS5oYW5kbGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG8gZ2V0cyBjb3BpZWQgdG9vXG4gICAgICAgICAgICBkZXN0LnJlbW92ZUF0dHJpYnV0ZSggalF1ZXJ5LmV4cGFuZG8gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGJsYW5rcyBjb250ZW50cyB3aGVuIGNsb25pbmcgc2NyaXB0cywgYW5kIHRyaWVzIHRvIGV2YWx1YXRlIG5ld2x5LXNldCB0ZXh0XG4gICAgICAgIGlmICggbm9kZU5hbWUgPT09IFwic2NyaXB0XCIgJiYgZGVzdC50ZXh0ICE9PSBzcmMudGV4dCApIHtcbiAgICAgICAgICAgIGRpc2FibGVTY3JpcHQoIGRlc3QgKS50ZXh0ID0gc3JjLnRleHQ7XG4gICAgICAgICAgICByZXN0b3JlU2NyaXB0KCBkZXN0ICk7XG5cbiAgICAgICAgLy8gSUU2LTEwIGltcHJvcGVybHkgY2xvbmVzIGNoaWxkcmVuIG9mIG9iamVjdCBlbGVtZW50cyB1c2luZyBjbGFzc2lkLlxuICAgICAgICAvLyBJRTEwIHRocm93cyBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciBpZiBwYXJlbnQgaXMgbnVsbCwgIzEyMTMyLlxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgIGlmICggZGVzdC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgIGRlc3Qub3V0ZXJIVE1MID0gc3JjLm91dGVySFRNTDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBwYXRoIGFwcGVhcnMgdW5hdm9pZGFibGUgZm9yIElFOS4gV2hlbiBjbG9uaW5nIGFuIG9iamVjdFxuICAgICAgICAgICAgLy8gZWxlbWVudCBpbiBJRTksIHRoZSBvdXRlckhUTUwgc3RyYXRlZ3kgYWJvdmUgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3JjIGhhcyBpbm5lckhUTUwgYW5kIHRoZSBkZXN0aW5hdGlvbiBkb2VzIG5vdCxcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIHNyYy5pbm5lckhUTUwgaW50byB0aGUgZGVzdC5pbm5lckhUTUwuICMxMDMyNFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lICYmICggc3JjLmlubmVySFRNTCAmJiAhalF1ZXJ5LnRyaW0oZGVzdC5pbm5lckhUTUwpICkgKSB7XG4gICAgICAgICAgICAgICAgZGVzdC5pbm5lckhUTUwgPSBzcmMuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgbWFuaXB1bGF0aW9uX3JjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG4gICAgICAgICAgICAvLyBJRTYtOCBmYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94XG4gICAgICAgICAgICAvLyBvciByYWRpbyBidXR0b24uIFdvcnNlLCBJRTYtNyBmYWlsIHRvIGdpdmUgdGhlIGNsb25lZCBlbGVtZW50XG4gICAgICAgICAgICAvLyBhIGNoZWNrZWQgYXBwZWFyYW5jZSBpZiB0aGUgZGVmYXVsdENoZWNrZWQgdmFsdWUgaXNuJ3QgYWxzbyBzZXRcblxuICAgICAgICAgICAgZGVzdC5kZWZhdWx0Q2hlY2tlZCA9IGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG4gICAgICAgICAgICAvLyBJRTYtNyBnZXQgY29uZnVzZWQgYW5kIGVuZCB1cCBzZXR0aW5nIHRoZSB2YWx1ZSBvZiBhIGNsb25lZFxuICAgICAgICAgICAgLy8gY2hlY2tib3gvcmFkaW8gYnV0dG9uIHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIFwib25cIlxuICAgICAgICAgICAgaWYgKCBkZXN0LnZhbHVlICE9PSBzcmMudmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgZGVzdC52YWx1ZSA9IHNyYy52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAvLyBJRTYtOCBmYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZFxuICAgICAgICAvLyBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiApIHtcbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdFNlbGVjdGVkID0gZGVzdC5zZWxlY3RlZCA9IHNyYy5kZWZhdWx0U2VsZWN0ZWQ7XG5cbiAgICAgICAgLy8gSUU2LTggZmFpbHMgdG8gc2V0IHRoZSBkZWZhdWx0VmFsdWUgdG8gdGhlIGNvcnJlY3QgdmFsdWUgd2hlblxuICAgICAgICAvLyBjbG9uaW5nIG90aGVyIHR5cGVzIG9mIGlucHV0IGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG4gICAgICAgICAgICBkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuICAgICAgICBwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuICAgICAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG4gICAgICAgIGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG4gICAgICAgIHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxuICAgIH0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgZWxlbXMsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuICAgICAgICAgICAgICAgIGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgZm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIGluc2VydFtpXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gTW9kZXJuIGJyb3dzZXJzIGNhbiBhcHBseSBqUXVlcnkgY29sbGVjdGlvbnMgYXMgYXJyYXlzLCBidXQgb2xkSUUgbmVlZHMgYSAuZ2V0KClcbiAgICAgICAgICAgICAgICBjb3JlX3B1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuICAgICAgICB2YXIgZWxlbXMsIGVsZW0sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGZvdW5kID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IGNvcmVfc3RydW5kZWZpbmVkID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IGNvcmVfc3RydW5kZWZpbmVkID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICggIWZvdW5kICkge1xuICAgICAgICAgICAgZm9yICggZm91bmQgPSBbXSwgZWxlbXMgPSBjb250ZXh0LmNoaWxkTm9kZXMgfHwgY29udGV4dDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggIXRhZyB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIHRhZyApICkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBmb3VuZCwgZ2V0QWxsKCBlbGVtLCB0YWcgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG4gICAgICAgICAgICBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCBmb3VuZCApIDpcbiAgICAgICAgICAgIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIFVzZWQgaW4gYnVpbGRGcmFnbWVudCwgZml4ZXMgdGhlIGRlZmF1bHRDaGVja2VkIHByb3BlcnR5XG4gICAgZnVuY3Rpb24gZml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKSB7XG4gICAgICAgIGlmICggbWFuaXB1bGF0aW9uX3JjaGVja2FibGVUeXBlLnRlc3QoIGVsZW0udHlwZSApICkge1xuICAgICAgICAgICAgZWxlbS5kZWZhdWx0Q2hlY2tlZCA9IGVsZW0uY2hlY2tlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgICAgdmFyIGRlc3RFbGVtZW50cywgbm9kZSwgY2xvbmUsIGksIHNyY0VsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cbiAgICAgICAgICAgIGlmICggalF1ZXJ5LnN1cHBvcnQuaHRtbDVDbG9uZSB8fCBqUXVlcnkuaXNYTUxEb2MoZWxlbSkgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCBcIjxcIiArIGVsZW0ubm9kZU5hbWUgKyBcIj5cIiApICkge1xuICAgICAgICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKTtcblxuICAgICAgICAgICAgLy8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2Rlc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudERpdi5pbm5lckhUTUwgPSBlbGVtLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICBmcmFnbWVudERpdi5yZW1vdmVDaGlsZCggY2xvbmUgPSBmcmFnbWVudERpdi5maXJzdENoaWxkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggKCFqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXggYWxsIElFIGNsb25pbmcgaXNzdWVzXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGRlc3RpbmF0aW9uIG5vZGUgaXMgbm90IG51bGw7IEZpeGVzICM5NTg3XG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVzdEVsZW1lbnRzW2ldICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZml4Q2xvbmVOb2RlSXNzdWVzKCBub2RlLCBkZXN0RWxlbWVudHNbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuICAgICAgICAgICAgaWYgKCBkYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBub2RlLCBkZXN0RWxlbWVudHNbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuICAgICAgICAgICAgaWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gc3JjRWxlbWVudHMgPSBub2RlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRGcmFnbWVudDogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24gKSB7XG4gICAgICAgICAgICB2YXIgaiwgZWxlbSwgY29udGFpbnMsXG4gICAgICAgICAgICAgICAgdG1wLCB0YWcsIHRib2R5LCB3cmFwLFxuICAgICAgICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGgsXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYSBzYWZlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgc2FmZSA9IGNyZWF0ZVNhZmVGcmFnbWVudCggY29udGV4dCApLFxuXG4gICAgICAgICAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wIHx8IHNhZmUuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbXCJcIiwgXCJcIl0gKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IHdyYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBhZGQgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgYnkgSUVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggcmxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMoIGVsZW0gKVswXSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJRSdzIGF1dG9pbnNlcnRlZCA8dGJvZHk+IGZyb20gdGFibGUgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC50Ym9keSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGFnID09PSBcInRhYmxlXCIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAuZmlyc3RDaGlsZCA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBbMV0gPT09IFwiPHRhYmxlPlwiICYmICFydGJvZHkudGVzdCggZWxlbSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGVsZW0gJiYgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoICh0Ym9keSA9IGVsZW0uY2hpbGROb2Rlc1tqXSksIFwidGJvZHlcIiApICYmICF0Ym9keS5jaGlsZE5vZGVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2hpbGQoIHRib2R5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCAjMTIzOTIgZm9yIFdlYktpdCBhbmQgSUUgPiA5XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggIzEyMzkyIGZvciBvbGRJRVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCB0bXAuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucmVtb3ZlQ2hpbGQoIHRtcC5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciBwcm9wZXIgY2xlYW51cFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gc2FmZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeCAjMTEzNTY6IENsZWFyIGVsZW1lbnRzIGZyb20gZnJhZ21lbnRcbiAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgIHNhZmUucmVtb3ZlQ2hpbGQoIHRtcCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCBkZWZhdWx0Q2hlY2tlZCBmb3IgYW55IHJhZGlvcyBhbmQgY2hlY2tib3hlc1xuICAgICAgICAgICAgLy8gYWJvdXQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIERPTSBpbiBJRSA2LzcgKCM4MDYwKVxuICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuYXBwZW5kQ2hlY2tlZCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZ3JlcCggZ2V0QWxsKCBub2RlcywgXCJpbnB1dFwiICksIGZpeERlZmF1bHRDaGVja2VkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IG5vZGVzWyBpKysgXSkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRvIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgdG1wID0gZ2V0QWxsKCBzYWZlLmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRhaW5zICkge1xuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKCB0bXAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG4gICAgICAgICAgICAgICAgaWYgKCBzY3JpcHRzICkge1xuICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IHRtcFsgaisrIF0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bXAgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gc2FmZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcywgLyogaW50ZXJuYWwgKi8gYWNjZXB0RGF0YSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtLCB0eXBlLCBpZCwgZGF0YSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuICAgICAgICAgICAgICAgIGNhY2hlID0galF1ZXJ5LmNhY2hlLFxuICAgICAgICAgICAgICAgIGRlbGV0ZUV4cGFuZG8gPSBqUXVlcnkuc3VwcG9ydC5kZWxldGVFeHBhbmRvLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbDtcblxuICAgICAgICAgICAgZm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFjY2VwdERhdGEgfHwgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZCA9IGVsZW1bIGludGVybmFsS2V5IF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBpZCAmJiBjYWNoZVsgaWQgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEuZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlIG9ubHkgaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHJlbW92ZWQgYnkgalF1ZXJ5LmV2ZW50LnJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWNoZVsgaWQgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3IgZG9lcyBpdCBoYXZlIGEgcmVtb3ZlQXR0cmlidXRlIGZ1bmN0aW9uIG9uIERvY3VtZW50IG5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgaGFuZGxlIGFsbCBvZiB0aGVzZSBjYXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGVsZXRlRXhwYW5kbyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1bIGludGVybmFsS2V5IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgZWxlbS5yZW1vdmVBdHRyaWJ1dGUgIT09IGNvcmVfc3RydW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSggaW50ZXJuYWxLZXkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIGludGVybmFsS2V5IF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfZGVsZXRlZElkcy5wdXNoKCBpZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGlmcmFtZSwgZ2V0U3R5bGVzLCBjdXJDU1MsXG4gICAgICAgIHJhbHBoYSA9IC9hbHBoYVxcKFteKV0qXFwpL2ksXG4gICAgICAgIHJvcGFjaXR5ID0gL29wYWNpdHlcXHMqPVxccyooW14pXSopLyxcbiAgICAgICAgcnBvc2l0aW9uID0gL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvLFxuICAgICAgICAvLyBzd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuICAgICAgICAvLyBzZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcbiAgICAgICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuICAgICAgICBybWFyZ2luID0gL15tYXJnaW4vLFxuICAgICAgICBybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjb3JlX3BudW0gKyBcIikoLiopJFwiLCBcImlcIiApLFxuICAgICAgICBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjb3JlX3BudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApLFxuICAgICAgICBycmVsTnVtID0gbmV3IFJlZ0V4cCggXCJeKFsrLV0pPShcIiArIGNvcmVfcG51bSArIFwiKVwiLCBcImlcIiApLFxuICAgICAgICBlbGVtZGlzcGxheSA9IHsgQk9EWTogXCJibG9ja1wiIH0sXG5cbiAgICAgICAgY3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG4gICAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IDAsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiA0MDBcbiAgICAgICAgfSxcblxuICAgICAgICBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXSxcbiAgICAgICAgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcblxuICAgIC8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG5hbWUgKSB7XG5cbiAgICAgICAgLy8gc2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcbiAgICAgICAgaWYgKCBuYW1lIGluIHN0eWxlICkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG4gICAgICAgIHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgICBvcmlnTmFtZSA9IG5hbWUsXG4gICAgICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgbmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuICAgICAgICAgICAgaWYgKCBuYW1lIGluIHN0eWxlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWdOYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSGlkZGVuKCBlbGVtLCBlbCApIHtcbiAgICAgICAgLy8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICAgIGVsZW0gPSBlbCB8fCBlbGVtO1xuICAgICAgICByZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHwgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuICAgICAgICB2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuICAgICAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcbiAgICAgICAgICAgIGlmICggIWVsZW0uc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcbiAgICAgICAgICAgIGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAoIHNob3cgKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuICAgICAgICAgICAgICAgIC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3RcbiAgICAgICAgICAgICAgICBpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuICAgICAgICAgICAgICAgIC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG4gICAgICAgICAgICAgICAgLy8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGNzc19kZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXNwbGF5ICYmIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3BcbiAgICAgICAgLy8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuICAgICAgICBmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuICAgICAgICAgICAgaWYgKCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuLCBzdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgIG1hcCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IG5hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgIH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9LFxuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcbiAgICAgICAgICAgIHZhciBib29sID0gdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGJvb2wgPyBzdGF0ZSA6IGlzSGlkZGVuKCB0aGlzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG4gICAgICAgIGNzc0hvb2tzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFeGNsdWRlIHRoZSBmb2xsb3dpbmcgY3NzIHByb3BlcnRpZXMgdG8gYWRkIHB4XG4gICAgICAgIGNzc051bWJlcjoge1xuICAgICAgICAgICAgXCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IHRydWUsXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXG4gICAgICAgICAgICBcIndpZG93c1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgICAgICAvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG4gICAgICAgIGNzc1Byb3BzOiB7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgZmxvYXQgY3NzIHByb3BlcnR5XG4gICAgICAgICAgICBcImZsb2F0XCI6IGpRdWVyeS5zdXBwb3J0LmNzc0Zsb2F0ID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCJcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuICAgICAgICBzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcbiAgICAgICAgICAgIC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcbiAgICAgICAgICAgIHZhciByZXQsIHR5cGUsIGhvb2tzLFxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBzdHlsZSwgb3JpZ05hbWUgKSApO1xuXG4gICAgICAgICAgICAvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcnJlbE51bS5leGVjKCB2YWx1ZSApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoIHJldFsxXSArIDEgKSAqIHJldFsyXSArIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKSApO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyBidWcgIzkyMzdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgTmFOIGFuZCBudWxsIHZhbHVlcyBhcmVuJ3Qgc2V0LiBTZWU6ICM3MTE2XG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PSBudWxsIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaXhlcyAjODkwOCwgaXQgY2FuIGJlIGRvbmUgbW9yZSBjb3JyZWN0bHkgYnkgc3BlY2lmaW5nIHNldHRlcnMgaW4gY3NzSG9va3MsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IHdvdWxkIG1lYW4gdG8gZGVmaW5lIGVpZ2h0IChmb3IgZXZlcnkgcHJvYmxlbWF0aWMgcHJvcGVydHkpIGlkZW50aWNhbCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgd2hlbiAnaW52YWxpZCcgdmFsdWVzIGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyBidWcgIzU1MDlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3RcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuICAgICAgICAgICAgdmFyIG51bSwgdmFsLCBob29rcyxcbiAgICAgICAgICAgICAgICBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuICAgICAgICAgICAgLy8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuICAgICAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cbiAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuICAgICAgICAgICAgaWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2NvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuICAgICAgICAgICAgaWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcbiAgICAgICAgICAgIGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnNcbiAgICAgICAgc3dhcDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuICAgICAgICAgICAgdmFyIHJldCwgbmFtZSxcbiAgICAgICAgICAgICAgICBvbGQgPSB7fTtcblxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgb2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG4gICAgICAgICAgICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTk9URTogd2UndmUgaW5jbHVkZWQgdGhlIFwid2luZG93XCIgaW4gd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgICAvLyBiZWNhdXNlIGpzZG9tIG9uIG5vZGUuanMgd2lsbCBicmVhayB3aXRob3V0IGl0LlxuICAgIGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG4gICAgICAgIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY3VyQ1NTID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIF9jb21wdXRlZCApIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gX2NvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApLFxuXG4gICAgICAgICAgICAgICAgLy8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgaW4gSUU5LCBzZWUgIzEyNTM3XG4gICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cbiAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuICAgICAgICAgICAgICAgIC8vIENocm9tZSA8IDE3IGFuZCBTYWZhcmkgNS4wIHVzZXMgXCJjb21wdXRlZCB2YWx1ZVwiIGluc3RlYWQgb2YgXCJ1c2VkIHZhbHVlXCIgZm9yIG1hcmdpbi1yaWdodFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA1LjEuNyAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuICAgICAgICAgICAgICAgIGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICkge1xuICAgICAgICBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjdXJDU1MgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgX2NvbXB1dGVkICkge1xuICAgICAgICAgICAgdmFyIGxlZnQsIHJzLCByc0xlZnQsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBfY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICksXG4gICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAgICAgLy8gQXZvaWQgc2V0dGluZyByZXQgdG8gZW1wdHkgc3RyaW5nIGhlcmVcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IGRlZmF1bHQgdG8gYXV0b1xuICAgICAgICAgICAgaWYgKCByZXQgPT0gbnVsbCAmJiBzdHlsZSAmJiBzdHlsZVsgbmFtZSBdICkge1xuICAgICAgICAgICAgICAgIHJldCA9IHN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gICAgICAgICAgICAvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcbiAgICAgICAgICAgIC8vIGJ1dCBub3QgcG9zaXRpb24gY3NzIGF0dHJpYnV0ZXMsIGFzIHRob3NlIGFyZSBwcm9wb3J0aW9uYWwgdG8gdGhlIHBhcmVudCBlbGVtZW50IGluc3RlYWRcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBjYW4ndCBtZWFzdXJlIHRoZSBwYXJlbnQgaW5zdGVhZCBiZWNhdXNlIGl0IG1pZ2h0IHRyaWdnZXIgYSBcInN0YWNraW5nIGRvbGxzXCIgcHJvYmxlbVxuICAgICAgICAgICAgaWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgIXJwb3NpdGlvbi50ZXN0KCBuYW1lICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgbGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgICAgICAgICAgcnMgPSBlbGVtLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgICAgICAgICByc0xlZnQgPSBycyAmJiBycy5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgICAgICAgICAgICAgIGlmICggcnNMZWZ0ICkge1xuICAgICAgICAgICAgICAgICAgICBycy5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG4gICAgICAgICAgICAgICAgcmV0ID0gc3R5bGUucGl4ZWxMZWZ0ICsgXCJweFwiO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICggcnNMZWZ0ICkge1xuICAgICAgICAgICAgICAgICAgICBycy5sZWZ0ID0gcnNMZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiYXV0b1wiIDogcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG4gICAgICAgIHJldHVybiBtYXRjaGVzID9cbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG4gICAgICAgICAgICBNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcbiAgICAgICAgICAgIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcbiAgICAgICAgdmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuICAgICAgICAgICAgNCA6XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuICAgICAgICAgICAgdmFsID0gMDtcblxuICAgICAgICBmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG4gICAgICAgICAgICAvLyBib3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG4gICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpc0JvcmRlckJveCApIHtcbiAgICAgICAgICAgICAgICAvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcbiAgICAgICAgICAgICAgICBpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuICAgICAgICAvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG4gICAgICAgICAgICB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcbiAgICAgICAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LnN1cHBvcnQuYm94U2l6aW5nICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cbiAgICAgICAgLy8gc29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG4gICAgICAgIC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuICAgICAgICAvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcbiAgICAgICAgaWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcbiAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiAoIGpRdWVyeS5zdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuICAgICAgICByZXR1cm4gKCB2YWwgK1xuICAgICAgICAgICAgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG4gICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcbiAgICAgICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94LFxuICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgKVxuICAgICAgICApICsgXCJweFwiO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gICAgZnVuY3Rpb24gY3NzX2RlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcbiAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LFxuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG4gICAgICAgIGlmICggIWRpc3BsYXkgKSB7XG4gICAgICAgICAgICBkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcbiAgICAgICAgICAgIGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgaWZyYW1lID0gKCBpZnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiKVxuICAgICAgICAgICAgICAgICAgICAuY3NzKCBcImNzc1RleHRcIiwgXCJkaXNwbGF5OmJsb2NrICFpbXBvcnRhbnRcIiApXG4gICAgICAgICAgICAgICAgKS5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG4gICAgICAgICAgICAgICAgZG9jID0gKCBpZnJhbWVbMF0uY29udGVudFdpbmRvdyB8fCBpZnJhbWVbMF0uY29udGVudERvY3VtZW50ICkuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgZG9jLndyaXRlKFwiPCFkb2N0eXBlIGh0bWw+PGh0bWw+PGJvZHk+XCIpO1xuICAgICAgICAgICAgICAgIGRvYy5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcbiAgICAgICAgICAgICAgICBpZnJhbWUuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuICAgICAgICAgICAgZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIE9OTFkgZnJvbSB3aXRoaW4gY3NzX2RlZmF1bHREaXNwbGF5XG4gICAgZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuICAgICAgICB2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuICAgICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bMF0sIFwiZGlzcGxheVwiICk7XG4gICAgICAgIGVsZW0ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgJiYgcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgZXh0cmEgP1xuICAgICAgICAgICAgICAgICAgICBhdWdtZW50V2lkdGhPckhlaWdodChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3VwcG9ydC5ib3hTaXppbmcgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICApIDogMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5vcGFjaXR5ICkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3Mub3BhY2l0eSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgIC8vIElFIHVzZXMgZmlsdGVycyBmb3Igb3BhY2l0eVxuICAgICAgICAgICAgICAgIHJldHVybiByb3BhY2l0eS50ZXN0KCAoY29tcHV0ZWQgJiYgZWxlbS5jdXJyZW50U3R5bGUgPyBlbGVtLmN1cnJlbnRTdHlsZS5maWx0ZXIgOiBlbGVtLnN0eWxlLmZpbHRlcikgfHwgXCJcIiApID9cbiAgICAgICAgICAgICAgICAgICAgKCAwLjAxICogcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgKSArIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW0uc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSA9IGVsZW0uY3VycmVudFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ID0galF1ZXJ5LmlzTnVtZXJpYyggdmFsdWUgKSA/IFwiYWxwaGEob3BhY2l0eT1cIiArIHZhbHVlICogMTAwICsgXCIpXCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBjdXJyZW50U3R5bGUgJiYgY3VycmVudFN0eWxlLmZpbHRlciB8fCBzdHlsZS5maWx0ZXIgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcbiAgICAgICAgICAgICAgICBzdHlsZS56b29tID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtIGF0dGVtcHQgdG8gcmVtb3ZlIGZpbHRlciBhdHRyaWJ1dGUgIzY2NTJcbiAgICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSA9PT0gXCJcIiwgdGhlbiByZW1vdmUgaW5saW5lIG9wYWNpdHkgIzEyNjg1XG4gICAgICAgICAgICAgICAgaWYgKCAoIHZhbHVlID49IDEgfHwgdmFsdWUgPT09IFwiXCIgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBzdHlsZS5maWx0ZXIgdG8gbnVsbCwgXCJcIiAmIFwiIFwiIHN0aWxsIGxlYXZlIFwiZmlsdGVyOlwiIGluIHRoZSBjc3NUZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIFwiZmlsdGVyOlwiIGlzIHByZXNlbnQgYXQgYWxsLCBjbGVhclR5cGUgaXMgZGlzYWJsZWQsIHdlIHdhbnQgdG8gYXZvaWQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUgaXMgSUUgT25seSwgYnV0IHNvIGFwcGFyZW50bHkgaXMgdGhpcyBjb2RlIHBhdGguLi5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCBcImZpbHRlclwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZmlsdGVyIHN0eWxlIGFwcGxpZWQgaW4gYSBjc3MgcnVsZSBvciB1bnNldCBpbmxpbmUgb3BhY2l0eSwgd2UgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gXCJcIiB8fCBjdXJyZW50U3R5bGUgJiYgIWN1cnJlbnRTdHlsZS5maWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbHRlciA9IHJhbHBoYS50ZXN0KCBmaWx0ZXIgKSA/XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIG9wYWNpdHkgKSA6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciArIFwiIFwiICsgb3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBob29rcyBjYW5ub3QgYmUgYWRkZWQgdW50aWwgRE9NIHJlYWR5IGJlY2F1c2UgdGhlIHN1cHBvcnQgdGVzdFxuICAgIC8vIGZvciBpdCBpcyBub3QgcnVuIHVudGlsIGFmdGVyIERPTSByZWFkeVxuICAgIGpRdWVyeShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgYnkgdGVtcG9yYXJpbHkgc2V0dGluZyBlbGVtZW50IGRpc3BsYXkgdG8gaW5saW5lLWJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbiAgICAgICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodFxuICAgICAgICAvLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxuICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5waXhlbFBvc2l0aW9uICYmIGpRdWVyeS5mbi5wb3NpdGlvbiApIHtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBpZiAoIGpRdWVyeS5leHByICYmIGpRdWVyeS5leHByLmZpbHRlcnMgKSB7XG4gICAgICAgIGpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuICAgICAgICAgICAgLy8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwIHx8XG4gICAgICAgICAgICAgICAgKCFqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgJiYgKChlbGVtLnN0eWxlICYmIGVsZW0uc3R5bGUuZGlzcGxheSkgfHwgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSkgPT09IFwibm9uZVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG4gICAgalF1ZXJ5LmVhY2goe1xuICAgICAgICBtYXJnaW46IFwiXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiXCIsXG4gICAgICAgIGJvcmRlcjogXCJXaWR0aFwiXG4gICAgfSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuICAgICAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9IHt9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciByMjAgPSAvJTIwL2csXG4gICAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvLFxuICAgICAgICByQ1JMRiA9IC9cXHI/XFxuL2csXG4gICAgICAgIHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcbiAgICAgICAgcnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLy8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgLy8gVXNlIC5pcyhcIjpkaXNhYmxlZFwiKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgcnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIHRoaXMuY2hlY2tlZCB8fCAhbWFuaXB1bGF0aW9uX3JjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG4gICAgICAgICAgICB9KS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9TZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuICAgIC8va2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gICAgalF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuICAgICAgICB2YXIgcHJlZml4LFxuICAgICAgICAgICAgcyA9IFtdLFxuICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuICAgICAgICBpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAgICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgICAgICAgIGZvciAoIHByZWZpeCBpbiBhICkge1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG4gICAgICAgIHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICAgICAgICAgIGFkZCggcHJlZml4LCB2ICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgICAgICAgIGFkZCggcHJlZml4LCBvYmogKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBqUXVlcnkuZWFjaCggKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuICAgICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICAgICAgXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cbiAgICAgICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciggbmFtZSApO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmhvdmVyID0gZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuICAgIH07XG4gICAgdmFyXG4gICAgICAgIC8vIERvY3VtZW50IGxvY2F0aW9uXG4gICAgICAgIGFqYXhMb2NQYXJ0cyxcbiAgICAgICAgYWpheExvY2F0aW9uLFxuICAgICAgICBhamF4X25vbmNlID0galF1ZXJ5Lm5vdygpLFxuXG4gICAgICAgIGFqYXhfcnF1ZXJ5ID0gL1xcPy8sXG4gICAgICAgIHJoYXNoID0gLyMuKiQvLFxuICAgICAgICBydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG4gICAgICAgIHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvbWcsIC8vIElFIGxlYXZlcyBhbiBcXHIgY2hhcmFjdGVyIGF0IEVPTFxuICAgICAgICAvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cbiAgICAgICAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG4gICAgICAgIHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcbiAgICAgICAgcnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuXG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbiAgICAgICAgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZCxcblxuICAgICAgICAvKiBQcmVmaWx0ZXJzXG4gICAgICAgICAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG4gICAgICAgICAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG4gICAgICAgICAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcbiAgICAgICAgICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuICAgICAgICAgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG4gICAgICAgICAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcbiAgICAgICAgICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpbHRlcnMgPSB7fSxcblxuICAgICAgICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG4gICAgICAgICAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcbiAgICAgICAgICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuICAgICAgICAgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zcG9ydHMgPSB7fSxcblxuICAgICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cbiAgICAgICAgYWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KFwiKlwiKTtcblxuICAgIC8vICM4MTM4LCBJRSBtYXkgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG4gICAgLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XG4gICAgdHJ5IHtcbiAgICAgICAgYWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcbiAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudFxuICAgICAgICAvLyBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvblxuICAgICAgICBhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuICAgICAgICBhamF4TG9jYXRpb24uaHJlZiA9IFwiXCI7XG4gICAgICAgIGFqYXhMb2NhdGlvbiA9IGFqYXhMb2NhdGlvbi5ocmVmO1xuICAgIH1cblxuICAgIC8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuICAgIGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuICAgIC8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbiAgICBmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuICAgICAgICAvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGFUeXBlWzBdID09PSBcIitcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnVuc2hpZnQoIGZ1bmMgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS5wdXNoKCBmdW5jICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG4gICAgZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuICAgICAgICB2YXIgaW5zcGVjdGVkID0ge30sXG4gICAgICAgICAgICBzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuICAgICAgICBmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICAgIGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbiAgICB9XG5cbiAgICAvLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbiAgICAvLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuICAgIC8vIEZpeGVzICM5ODg3XG4gICAgZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG4gICAgICAgIHZhciBkZWVwLCBrZXksXG4gICAgICAgICAgICBmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZm9yICgga2V5IGluIHNyYyApIHtcbiAgICAgICAgICAgIGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8IChkZWVwID0ge30pICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggZGVlcCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBqUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG4gICAgICAgIGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcbiAgICAgICAgICAgIHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0b3IsIHJlc3BvbnNlLCB0eXBlLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG5cbiAgICAgICAgaWYgKCBvZmYgPj0gMCApIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gdXJsLnNsaWNlKCBvZmYsIHVybC5sZW5ndGggKTtcbiAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb25cbiAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgdHlwZSA9IFwiUE9TVFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAgICAgICAvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFyZ3VtZW50cztcblxuICAgICAgICAgICAgICAgIHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCApO1xuXG4gICAgICAgICAgICB9KS5jb21wbGV0ZSggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lYWNoKCBjYWxsYmFjaywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbiAgICBqUXVlcnkuZWFjaCggWyBcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICl7XG4gICAgICAgIGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG4gICAgICAgIGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcbiAgICAgICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogY2FsbGJhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG5cbiAgICAgICAgLy8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG4gICAgICAgIGFjdGl2ZTogMCxcblxuICAgICAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXG4gICAgICAgIGV0YWc6IHt9LFxuXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICAgICAgdXJsOiBhamF4TG9jYXRpb24sXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcbiAgICAgICAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBudWxsLFxuICAgICAgICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICAgICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgICAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgICAgICAgdGhyb3dzOiBmYWxzZSxcbiAgICAgICAgICAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgYWNjZXB0czoge1xuICAgICAgICAgICAgICAgIFwiKlwiOiBhbGxUeXBlcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgICAgICBodG1sOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG4gICAgICAgICAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IC94bWwvLFxuICAgICAgICAgICAgICAgIGh0bWw6IC9odG1sLyxcbiAgICAgICAgICAgICAgICBqc29uOiAvanNvbi9cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3BvbnNlRmllbGRzOiB7XG4gICAgICAgICAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIlxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRGF0YSBjb252ZXJ0ZXJzXG4gICAgICAgICAgICAvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICBjb252ZXJ0ZXJzOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcbiAgICAgICAgICAgICAgICBcIiogdGV4dFwiOiB3aW5kb3cuU3RyaW5nLFxuXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcbiAgICAgICAgICAgICAgICBcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuICAgICAgICAvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG4gICAgICAgIGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MgP1xuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAgICBhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG4gICAgICAgIGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG4gICAgICAgIC8vIE1haW4gbWV0aG9kXG4gICAgICAgIGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuICAgICAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgICAgIC8vIExvb3AgdmFyaWFibGVcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cbiAgICAgICAgICAgICAgICBjYWNoZVVSTCxcbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBoZWFkZXJzIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcbiAgICAgICAgICAgICAgICAvLyB0aW1lb3V0IGhhbmRsZVxuICAgICAgICAgICAgICAgIHRpbWVvdXRUaW1lcixcblxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgICAgIGZpcmVHbG9iYWxzLFxuXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgIHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG4gICAgICAgICAgICAgICAgLy8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJiAoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LFxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkc1xuICAgICAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG4gICAgICAgICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcbiAgICAgICAgICAgICAgICAvLyBUaGUganFYSFIgc3RhdGVcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDAsXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgc3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG4gICAgICAgICAgICAgICAgLy8gRmFrZSB4aHJcbiAgICAgICAgICAgICAgICBqcVhIUiA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlTdGF0ZTogMCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhdyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGVzIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzdGF0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgPCAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBjb2RlIGluIG1hcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHJhbnNwb3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCAwLCBmaW5hbFRleHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIGRlZmVycmVkc1xuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuICAgICAgICAgICAganFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG4gICAgICAgICAgICBqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuICAgICAgICAgICAgLy8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAoIzU4NjY6IElFNyBpc3N1ZSB3aXRoIHByb3RvY29sLWxlc3MgdXJscylcbiAgICAgICAgICAgIC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG4gICAgICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBhamF4TG9jYXRpb24gKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApLnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuICAgICAgICAgICAgLy8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG4gICAgICAgICAgICBzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG4gICAgICAgICAgICBzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggY29yZV9ybm90d2hpdGUgKSB8fCBbXCJcIl07XG5cbiAgICAgICAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG4gICAgICAgICAgICBpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuICAgICAgICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMgKSApICE9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhamF4TG9jUGFydHNbIDMgXSB8fCAoIGFqYXhMb2NQYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyA4MCA6IDQ0MyApICkgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuICAgICAgICAgICAgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHByZWZpbHRlcnNcbiAgICAgICAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG4gICAgICAgICAgICAvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG4gICAgICAgICAgICBmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xuXG4gICAgICAgICAgICAvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXG4gICAgICAgICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcbiAgICAgICAgICAgIHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcbiAgICAgICAgICAgIC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuICAgICAgICAgICAgY2FjaGVVUkwgPSBzLnVybDtcblxuICAgICAgICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICggIXMuaGFzQ29udGVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcbiAgICAgICAgICAgICAgICBpZiAoIHMuZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgPSAoIHMudXJsICs9ICggYWpheF9ycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIGFqYXhfbm9uY2UrKyApIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgKyAoIGFqYXhfcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBhamF4X25vbmNlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgaWYgKCBzLmlmTW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuICAgICAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICAgICAgICAgICBcIkFjY2VwdFwiLFxuICAgICAgICAgICAgICAgIHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzWyBcIipcIiBdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cbiAgICAgICAgICAgIGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcbiAgICAgICAgICAgIGlmICggcy5iZWZvcmVTZW5kICYmICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG4gICAgICAgICAgICBzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuICAgICAgICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG4gICAgICAgICAgICBmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XG4gICAgICAgICAgICAgICAganFYSFJbIGkgXSggc1sgaSBdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG4gICAgICAgICAgICAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcbiAgICAgICAgICAgIGlmICggIXRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICBkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXRcbiAgICAgICAgICAgICAgICBpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcy50aW1lb3V0ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlIDwgMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoIC0xLCBlICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIENhbGxlZCBvbmNlXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKCB0aW1lb3V0VGltZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgcmVzcG9uc2UgZGF0YVxuICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzLmlmTW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID09PSAyMDQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBpc1N1Y2Nlc3Muc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gaXNTdWNjZXNzLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGlzU3VjY2Vzcy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9ICFlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gbm9ybWFsaXplIHN0YXR1c1RleHQgYW5kIHN0YXR1cyBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxuICAgICAgICAgICAgICAgIGlmICggaXNTdWNjZXNzICkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuICAgICAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gICAgICogLSBzZXRzIGFsbCByZXNwb25zZVhYWCBmaWVsZHMgYWNjb3JkaW5nbHlcbiAgICAgKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICAgICAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG4gICAgICAgIHZhciBmaXJzdERhdGFUeXBlLCBjdCwgZmluYWxEYXRhVHlwZSwgdHlwZSxcbiAgICAgICAgICAgIGNvbnRlbnRzID0gcy5jb250ZW50cyxcbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLFxuICAgICAgICAgICAgcmVzcG9uc2VGaWVsZHMgPSBzLnJlc3BvbnNlRmllbGRzO1xuXG4gICAgICAgIC8vIEZpbGwgcmVzcG9uc2VYWFggZmllbGRzXG4gICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VGaWVsZHMgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgIGpxWEhSWyByZXNwb25zZUZpZWxkc1t0eXBlXSBdID0gcmVzcG9uc2VzWyB0eXBlIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICB3aGlsZSggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuICAgICAgICAgICAgZGF0YVR5cGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgY3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG4gICAgICAgIGlmICggY3QgKSB7XG4gICAgICAgICAgICBmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuICAgICAgICAgICAgICAgIGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuICAgICAgICBpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgIGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCAhZmlyc3REYXRhVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gICAgICAgIGlmICggZmluYWxEYXRhVHlwZSApIHtcbiAgICAgICAgICAgIGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAgICBmdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UgKSB7XG4gICAgICAgIHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLFxuICAgICAgICAgICAgY29udmVydGVycyA9IHt9LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpLFxuICAgICAgICAgICAgcHJldiA9IGRhdGFUeXBlc1sgMCBdO1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICggcy5kYXRhRmlsdGVyICkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcbiAgICAgICAgaWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcbiAgICAgICAgICAgIGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZSwgdG9sZXJhdGluZyBsaXN0IG1vZGlmaWNhdGlvblxuICAgICAgICBmb3IgKCA7IChjdXJyZW50ID0gZGF0YVR5cGVzWysraV0pOyApIHtcblxuICAgICAgICAgICAgLy8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuICAgICAgICAgICAgaWYgKCBjdXJyZW50ICE9PSBcIipcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgICAgICAgICBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhY29udiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBjb252Mi5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29udiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29udiA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdG1wWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnNwbGljZSggaS0tLCAwLCBjdXJyZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICYmIHNbXCJ0aHJvd3NcIl0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmV2IGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xuICAgIH1cbiAgICAvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxuICAgIGpRdWVyeS5hamF4U2V0dXAoe1xuICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgc2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydGVyczoge1xuICAgICAgICAgICAgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGdsb2JhbFxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcbiAgICAgICAgaWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBzLmNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBzLmNyb3NzRG9tYWluICkge1xuICAgICAgICAgICAgcy50eXBlID0gXCJHRVRcIjtcbiAgICAgICAgICAgIHMuZ2xvYmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbihzKSB7XG5cbiAgICAgICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuICAgICAgICBpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHQsXG4gICAgICAgICAgICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgalF1ZXJ5KFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiggXywgY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcy5zY3JpcHRDaGFyc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LmNoYXJzZXQgPSBzLnNjcmlwdENoYXJzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc3JjID0gcy51cmw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiggXywgaXNBYm9ydCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0Fib3J0IHx8ICFzY3JpcHQucmVhZHlTdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KCBzY3JpcHQucmVhZHlTdGF0ZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNjcmlwdC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayBpZiBub3QgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0Fib3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggMjAwLCBcInN1Y2Nlc3NcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaXJjdW12ZW50IElFNiBidWdzIHdpdGggYmFzZSBlbGVtZW50cyAoIzI3MDkgYW5kICM0Mzc4KSBieSBwcmVwZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuICAgICAgICAgICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZSggc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjcmlwdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQoIHVuZGVmaW5lZCwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcbiAgICAgICAgcmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuICAgIC8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbiAgICBqUXVlcnkuYWpheFNldHVwKHtcbiAgICAgICAganNvbnA6IFwiY2FsbGJhY2tcIixcbiAgICAgICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBhamF4X25vbmNlKysgKSApO1xuICAgICAgICAgICAgdGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG4gICAgICAgIHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcbiAgICAgICAgICAgIGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG4gICAgICAgICAgICAgICAgXCJ1cmxcIiA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG4gICAgICAgIGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG4gICAgICAgICAgICAvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaygpIDpcbiAgICAgICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcbiAgICAgICAgICAgIGlmICgganNvblByb3AgKSB7XG4gICAgICAgICAgICAgICAgc1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHMudXJsICs9ICggYWpheF9ycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZm9yY2UganNvbiBkYXRhVHlwZVxuICAgICAgICAgICAgcy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXG4gICAgICAgICAgICBvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG4gICAgICAgICAgICB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcbiAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgd2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBiYWNrIGFzIGZyZWVcbiAgICAgICAgICAgICAgICBpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcbiAgICAgICAgICAgIHJldHVybiBcInNjcmlwdFwiO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHhockNhbGxiYWNrcywgeGhyU3VwcG9ydGVkLFxuICAgICAgICB4aHJJZCA9IDAsXG4gICAgICAgIC8vICM1MjgwOiBJbnRlcm5ldCBFeHBsb3JlciB3aWxsIGtlZXAgY29ubmVjdGlvbnMgYWxpdmUgaWYgd2UgZG9uJ3QgYWJvcnQgb24gdW5sb2FkXG4gICAgICAgIHhock9uVW5sb2FkQWJvcnQgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgZm9yICgga2V5IGluIHhockNhbGxiYWNrcyApIHtcbiAgICAgICAgICAgICAgICB4aHJDYWxsYmFja3NbIGtleSBdKCB1bmRlZmluZWQsIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkWEhSKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0aXZlWEhSKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICB9IGNhdGNoKCBlICkge31cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAgLy8gKFRoaXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYWpheFNldHRpbmdzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgP1xuICAgICAgICAvKiBNaWNyb3NvZnQgZmFpbGVkIHRvIHByb3Blcmx5XG4gICAgICAgICAqIGltcGxlbWVudCB0aGUgWE1MSHR0cFJlcXVlc3QgaW4gSUU3IChjYW4ndCByZXF1ZXN0IGxvY2FsIGZpbGVzKSxcbiAgICAgICAgICogc28gd2UgdXNlIHRoZSBBY3RpdmVYT2JqZWN0IHdoZW4gaXQgaXMgYXZhaWxhYmxlXG4gICAgICAgICAqIEFkZGl0aW9uYWxseSBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgaW4gSUU3L0lFOCBzb1xuICAgICAgICAgKiB3ZSBuZWVkIGEgZmFsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc0xvY2FsICYmIGNyZWF0ZVN0YW5kYXJkWEhSKCkgfHwgY3JlYXRlQWN0aXZlWEhSKCk7XG4gICAgICAgIH0gOlxuICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuICAgICAgICBjcmVhdGVTdGFuZGFyZFhIUjtcblxuICAgIC8vIERldGVybWluZSBzdXBwb3J0IHByb3BlcnRpZXNcbiAgICB4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuICAgIGpRdWVyeS5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG4gICAgeGhyU3VwcG9ydGVkID0galF1ZXJ5LnN1cHBvcnQuYWpheCA9ICEheGhyU3VwcG9ydGVkO1xuXG4gICAgLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcbiAgICBpZiAoIHhoclN1cHBvcnRlZCApIHtcblxuICAgICAgICBqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggcyApIHtcbiAgICAgICAgICAgIC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIGlmICggIXMuY3Jvc3NEb21haW4gfHwgalF1ZXJ5LnN1cHBvcnQuY29ycyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHhoclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBzLnhocigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIHRoZSBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzLnVzZXJuYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jLCBzLnVzZXJuYW1lLCBzLnBhc3N3b3JkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcy54aHJGaWVsZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSBpbiBzLnhockZpZWxkcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyWyBpIF0gPSBzLnhockZpZWxkc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCBzLm1pbWVUeXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIGFuIGV4dHJhIHRyeS9jYXRjaCBmb3IgY3Jvc3MgZG9tYWluIHJlcXVlc3RzIGluIEZpcmVmb3ggM1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKCBlcnIgKSB7fVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZWQgaW4galF1ZXJ5LmFqYXggKHNvIG5vIHRyeS9jYXRjaCBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoICggcy5oYXNDb250ZW50ICYmIHMuZGF0YSApIHx8IG51bGwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cywgcmVzcG9uc2VIZWFkZXJzLCBzdGF0dXNUZXh0LCByZXNwb25zZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBleGNlcHRpb25zIHdoZW4gYWNjZXNzaW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBhbiB4aHIgd2hlbiBhIG5ldHdvcmsgZXJyb3Igb2NjdXJyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vaGVscGZ1bC5rbm9icy1kaWFscy5jb20vaW5kZXgucGhwL0NvbXBvbmVudF9yZXR1cm5lZF9mYWlsdXJlX2NvZGU6XzB4ODAwNDAxMTFfKE5TX0VSUk9SX05PVF9BVkFJTEFCTEUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgJiYgKCBpc0Fib3J0IHx8IHhoci5yZWFkeVN0YXRlID09PSA0ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2FsbGVkIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qga2VlcCBhcyBhY3RpdmUgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGpRdWVyeS5ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHhockNhbGxiYWNrc1sgaGFuZGxlIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFuIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzQWJvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaXQgbWFudWFsbHkgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmVxdWVzdGluZyBiaW5hcnkgZGF0YSwgSUU2LTkgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgcmVzcG9uc2VUZXh0ICgjMTE0MjYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLnRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXR1c1RleHQgZm9yIGZhdWx0eSBjcm9zcy1kb21haW4gcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBzdGF0dXMgZm9yIG5vbiBzdGFuZGFyZCBiZWhhdmlvcnNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzIGxvY2FsIGFuZCB3ZSBoYXZlIGRhdGE6IGFzc3VtZSBhIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoc3VjY2VzcyB3aXRoIG5vIGRhdGEgd29uJ3QgZ2V0IG5vdGlmaWVkLCB0aGF0J3MgdGhlIGJlc3Qgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gZG8gZ2l2ZW4gY3VycmVudCBpbXBsZW1lbnRhdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhdHVzICYmIHMuaXNMb2NhbCAmJiAhcy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gcmVzcG9uc2VzLnRleHQgPyAyMDAgOiA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgLSAjMTQ1MDogc29tZXRpbWVzIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDEyMjMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0Fib3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoIC0xLCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGNvbXBsZXRlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSggc3RhdHVzLCBzdGF0dXNUZXh0LCByZXNwb25zZXMsIHJlc3BvbnNlSGVhZGVycyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXMuYXN5bmMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gc3luYyBtb2RlIHdlIGZpcmUgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChJRTYgJiBJRTcpIGlmIGl0J3MgaW4gY2FjaGUgYW5kIGhhcyBiZWVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0cmlldmVkIGRpcmVjdGx5IHdlIG5lZWQgdG8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBjYWxsYmFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSArK3hocklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBhY3RpdmUgeGhycyBjYWxsYmFja3MgbGlzdCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGF0dGFjaCB0aGUgdW5sb2FkIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAheGhyQ2FsbGJhY2tzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyQ2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHdpbmRvdyApLnVubG9hZCggeGhyT25VbmxvYWRBYm9ydCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IG9mIGFjdGl2ZSB4aHJzIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJDYWxsYmFja3NbIGhhbmRsZSBdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCB1bmRlZmluZWQsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZnhOb3csIHRpbWVySWQsXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgICByZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBjb3JlX3BudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG4gICAgICAgIHJydW4gPSAvcXVldWVIb29rcyQvLFxuICAgICAgICBhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG4gICAgICAgIHR3ZWVuZXJzID0ge1xuICAgICAgICAgICAgXCIqXCI6IFtmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCwgdW5pdCxcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSArdGFyZ2V0IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gMSxcbiAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDIwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJ0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gK3BhcnRzWzJdO1xuICAgICAgICAgICAgICAgICAgICB1bml0ID0gcGFydHNbM10gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHN0YXJ0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pdCAhPT0gXCJweFwiICYmIHN0YXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlciB0aGUgY3VycmVudCBwcm9wZXJ0eSwgYmVjYXVzZSB0aGlzIHByb2Nlc3Mgd2lsbCBiZSB0cml2aWFsIGlmIGl0IHVzZXMgdGhlIHNhbWUgdW5pdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGVuZCBvciBhIHNpbXBsZSBjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCBwcm9wLCB0cnVlICkgfHwgZW5kIHx8IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIHN0cmluZyBmb3IgZG91YmxpbmcgZmFjdG9yIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgYW5kIGFwcGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydCAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgYnJlYWtpbmcgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoIHNjYWxlICE9PSAoc2NhbGUgPSB0d2Vlbi5jdXIoKSAvIHRhcmdldCkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi51bml0ID0gdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSArPS8tPSB0b2tlbiB3YXMgcHJvdmlkZWQsIHdlJ3JlIGRvaW5nIGEgcmVsYXRpdmUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVuZCA9IHBhcnRzWzFdID8gc3RhcnQgKyAoIHBhcnRzWzFdICsgMSApICogZW5kIDogZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICB9XVxuICAgICAgICB9O1xuXG4gICAgLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVucyggYW5pbWF0aW9uLCBwcm9wcyApIHtcbiAgICAgICAgalF1ZXJ5LmVhY2goIHByb3BzLCBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgIGlmICggY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgc3RvcHBlZCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFuaW1hdGlvblByZWZpbHRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aWNrLmVsZW07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHN0b3BwZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuICAgICAgICAgICAgICAgICAgICAvLyBhcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgMSAtICggMC41IHx8IDAgKSAoIzEyNDk3KVxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxIC0gdGVtcCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xuICAgICAgICAgICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgICAgICAgICAgcHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG4gICAgICAgICAgICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgeyBzcGVjaWFsRWFzaW5nOiB7fSB9LCBvcHRpb25zICksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHdlZW5zOiBbXSxcbiAgICAgICAgICAgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0b3BwZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cbiAgICAgICAgcHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFuaW1hdGlvblByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcbiAgICAgICAgICAgIGlmICggcmVzdWx0ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjcmVhdGVUd2VlbnMoIGFuaW1hdGlvbiwgcHJvcHMgKTtcblxuICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkuZngudGltZXIoXG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG4gICAgICAgICAgICAgICAgZWxlbTogZWxlbSxcbiAgICAgICAgICAgICAgICBhbmltOiBhbmltYXRpb24sXG4gICAgICAgICAgICAgICAgcXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG4gICAgICAgIHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcbiAgICAgICAgICAgIC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG4gICAgICAgICAgICAuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG4gICAgICAgICAgICAuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcbiAgICAgICAgdmFyIHZhbHVlLCBuYW1lLCBpbmRleCwgZWFzaW5nLCBob29rcztcblxuICAgICAgICAvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcbiAgICAgICAgZm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcbiAgICAgICAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIGVhc2luZyA9IHZhbHVlWyAxIF07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcbiAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgIC8vIG5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b250IG92ZXJ3cml0ZSBrZXlzIGFscmVhZHkgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAvLyBhbHNvIC0gcmV1c2luZyAnaW5kZXgnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG4gICAgICAgICAgICAgICAgZm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cbiAgICAgICAgdHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcyA9IFsgXCIqXCIgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm9wLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wc1sgaW5kZXggXTtcbiAgICAgICAgICAgICAgICB0d2VlbmVyc1sgcHJvcCBdID0gdHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG4gICAgICAgICAgICBpZiAoIHByZXBlbmQgKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25QcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICB2YXIgcHJvcCwgaW5kZXgsIGxlbmd0aCxcbiAgICAgICAgICAgIHZhbHVlLCBkYXRhU2hvdywgdG9nZ2xlLFxuICAgICAgICAgICAgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLFxuICAgICAgICAgICAgYW5pbSA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXG4gICAgICAgICAgICBvcmlnID0ge30sXG4gICAgICAgICAgICBoYW5kbGVkID0gW10sXG4gICAgICAgICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICk7XG5cbiAgICAgICAgLy8gaGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xuICAgICAgICBpZiAoICFvcHRzLnF1ZXVlICkge1xuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuICAgICAgICAgICAgaWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIGhvb2tzLnVucXVldWVkID0gMDtcbiAgICAgICAgICAgICAgICBvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcbiAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhvb2tzLnVucXVldWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvb2tzLnVucXVldWVkKys7XG5cbiAgICAgICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIHRoaXMgY29tcGxldGVzXG4gICAgICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVucXVldWVkLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG4gICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcbiAgICAgICAgICAgIC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuICAgICAgICAgICAgLy8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgICAgIG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG4gICAgICAgICAgICAvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuICAgICAgICAgICAgLy8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcImlubGluZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vIGlubGluZS1sZXZlbCBlbGVtZW50cyBhY2NlcHQgaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICAgIC8vIGJsb2NrLWxldmVsIGVsZW1lbnRzIG5lZWQgdG8gYmUgaW5saW5lIHdpdGggbGF5b3V0XG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCB8fCBjc3NfZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA9PT0gXCJpbmxpbmVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS56b29tID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzICkge1xuICAgICAgICAgICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIHNob3cvaGlkZSBwYXNzXG4gICAgICAgIGZvciAoIGluZGV4IGluIHByb3BzICkge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcbiAgICAgICAgICAgIGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbIGluZGV4IF07XG4gICAgICAgICAgICAgICAgdG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlZC5wdXNoKCBpbmRleCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gaGFuZGxlZC5sZW5ndGg7XG4gICAgICAgIGlmICggbGVuZ3RoICkge1xuICAgICAgICAgICAgZGF0YVNob3cgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZnhzaG93XCIgKSB8fCBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG4gICAgICAgICAgICBpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG4gICAgICAgICAgICBpZiAoIHRvZ2dsZSApIHtcbiAgICAgICAgICAgICAgICBkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggZWxlbSApLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgICAgICAgICBqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIFwiZnhzaG93XCIgKTtcbiAgICAgICAgICAgICAgICBmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKCBpbmRleCA9IDAgOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGhhbmRsZWRbIGluZGV4IF07XG4gICAgICAgICAgICAgICAgdHdlZW4gPSBhbmltLmNyZWF0ZVR3ZWVuKCBwcm9wLCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCApO1xuICAgICAgICAgICAgICAgIG9yaWdbIHByb3AgXSA9IGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuICAgICAgICByZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xuICAgIH1cbiAgICBqUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFR3ZWVuLFxuICAgICAgICBpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFwic3dpbmdcIjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuICAgICAgICB9LFxuICAgICAgICBjdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuICAgICAgICAgICAgcmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG4gICAgICAgICAgICAgICAgaG9va3MuZ2V0KCB0aGlzICkgOlxuICAgICAgICAgICAgICAgIFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcbiAgICAgICAgICAgIHZhciBlYXNlZCxcbiAgICAgICAgICAgICAgICBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuICAgICAgICAgICAgICAgIGhvb2tzLnNldCggdGhpcyApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgICBUd2Vlbi5wcm9wSG9va3MgPSB7XG4gICAgICAgIF9kZWZhdWx0OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHNcbiAgICAgICAgICAgICAgICAvLyBzbywgc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXG4gICAgICAgICAgICAgICAgLy8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcyBpcy5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQgLSB1c2UgY3NzSG9vayBpZiBpdHMgdGhlcmUgLSB1c2UgLnN0eWxlIGlmIGl0c1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0uc3R5bGUgJiYgKCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHwgalF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgaW4gMi4wIC0gdGhpcyBzdXBwb3J0cyBJRTgncyBwYW5pYyBiYXNlZCBhcHByb2FjaFxuICAgIC8vIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXG4gICAgVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICAgICAgICAgIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICB2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cbiAgICAgICAgICAgICAgICBjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgIC8vIHNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuICAgICAgICAgICAgICAgIC8vIGFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIC5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcbiAgICAgICAgICAgICAgICBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG4gICAgICAgICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuICAgICAgICAgICAgICAgICAgICBkb0FuaW1hdGlvbi5maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW0uc3RvcCggdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbXB0eSB8fCBqUXVlcnkuX2RhdGEoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW0uc3RvcCggdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcbiAgICAgICAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIHN0b3AoIGdvdG9FbmQgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgICAgICAgICAgY2xlYXJRdWV1ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVxdWV1ZSA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS5fZGF0YSggdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaW5kZXggaW4gZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXF1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZFxuICAgICAgICAgICAgICAgIC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXG4gICAgICAgICAgICAgICAgLy8gYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmRcbiAgICAgICAgICAgICAgICBpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuICAgICAgICAgICAgICAgICAgICBob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG4gICAgICAgICAgICAgICAgZGF0YS5maW5pc2ggPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBob29rcy5jdXIgJiYgaG9va3MuY3VyLmZpbmlzaCApIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MuY3VyLmZpbmlzaC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuICAgICAgICAgICAgICAgIGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG4gICAgZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcbiAgICAgICAgdmFyIHdoaWNoLFxuICAgICAgICAgICAgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgLy8gaWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG4gICAgICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aD8gMSA6IDA7XG4gICAgICAgIGZvciggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcbiAgICAgICAgICAgIHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG4gICAgICAgICAgICBhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaW5jbHVkZVdpZHRoICkge1xuICAgICAgICAgICAgYXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG4gICAgalF1ZXJ5LmVhY2goe1xuICAgICAgICBzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiKSxcbiAgICAgICAgc2xpZGVVcDogZ2VuRngoXCJoaWRlXCIpLFxuICAgICAgICBzbGlkZVRvZ2dsZTogZ2VuRngoXCJ0b2dnbGVcIiksXG4gICAgICAgIGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuICAgICAgICBmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG4gICAgICAgIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuICAgICAgICB2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG4gICAgICAgICAgICBjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuICAgICAgICAgICAgZHVyYXRpb246IHNwZWVkLFxuICAgICAgICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcbiAgICAgICAgICAgIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuICAgICAgICBpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIG9wdC5xdWV1ZSA9IFwiZnhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFF1ZXVlaW5nXG4gICAgICAgIG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cbiAgICAgICAgb3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG4gICAgICAgICAgICAgICAgb3B0Lm9sZC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb3B0LnF1ZXVlICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZWFzaW5nID0ge1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIHN3aW5nOiBmdW5jdGlvbiggcCApIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCpNYXRoLlBJICkgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS50aW1lcnMgPSBbXTtcbiAgICBqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcbiAgICBqUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGltZXIsXG4gICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cbiAgICAgICAgZm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbIGkgXTtcbiAgICAgICAgICAgIC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG4gICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaS0tLCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuICAgICAgICBpZiAoIHRpbWVyKCkgJiYgalF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApICkge1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbiAgICBqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhdGltZXJJZCApIHtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcbiAgICAgICAgdGltZXJJZCA9IG51bGw7XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5zcGVlZHMgPSB7XG4gICAgICAgIHNsb3c6IDYwMCxcbiAgICAgICAgZmFzdDogMjAwLFxuICAgICAgICAvLyBEZWZhdWx0IHNwZWVkXG4gICAgICAgIF9kZWZhdWx0OiA0MDBcbiAgICB9O1xuXG4gICAgLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbiAgICBqUXVlcnkuZnguc3RlcCA9IHt9O1xuXG4gICAgaWYgKCBqUXVlcnkuZXhwciAmJiBqUXVlcnkuZXhwci5maWx0ZXJzICkge1xuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBqUXVlcnkuZm4ub2Zmc2V0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2NFbGVtLCB3aW4sXG4gICAgICAgICAgICBib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXSxcbiAgICAgICAgICAgIGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIGlmICggIWRvYyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuICAgICAgICBpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcbiAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGdCQ1IsIGp1c3QgdXNlIDAsMCByYXRoZXIgdGhhbiBlcnJvclxuICAgICAgICAvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpXG4gICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBjb3JlX3N0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luID0gZ2V0V2luZG93KCBkb2MgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogYm94LnRvcCAgKyAoIHdpbi5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCApICAtICggZG9jRWxlbS5jbGllbnRUb3AgIHx8IDAgKSxcbiAgICAgICAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgKCB3aW4ucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0ICkgLSAoIGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwIClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5Lm9mZnNldCA9IHtcblxuICAgICAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICk7XG5cbiAgICAgICAgICAgIC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgICAgICAgICAgIGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcbiAgICAgICAgICAgICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKSxcbiAgICAgICAgICAgICAgICBjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKSxcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiYgalF1ZXJ5LmluQXJyYXkoXCJhdXRvXCIsIFtjdXJDU1NUb3AsIGN1ckNTU0xlZnRdKSA+IC0xLFxuICAgICAgICAgICAgICAgIHByb3BzID0ge30sIGN1clBvc2l0aW9uID0ge30sIGN1clRvcCwgY3VyTGVmdDtcblxuICAgICAgICAgICAgLy8gbmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXIgdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG4gICAgICAgICAgICBpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuICAgICAgICAgICAgICAgIGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcbiAgICAgICAgICAgICAgICBjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBjdXJPZmZzZXQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyRWxlbS5jc3MoIHByb3BzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcblxuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoICF0aGlzWyAwIF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdO1xuXG4gICAgICAgICAgICAvLyBmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0J3Mgb25seSBvZmZzZXQgcGFyZW50XG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG4gICAgICAgICAgICAvLyBub3RlOiB3aGVuIGFuIGVsZW1lbnQgaGFzIG1hcmdpbjogYXV0byB0aGUgb2Zmc2V0TGVmdCBhbmQgbWFyZ2luTGVmdFxuICAgICAgICAgICAgLy8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKCB7c2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIn0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG4gICAgICAgIHZhciB0b3AgPSAvWS8udGVzdCggcHJvcCApO1xuXG4gICAgICAgIGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luID8gKHByb3AgaW4gd2luKSA/IHdpblsgcHJvcCBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIG1ldGhvZCBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG1ldGhvZCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggd2luICkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAhdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxMZWZ0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbFRvcCgpXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtWyBtZXRob2QgXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgP1xuICAgICAgICAgICAgZWxlbSA6XG4gICAgICAgICAgICBlbGVtLm5vZGVUeXBlID09PSA5ID9cbiAgICAgICAgICAgICAgICBlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcbiAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuICAgICAgICBqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuICAgICAgICAgICAgLy8gbWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG4gICAgICAgICAgICBqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSwgd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5LCB0aGlzIGNhdXNlcyBidWcgIzM4MzggaW4gSUU2Lzggb25seSwgYnV0IHRoZXJlIGlzIGN1cnJlbnRseSBubyBnb29kLCBzbWFsbCB3YXkgdG8gZml4IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuICAgICAgICAgICAgICAgIH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBMaW1pdCBzY29wZSBwb2xsdXRpb24gZnJvbSBhbnkgZGVwcmVjYXRlZCBBUElcbiAgICAvLyAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyB9KSgpO1xuICAgIC8vIEV4cG9zZSBqUXVlcnkgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICB3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG5cbiAgICAvLyBFeHBvc2UgalF1ZXJ5IGFzIGFuIEFNRCBtb2R1bGUsIGJ1dCBvbmx5IGZvciBBTUQgbG9hZGVycyB0aGF0XG4gICAgLy8gdW5kZXJzdGFuZCB0aGUgaXNzdWVzIHdpdGggbG9hZGluZyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBqUXVlcnlcbiAgICAvLyBpbiBhIHBhZ2UgdGhhdCBhbGwgbWlnaHQgY2FsbCBkZWZpbmUoKS4gVGhlIGxvYWRlciB3aWxsIGluZGljYXRlXG4gICAgLy8gdGhleSBoYXZlIHNwZWNpYWwgYWxsb3dhbmNlcyBmb3IgbXVsdGlwbGUgalF1ZXJ5IHZlcnNpb25zIGJ5XG4gICAgLy8gc3BlY2lmeWluZyBkZWZpbmUuYW1kLmpRdWVyeSA9IHRydWUuIFJlZ2lzdGVyIGFzIGEgbmFtZWQgbW9kdWxlLFxuICAgIC8vIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXIgZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSxcbiAgICAvLyBidXQgbm90IHVzZSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0IHVuZGVyc3RhbmRzIGFub255bW91c1xuICAgIC8vIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0IHdheSB0byByZWdpc3Rlci5cbiAgICAvLyBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZSBkZXJpdmVkIGZyb21cbiAgICAvLyBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZSBmaWxlIG5hbWUuXG4gICAgLy8gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50cyB0byBjYWxsXG4gICAgLy8gbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICYmIGRlZmluZS5hbWQualF1ZXJ5ICkge1xuICAgICAgICBkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbiAoKSB7IHJldHVybiBqUXVlcnk7IH0gKTtcbiAgICB9XG5cbiAgICB9KSggd2luZG93ICk7XG4iXSwibmFtZXMiOlsid2luZG93IiwidW5kZWZpbmVkIiwicmVhZHlMaXN0Iiwicm9vdGpRdWVyeSIsImNvcmVfc3RydW5kZWZpbmVkIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsIl9qUXVlcnkiLCJqUXVlcnkiLCJfJCIsIiQiLCJjbGFzczJ0eXBlIiwiY29yZV9kZWxldGVkSWRzIiwiY29yZV92ZXJzaW9uIiwiY29yZV9jb25jYXQiLCJjb25jYXQiLCJjb3JlX3B1c2giLCJwdXNoIiwiY29yZV9zbGljZSIsInNsaWNlIiwiY29yZV9pbmRleE9mIiwiaW5kZXhPZiIsImNvcmVfdG9TdHJpbmciLCJ0b1N0cmluZyIsImNvcmVfaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJjb3JlX3RyaW0iLCJ0cmltIiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwiY29yZV9wbnVtIiwic291cmNlIiwiY29yZV9ybm90d2hpdGUiLCJydHJpbSIsInJxdWlja0V4cHIiLCJyc2luZ2xlVGFnIiwicnZhbGlkY2hhcnMiLCJydmFsaWRicmFjZXMiLCJydmFsaWRlc2NhcGUiLCJydmFsaWR0b2tlbnMiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImFsbCIsImxldHRlciIsInRvVXBwZXJDYXNlIiwiY29tcGxldGVkIiwiZXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwidHlwZSIsInJlYWR5U3RhdGUiLCJkZXRhY2giLCJyZWFkeSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsInByb3RvdHlwZSIsImpxdWVyeSIsImNvbnN0cnVjdG9yIiwibWF0Y2giLCJlbGVtIiwiY2hhckF0IiwibGVuZ3RoIiwiZXhlYyIsIm1lcmdlIiwicGFyc2VIVE1MIiwibm9kZVR5cGUiLCJvd25lckRvY3VtZW50IiwidGVzdCIsImlzUGxhaW5PYmplY3QiLCJpc0Z1bmN0aW9uIiwiYXR0ciIsImdldEVsZW1lbnRCeUlkIiwicGFyZW50Tm9kZSIsImlkIiwiZmluZCIsIm1ha2VBcnJheSIsInNpemUiLCJ0b0FycmF5IiwiY2FsbCIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwicHJldk9iamVjdCIsImVhY2giLCJjYWxsYmFjayIsImFyZ3MiLCJwcm9taXNlIiwiZG9uZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiZmlyc3QiLCJlcSIsImxhc3QiLCJpIiwibGVuIiwiaiIsIm1hcCIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJzcmMiLCJjb3B5SXNBcnJheSIsImNvcHkiLCJuYW1lIiwib3B0aW9ucyIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzQXJyYXkiLCJub0NvbmZsaWN0IiwiaXNSZWFkeSIsInJlYWR5V2FpdCIsImhvbGRSZWFkeSIsImhvbGQiLCJ3YWl0IiwiYm9keSIsInNldFRpbWVvdXQiLCJyZXNvbHZlV2l0aCIsInRyaWdnZXIiLCJvZmYiLCJvYmoiLCJBcnJheSIsImlzV2luZG93IiwiaXNOdW1lcmljIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiaXNGaW5pdGUiLCJTdHJpbmciLCJlIiwia2V5IiwiaXNFbXB0eU9iamVjdCIsImVycm9yIiwibXNnIiwiRXJyb3IiLCJkYXRhIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJzY3JpcHRzIiwiY3JlYXRlRWxlbWVudCIsImJ1aWxkRnJhZ21lbnQiLCJyZW1vdmUiLCJjaGlsZE5vZGVzIiwicGFyc2VKU09OIiwiSlNPTiIsInBhcnNlIiwicmVwbGFjZSIsIkZ1bmN0aW9uIiwicGFyc2VYTUwiLCJ4bWwiLCJ0bXAiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJBY3RpdmVYT2JqZWN0IiwiYXN5bmMiLCJsb2FkWE1MIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJub29wIiwiZ2xvYmFsRXZhbCIsImV4ZWNTY3JpcHQiLCJjYW1lbENhc2UiLCJzdHJpbmciLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwidmFsdWUiLCJpc0FycmF5bGlrZSIsInRleHQiLCJhcnIiLCJyZXN1bHRzIiwiT2JqZWN0IiwiaW5BcnJheSIsIk1hdGgiLCJtYXgiLCJzZWNvbmQiLCJsIiwiZ3JlcCIsImludiIsInJldFZhbCIsImFyZyIsImd1aWQiLCJwcm94eSIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiRGVmZXJyZWQiLCJhdHRhY2hFdmVudCIsInRvcCIsImZyYW1lRWxlbWVudCIsImRvU2Nyb2xsIiwiZG9TY3JvbGxDaGVjayIsInNwbGl0Iiwib3B0aW9uc0NhY2hlIiwiY3JlYXRlT3B0aW9ucyIsIm9iamVjdCIsIl8iLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJmaXJpbmdMZW5ndGgiLCJmaXJpbmdJbmRleCIsImZpcmluZ1N0YXJ0IiwibGlzdCIsInN0YWNrIiwib25jZSIsImZpcmUiLCJzdG9wT25GYWxzZSIsInNoaWZ0Iiwic2VsZiIsImRpc2FibGUiLCJhZGQiLCJzdGFydCIsInVuaXF1ZSIsImhhcyIsImluZGV4IiwiZW1wdHkiLCJkaXNhYmxlZCIsImxvY2siLCJsb2NrZWQiLCJmaXJlV2l0aCIsImZ1bmMiLCJ0dXBsZXMiLCJzdGF0ZSIsImFsd2F5cyIsImRlZmVycmVkIiwiZmFpbCIsInRoZW4iLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwiYWN0aW9uIiwicmV0dXJuZWQiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvZ3Jlc3MiLCJub3RpZnkiLCJwaXBlIiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic3Vib3JkaW5hdGUiLCJyZXNvbHZlVmFsdWVzIiwicmVtYWluaW5nIiwidXBkYXRlRnVuYyIsImNvbnRleHRzIiwidmFsdWVzIiwicHJvZ3Jlc3NWYWx1ZXMiLCJub3RpZnlXaXRoIiwicHJvZ3Jlc3NDb250ZXh0cyIsInJlc29sdmVDb250ZXh0cyIsInN1cHBvcnQiLCJhIiwiaW5wdXQiLCJzZWxlY3QiLCJmcmFnbWVudCIsIm9wdCIsImV2ZW50TmFtZSIsImlzU3VwcG9ydGVkIiwiZGl2Iiwic2V0QXR0cmlidXRlIiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJzdHlsZSIsImNzc1RleHQiLCJnZXRTZXRBdHRyaWJ1dGUiLCJjbGFzc05hbWUiLCJsZWFkaW5nV2hpdGVzcGFjZSIsImZpcnN0Q2hpbGQiLCJ0Ym9keSIsImh0bWxTZXJpYWxpemUiLCJnZXRBdHRyaWJ1dGUiLCJocmVmTm9ybWFsaXplZCIsIm9wYWNpdHkiLCJjc3NGbG9hdCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsInNlbGVjdGVkIiwiZW5jdHlwZSIsImh0bWw1Q2xvbmUiLCJjbG9uZU5vZGUiLCJvdXRlckhUTUwiLCJib3hNb2RlbCIsImNvbXBhdE1vZGUiLCJkZWxldGVFeHBhbmRvIiwibm9DbG9uZUV2ZW50IiwiaW5saW5lQmxvY2tOZWVkc0xheW91dCIsInNocmlua1dyYXBCbG9ja3MiLCJyZWxpYWJsZU1hcmdpblJpZ2h0IiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbFBvc2l0aW9uIiwiY2hlY2tlZCIsIm5vQ2xvbmVDaGVja2VkIiwib3B0RGlzYWJsZWQiLCJyYWRpb1ZhbHVlIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImFwcGVuZENoZWNrZWQiLCJjaGVja0Nsb25lIiwibGFzdENoaWxkIiwiY2xpY2siLCJzdWJtaXQiLCJjaGFuZ2UiLCJmb2N1c2luIiwiYXR0cmlidXRlcyIsImV4cGFuZG8iLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsImNvbnRhaW5lciIsIm1hcmdpbkRpdiIsInRkcyIsImRpdlJlc2V0Iiwib2Zmc2V0SGVpZ2h0IiwiZGlzcGxheSIsInJlbGlhYmxlSGlkZGVuT2Zmc2V0cyIsImJveFNpemluZyIsIm9mZnNldFdpZHRoIiwiZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQiLCJvZmZzZXRUb3AiLCJnZXRDb21wdXRlZFN0eWxlIiwid2lkdGgiLCJtYXJnaW5SaWdodCIsInpvb20iLCJyZW1vdmVDaGlsZCIsInJicmFjZSIsInJtdWx0aURhc2giLCJpbnRlcm5hbERhdGEiLCJwdnQiLCJhY2NlcHREYXRhIiwidGhpc0NhY2hlIiwiaW50ZXJuYWxLZXkiLCJnZXRCeU5hbWUiLCJpc05vZGUiLCJjYWNoZSIsInBvcCIsInRvSlNPTiIsImludGVybmFsUmVtb3ZlRGF0YSIsImlzRW1wdHlEYXRhT2JqZWN0IiwiY2xlYW5EYXRhIiwicmFuZG9tIiwibm9EYXRhIiwiaGFzRGF0YSIsInJlbW92ZURhdGEiLCJfZGF0YSIsIl9yZW1vdmVEYXRhIiwiYXR0cnMiLCJkYXRhQXR0ciIsInF1ZXVlIiwiZGVxdWV1ZSIsInN0YXJ0TGVuZ3RoIiwiaG9va3MiLCJfcXVldWVIb29rcyIsIm5leHQiLCJjdXIiLCJ1bnNoaWZ0Iiwic3RvcCIsInNldHRlciIsImRlbGF5IiwidGltZSIsImZ4Iiwic3BlZWRzIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImNsZWFyUXVldWUiLCJjb3VudCIsImRlZmVyIiwiZWxlbWVudHMiLCJub2RlSG9vayIsImJvb2xIb29rIiwicmNsYXNzIiwicnJldHVybiIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmJvb2xlYW4iLCJydXNlRGVmYXVsdCIsImdldFNldElucHV0IiwicmVtb3ZlQXR0ciIsInByb3AiLCJyZW1vdmVQcm9wIiwicHJvcEZpeCIsImFkZENsYXNzIiwiY2xhc3NlcyIsImNsYXp6IiwicHJvY2VlZCIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImlzQm9vbCIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsInZhbCIsInZhbEhvb2tzIiwic2V0Iiwib3B0aW9uIiwic3BlY2lmaWVkIiwic2VsZWN0ZWRJbmRleCIsIm9uZSIsIm5vdHhtbCIsIm5UeXBlIiwiaXNYTUxEb2MiLCJhdHRySG9va3MiLCJwcm9wTmFtZSIsImF0dHJOYW1lcyIsInJlbW92ZUF0dHJpYnV0ZSIsInRhYmluZGV4IiwicmVhZG9ubHkiLCJtYXhsZW5ndGgiLCJjZWxsc3BhY2luZyIsImNlbGxwYWRkaW5nIiwicm93c3BhbiIsImNvbHNwYW4iLCJ1c2VtYXAiLCJmcmFtZWJvcmRlciIsImNvbnRlbnRlZGl0YWJsZSIsInByb3BIb29rcyIsInRhYkluZGV4IiwiYXR0cmlidXRlTm9kZSIsImdldEF0dHJpYnV0ZU5vZGUiLCJwYXJzZUludCIsImhyZWYiLCJkZXRhaWwiLCJkZWZhdWx0VmFsdWUiLCJidXR0b24iLCJzZXRBdHRyaWJ1dGVOb2RlIiwiY3JlYXRlQXR0cmlidXRlIiwicGFyZW50IiwicmZvcm1FbGVtcyIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicmZvY3VzTW9ycGgiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsImdsb2JhbCIsInR5cGVzIiwiaGFuZGxlciIsImV2ZW50cyIsInQiLCJoYW5kbGVPYmpJbiIsInNwZWNpYWwiLCJldmVudEhhbmRsZSIsImhhbmRsZU9iaiIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwibmVlZHNDb250ZXh0IiwiZXhwciIsIm5hbWVzcGFjZSIsImpvaW4iLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsIlJlZ0V4cCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJvbmx5SGFuZGxlcnMiLCJvbnR5cGUiLCJidWJibGVUeXBlIiwiZXZlbnRQYXRoIiwiRXZlbnQiLCJpc1RyaWdnZXIiLCJuYW1lc3BhY2VfcmUiLCJyZXN1bHQiLCJub0J1YmJsZSIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIl9kZWZhdWx0IiwiZml4IiwibWF0Y2hlZCIsImhhbmRsZXJRdWV1ZSIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJzZWwiLCJtYXRjaGVzIiwib3JpZ2luYWxFdmVudCIsImZpeEhvb2siLCJmaXhIb29rcyIsIm1vdXNlSG9va3MiLCJrZXlIb29rcyIsInByb3BzIiwic3JjRWxlbWVudCIsIm1ldGFLZXkiLCJmaWx0ZXIiLCJvcmlnaW5hbCIsIndoaWNoIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiZXZlbnREb2MiLCJkb2MiLCJmcm9tRWxlbWVudCIsInBhZ2VYIiwiY2xpZW50WCIsInNjcm9sbExlZnQiLCJjbGllbnRMZWZ0IiwicGFnZVkiLCJjbGllbnRZIiwic2Nyb2xsVG9wIiwiY2xpZW50VG9wIiwicmVsYXRlZFRhcmdldCIsInRvRWxlbWVudCIsImxvYWQiLCJmb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJzaW11bGF0ZSIsImJ1YmJsZSIsImlzU2ltdWxhdGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsImdldFByZXZlbnREZWZhdWx0IiwidGltZVN0YW1wIiwiY2FuY2VsQnViYmxlIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsImNvbnRhaW5zIiwic3VibWl0QnViYmxlcyIsImZvcm0iLCJfc3VibWl0X2J1YmJsZSIsImNoYW5nZUJ1YmJsZXMiLCJwcm9wZXJ0eU5hbWUiLCJfanVzdF9jaGFuZ2VkIiwiZm9jdXNpbkJ1YmJsZXMiLCJhdHRhY2hlcyIsIm9uIiwib3JpZ0ZuIiwiYmluZCIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsInRyaWdnZXJIYW5kbGVyIiwiY2FjaGVkcnVucyIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJjb21waWxlIiwiaGFzRHVwbGljYXRlIiwib3V0ZXJtb3N0Q29udGV4dCIsInNldERvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50SXNYTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwic29ydE9yZGVyIiwicHJlZmVycmVkRG9jIiwiZGlycnVucyIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwic3RydW5kZWZpbmVkIiwiTUFYX05FR0FUSVZFIiwid2hpdGVzcGFjZSIsImNoYXJhY3RlckVuY29kaW5nIiwiaWRlbnRpZmllciIsIm9wZXJhdG9ycyIsInBzZXVkb3MiLCJyY29tbWEiLCJyY29tYmluYXRvcnMiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJyc2libGluZyIsInJuYXRpdmUiLCJyaW5wdXRzIiwicmhlYWRlciIsInJlc2NhcGUiLCJyYXR0cmlidXRlUXVvdGVzIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiZXNjYXBlZCIsImhpZ2giLCJmcm9tQ2hhckNvZGUiLCJpc05hdGl2ZSIsImtleXMiLCJjYWNoZUxlbmd0aCIsIm1hcmtGdW5jdGlvbiIsImFzc2VydCIsIlNpenpsZSIsInNlZWQiLCJtIiwiZ3JvdXBzIiwib2xkIiwibmlkIiwibmV3Q29udGV4dCIsIm5ld1NlbGVjdG9yIiwiZ2V0QnlDbGFzc05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidG9rZW5pemUiLCJ0b1NlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsInFzYUVycm9yIiwibm9kZSIsInRhZ05hbWVOb0NvbW1lbnRzIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsInBhc3MiLCJnZXRFbGVtZW50c0J5TmFtZSIsImdldElkTm90TmFtZSIsImF0dHJIYW5kbGUiLCJhdHRySWQiLCJ0YWciLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsImF1cCIsImFwIiwiYnAiLCJzaWJsaW5nQ2hlY2siLCJkZXRlY3REdXBsaWNhdGVzIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkaWZmIiwic291cmNlSW5kZXgiLCJuZXh0U2libGluZyIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwidGV4dENvbnRlbnQiLCJub2RlVmFsdWUiLCJzZWxlY3RvcnMiLCJjcmVhdGVQc2V1ZG8iLCJyZWxhdGl2ZSIsImRpciIsInByZUZpbHRlciIsImV4Y2VzcyIsInVucXVvdGVkIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsIm91dGVyQ2FjaGUiLCJub2RlSW5kZXgiLCJ1c2VDYWNoZSIsInBzZXVkbyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwiaW5uZXJUZXh0IiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImhhc0ZvY3VzIiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwicmVzZXQiLCJwYXJzZU9ubHkiLCJ0b2tlbnMiLCJzb0ZhciIsInByZUZpbHRlcnMiLCJjYWNoZWQiLCJhZGRDb21iaW5hdG9yIiwiY29tYmluYXRvciIsImJhc2UiLCJjaGVja05vbkVsZW1lbnRzIiwiZG9uZU5hbWUiLCJkaXJrZXkiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibXVsdGlwbGVDb250ZXh0cyIsIm1hdGNoZXJJbiIsIm1hdGNoZXJPdXQiLCJtYXRjaGVyRnJvbVRva2VucyIsImNoZWNrQ29udGV4dCIsImxlYWRpbmdSZWxhdGl2ZSIsImltcGxpY2l0UmVsYXRpdmUiLCJtYXRjaENvbnRleHQiLCJtYXRjaEFueUNvbnRleHQiLCJtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMiLCJlbGVtZW50TWF0Y2hlcnMiLCJzZXRNYXRjaGVycyIsIm1hdGNoZXJDYWNoZWRSdW5zIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJleHBhbmRDb250ZXh0Iiwic2V0TWF0Y2hlZCIsIm1hdGNoZWRDb3VudCIsIm91dGVybW9zdCIsImNvbnRleHRCYWNrdXAiLCJkaXJydW5zVW5pcXVlIiwiZ3JvdXAiLCJ0b2tlbiIsImZpbHRlcnMiLCJydW50aWwiLCJycGFyZW50c3ByZXYiLCJpc1NpbXBsZSIsInJuZWVkc0NvbnRleHQiLCJndWFyYW50ZWVkVW5pcXVlIiwiY2hpbGRyZW4iLCJjb250ZW50cyIsInByZXYiLCJ0YXJnZXRzIiwibm90Iiwid2lubm93IiwiaXMiLCJjbG9zZXN0IiwicG9zIiwicHJldkFsbCIsImFkZEJhY2siLCJhbmRTZWxmIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJ1bnRpbCIsIm5leHRBbGwiLCJuZXh0VW50aWwiLCJwcmV2VW50aWwiLCJzaWJsaW5ncyIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJyZXZlcnNlIiwibiIsInIiLCJxdWFsaWZpZXIiLCJrZWVwIiwiZmlsdGVyZWQiLCJjcmVhdGVTYWZlRnJhZ21lbnQiLCJub2RlTmFtZXMiLCJzYWZlRnJhZyIsInJpbmxpbmVqUXVlcnkiLCJybm9zaGltY2FjaGUiLCJybGVhZGluZ1doaXRlc3BhY2UiLCJyeGh0bWxUYWciLCJydGFnTmFtZSIsInJ0Ym9keSIsInJodG1sIiwicm5vSW5uZXJodG1sIiwibWFuaXB1bGF0aW9uX3JjaGVja2FibGVUeXBlIiwicmNoZWNrZWQiLCJyc2NyaXB0VHlwZSIsInJzY3JpcHRUeXBlTWFza2VkIiwicmNsZWFuU2NyaXB0Iiwid3JhcE1hcCIsImxlZ2VuZCIsImFyZWEiLCJwYXJhbSIsInRoZWFkIiwidHIiLCJjb2wiLCJ0ZCIsInNhZmVGcmFnbWVudCIsImZyYWdtZW50RGl2Iiwib3B0Z3JvdXAiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwiYXBwZW5kIiwiY3JlYXRlVGV4dE5vZGUiLCJ3cmFwQWxsIiwiaHRtbCIsIndyYXAiLCJ3cmFwSW5uZXIiLCJ1bndyYXAiLCJyZXBsYWNlV2l0aCIsImRvbU1hbmlwIiwicHJlcGVuZCIsImJlZm9yZSIsImFmdGVyIiwia2VlcERhdGEiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwiaXNGdW5jIiwidGFibGUiLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJkaXNhYmxlU2NyaXB0IiwiZmluZE9yQXBwZW5kIiwicmVzdG9yZVNjcmlwdCIsImFqYXgiLCJ1cmwiLCJkYXRhVHlwZSIsInJlZkVsZW1lbnRzIiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0Iiwib2xkRGF0YSIsImN1ckRhdGEiLCJmaXhDbG9uZU5vZGVJc3N1ZXMiLCJkZWZhdWx0Q2hlY2tlZCIsImRlZmF1bHRTZWxlY3RlZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwiaW5zZXJ0IiwiZm91bmQiLCJmaXhEZWZhdWx0Q2hlY2tlZCIsImRlc3RFbGVtZW50cyIsInNyY0VsZW1lbnRzIiwiaW5QYWdlIiwic2VsZWN0aW9uIiwic2FmZSIsIm5vZGVzIiwiaWZyYW1lIiwiZ2V0U3R5bGVzIiwiY3VyQ1NTIiwicmFscGhhIiwicm9wYWNpdHkiLCJycG9zaXRpb24iLCJyZGlzcGxheXN3YXAiLCJybWFyZ2luIiwicm51bXNwbGl0Iiwicm51bW5vbnB4IiwicnJlbE51bSIsImVsZW1kaXNwbGF5IiwiQk9EWSIsImNzc1Nob3ciLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsImNzc0V4cGFuZCIsImNzc1ByZWZpeGVzIiwidmVuZG9yUHJvcE5hbWUiLCJjYXBOYW1lIiwib3JpZ05hbWUiLCJpc0hpZGRlbiIsImVsIiwiY3NzIiwic2hvd0hpZGUiLCJzaG93IiwiaGlkZGVuIiwiY3NzX2RlZmF1bHREaXNwbGF5Iiwic3R5bGVzIiwiaGlkZSIsInRvZ2dsZSIsImJvb2wiLCJjc3NIb29rcyIsImNvbXB1dGVkIiwiY3NzTnVtYmVyIiwiY3NzUHJvcHMiLCJleHRyYSIsInN3YXAiLCJfY29tcHV0ZWQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImN1cnJlbnRTdHlsZSIsImxlZnQiLCJycyIsInJzTGVmdCIsInJ1bnRpbWVTdHlsZSIsInBpeGVsTGVmdCIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImlzQm9yZGVyQm94IiwiZ2V0V2lkdGhPckhlaWdodCIsInZhbHVlSXNCb3JkZXJCb3giLCJhY3R1YWxEaXNwbGF5Iiwid3JpdGUiLCJjbG9zZSIsIiQxIiwidmlzaWJsZSIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwicjIwIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUFycmF5IiwidHJhZGl0aW9uYWwiLCJzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYWpheFNldHRpbmdzIiwiYnVpbGRQYXJhbXMiLCJ2IiwiaG92ZXIiLCJmbk92ZXIiLCJmbk91dCIsImFqYXhMb2NQYXJ0cyIsImFqYXhMb2NhdGlvbiIsImFqYXhfbm9uY2UiLCJhamF4X3JxdWVyeSIsInJoYXNoIiwicnRzIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJydXJsIiwiX2xvYWQiLCJwcmVmaWx0ZXJzIiwidHJhbnNwb3J0cyIsImFsbFR5cGVzIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJvcmlnaW5hbE9wdGlvbnMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsInBhcmFtcyIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0IiwiY29tcGxldGUiLCJzdGF0dXMiLCJtZXRob2QiLCJzdWNjZXNzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsImlzTG9jYWwiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwiYWNjZXB0cyIsImpzb24iLCJyZXNwb25zZUZpZWxkcyIsImNvbnZlcnRlcnMiLCJhamF4U2V0dXAiLCJzZXR0aW5ncyIsImFqYXhQcmVmaWx0ZXIiLCJhamF4VHJhbnNwb3J0IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJ0aW1lb3V0VGltZXIiLCJmaXJlR2xvYmFscyIsInRyYW5zcG9ydCIsInJlc3BvbnNlSGVhZGVycyIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRSZXNwb25zZUhlYWRlciIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJsbmFtZSIsIm92ZXJyaWRlTWltZVR5cGUiLCJtaW1lVHlwZSIsImNvZGUiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzZW5kIiwibmF0aXZlU3RhdHVzVGV4dCIsInJlc3BvbnNlcyIsImlzU3VjY2VzcyIsIm1vZGlmaWVkIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsImFqYXhDb252ZXJ0IiwicmVqZWN0V2l0aCIsImdldFNjcmlwdCIsImdldEpTT04iLCJmaXJzdERhdGFUeXBlIiwiY3QiLCJmaW5hbERhdGFUeXBlIiwiY29udjIiLCJjdXJyZW50IiwiY29udiIsImRhdGFGaWx0ZXIiLCJzY3JpcHQiLCJoZWFkIiwic2NyaXB0Q2hhcnNldCIsImNoYXJzZXQiLCJvbmxvYWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJpc0Fib3J0Iiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsImNhbGxiYWNrTmFtZSIsIm92ZXJ3cml0dGVuIiwicmVzcG9uc2VDb250YWluZXIiLCJqc29uUHJvcCIsInhockNhbGxiYWNrcyIsInhoclN1cHBvcnRlZCIsInhocklkIiwieGhyT25VbmxvYWRBYm9ydCIsImNyZWF0ZVN0YW5kYXJkWEhSIiwiWE1MSHR0cFJlcXVlc3QiLCJjcmVhdGVBY3RpdmVYSFIiLCJ4aHIiLCJjb3JzIiwidXNlcm5hbWUiLCJvcGVuIiwieGhyRmllbGRzIiwiZXJyIiwiZmlyZWZveEFjY2Vzc0V4Y2VwdGlvbiIsInVubG9hZCIsImZ4Tm93IiwidGltZXJJZCIsInJmeHR5cGVzIiwicmZ4bnVtIiwicnJ1biIsImFuaW1hdGlvblByZWZpbHRlcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwidHdlZW5lcnMiLCJ1bml0IiwidHdlZW4iLCJjcmVhdGVUd2VlbiIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImNyZWF0ZUZ4Tm93IiwiY3JlYXRlVHdlZW5zIiwiYW5pbWF0aW9uIiwiY29sbGVjdGlvbiIsIkFuaW1hdGlvbiIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwidGljayIsImN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwiZHVyYXRpb24iLCJwZXJjZW50IiwidHdlZW5zIiwicnVuIiwib3B0cyIsInNwZWNpYWxFYXNpbmciLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJUd2VlbiIsImVhc2luZyIsImdvdG9FbmQiLCJwcm9wRmlsdGVyIiwidGltZXIiLCJhbmltIiwidHdlZW5lciIsInByZWZpbHRlciIsImRhdGFTaG93Iiwib2xkZmlyZSIsImhhbmRsZWQiLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZWFzZWQiLCJzdGVwIiwiY3NzRm4iLCJzcGVlZCIsImFuaW1hdGUiLCJnZW5GeCIsImZhZGVUbyIsInRvIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJpbmNsdWRlV2lkdGgiLCJoZWlnaHQiLCJzbGlkZURvd24iLCJzbGlkZVVwIiwic2xpZGVUb2dnbGUiLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsImxpbmVhciIsInAiLCJzd2luZyIsImNvcyIsIlBJIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzbG93IiwiZmFzdCIsImFuaW1hdGVkIiwib2Zmc2V0Iiwic2V0T2Zmc2V0Iiwid2luIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0V2luZG93IiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsImN1ckVsZW0iLCJjdXJPZmZzZXQiLCJjdXJDU1NUb3AiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJQb3NpdGlvbiIsImN1clRvcCIsImN1ckxlZnQiLCJ1c2luZyIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJjb250ZW50IiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJkZWZpbmUiLCJhbWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/jquery-1.9.1.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/jquery-1.9.1.js");
/******/ 	
/******/ })()
;